<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>2021-04</title>
    <url>/2021/05/09/2021-04/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码看着不太对, 请再试试." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">
  <script id="hbeData" type="hbeData" data-hmacdigest="559bb016a7b683e087182fe3d4bdc2da3845dda9fc230d30912d8fdbf107b388">21b5bcc0e4657ce349e1a94ae87ceae1a9376f37946b70d81ac91823600fc4d803a1ed3e8fa7be80e915603c3aebda7a1a3794efaeeda38670c95035a1928cd0af7f76b9652b19b91717419ab210764e8ffeb86209895da58b8659646f579364e8184ea6a589be511dd7abd9cb341256faad0e6b48a2f404b3bb714afb3f30815ec798a6bf552c2d3b45ff2e16ec1be50986edac99379e39baf2e19596f36c13157f6065d062ab8a3694190fe30769c58e80656847439818e890ec3794934cb2b7c13b8147c006e632c010358608e240fb887ced6d2aaea9cc8662af2438deffced61148e08e60e740a60600b31b38a131fd874d7edc990a894e34a7e74dea8548ae913813b4f305cb6c29803d8b3f1e86e679048394bddd55ed392217327917b815981669f00fe53df155b35aa15e460b92a207e30e64e0973e4ff6dff86221e817ca8e9bbd11e4ec896d76c23abcc3dbc96d9cbc1e3a9cd3578c2880150768966a629892546140a94ff267b551ade6fdf363d657b99145962b8d14f5dafadaafa55893fdee5ae47cb269142188669c7f7f16ab23c651b788591b8f5b31bf3504516a3cf04dea81b9a7875f618863217449af529d8faed9cdd9f4c182f07876582fe809527735be7e9889e3bb625b7ba3d5cc5e5be7ec38fe502b39b4f15a3ee8cf1dda45fb72900bbee6d073c420eb9d55acbb477dbb528b4a27392882a41a275334f7a4b1f2bde995aa1511beb3cdd93772542cd73dd14797ad8d2df716592bb1ebf12dd6206151fe89ff445d8e7939162fe37b715910bb6a1fe76319a4585c21510821c8a4aa2441e06cf577a7a5d461ec827f53f89f07f34450023e39a67fd670da50ff72a2e5eca0178f57ab07428390c602db7b8210dfdb50d18efa428873862561f5106c3cc0e2592f7b20036952405836c45ccae2a433697963d58375ea0f113146e9dc1c4a57694b9613d60c86e99449ebe6fdc6dff438b1f4cf7fc5b82c68c002bd68ad567341d2f320c74f584d9629e1fc1ab041b51a9fcde2db59b33ba0a06600a52b5811fc6529707ecff3fd74c8c7a7738d1c6e10051c8d3bb9a76141991f9c4be8582c35348c7aae4a33b238d54182d31dded1008a447f4a6b1ed1418cf774cd1cbae887db9f1bb9bc026a4761e8aa6ec998bcb8c1d3d2e36d6a57445fc4d822ebfc74f784c3510b7c86ca63b10276f9c288d1b9bbe1b3c2fd90dfecffd8e37fe96e81ad6d78387249c713275ea8dfdc23f998236f86cfca74f8960ba558e18263904b832554fa391af7f5645b974b9a744e872587a8b689c1631c0691b82ebf0b4d1a6e915cc8bec74fdbb700e9bfb69d4f618f137e1d30a42fc54a3b678b45e8f1e0c8bce37c24b6236d618f7e2f919e84453fab4ff1e8ed818c62c4231d1656cc4d18c34faf1ac871149a050bf9155a97b51c66e0f9e67f6500a36f9e0c15cd7ff3a22dc442dd427e40c20cbf5b3ec9abec674b261b059dd5f1880873c9cdf3943296c8c4949a8fce596faf94a6f931e687701da23238bd7b16d662ffb36b796ffb6f85426931233efdd195272f5ad1ad3a0f5eebdb55ac51846947cf4f1214c7a33d4560a569fe70fa3491abf03be15dabb9b62d8dd73100bb31ad3ee49f34c334fec0f921b12562482592ca982f43684aa356234fb67e44e9a2cdf219f00e9cb1520f0b2103d8206aa9cf1325da068500596d975193be7c08b3f03d57f42fdae1776b2cac3e9c2bacd231a48d9a329352ebbc1f32d95c2048f01d5b36c680403cfc268038785831225247397f026e018e4db02117e8f5290bb9e511d24613ef82f63d8eb8f7590182ac4679e4e7171ea19ec83eb70c1a4d3a9150180b91d175ca5745bce765856e456d7f8b41d18cdd9b725d1a68670920a39d70d75be352acfd5fcf105f1d84d0cb43729d667823b3f2fa03c3ba73</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-shrink">
      <input class="hbe hbe-input-field hbe-input-field-shrink" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-shrink" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-shrink">您好, 这里需要密码.</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>月度总结</category>
      </categories>
      <tags>
        <tag>月度总结</tag>
      </tags>
  </entry>
  <entry>
    <title>2021-05中</title>
    <url>/2021/05/13/2021-05%E4%B8%AD/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码看着不太对, 请再试试." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">
  <script id="hbeData" type="hbeData" data-hmacdigest="434362b6d5bf1de965f6b20a54cffdd321227db468f5ff46665d506236a4830a">21b5bcc0e4657ce349e1a94ae87ceae1e652eabd69160199cdff8ea5fcfc8d1ad7c067d9df7415a4575f28dad82f855778b8e562ec1e90d857d0bc3b7aeabea32c30d50b8b4683e8c9f7f4d8abd45062160dcc9d870612ec88e83e88e9ec8054b9147b04247841e7eada34161fac903d09744daf0f799605b3f237167146dfde367cc27041c3987a44dd40c5fd4953470c6de972945241541fb5c239e3ff339718f5344d1026795cef40af977be6892a</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-shrink">
      <input class="hbe hbe-input-field hbe-input-field-shrink" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-shrink" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-shrink">您好, 这里需要密码.</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>月度总结</category>
      </categories>
      <tags>
        <tag>月度总结</tag>
      </tags>
  </entry>
  <entry>
    <title>2021-06</title>
    <url>/2021/06/15/2021-06/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码看着不太对, 请再试试." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">
  <script id="hbeData" type="hbeData" data-hmacdigest="3bcf438568863af00b2bf9b2124d692dd4fb35a0e9ada952eaecbdcb4b7cb1d1">21b5bcc0e4657ce349e1a94ae87ceae147df196a4073e9c70dd489b2c20970c7482df6c780f57ead05a8a0f8034437b7f247065939b2ecf68bdb203b1e71fb42162279677ddf339b6849f5d8ff6427b5fbfe2e251719711b9a2a12fa21687b233bd33540abe89150e6bf2ab4c28043d735971b2e32c5b0594e3e9a34280c86ff54ee91b7a7ea7b0ba573611eb7e460dfd547da7782c3f75e2e0513049fff64f5af5c36b3f1d342649f691c231cabed87eca039e484e1eb72c190d0d4b484f519bc387c5fd8b04b20e72f320c7ceb5a1c8851ad5f2b0b4720330e84d4e00f04b652b4fcf12987959f8fbaa440257f332091108cabc4640b1ff998d851212354f297c3e63bea2bca3d1485398275f4484f923321a23c70e85408ea1b9d8cb7a093aea5dd92a8f23837326c7796cadc01e2d4585e78594e7dc5071a8d3f4242cef3d5d11527ed80e32f7688066b79e5200cb5cc17116f7a70c926aba1e9b3eefb2735a9ed2cf1920f6fbb21e0cd01f4269b23d76272ba8ca2e8e0f8103b00ffdf06a87c4c3fd63e3d626b17d905fd833334899c28f1cbac8d893b7313f3e9cba1dc0571b15c02c9f1b7b465850965925405562cb22f28c042a1134866fc911a6bec0c1344cf65e1399232ef05886c01775853350fb2569491f1baff739072b4b3195805d3900144bb49994512ba73522cfd82d8c1ddffc50de548c2bee8ece70b2a72d82c34d98f01e0bf8f722d4ee6a29952480a6d711c97c8449d2ada360509d548d9345042c6a89da38b986c20ad5223b5c1f5fd852cf88d14a0d2ae7dab5d100f39770a0fa4cbcabe53bc6db24211a1e9af66a5e2b32f53ece470679bfeb6aba7dc2a7f76b2c34e0a3002d715c21c9ea6d8b2bcbee15ab4ba95dbb701fbf94d6bf373fed9a8c0652209c069736eb8012cb054cb4e5f6a26b11a18d59c5c44b8b1ad37ad58665d54bb1890fa3c984e0f3f611c26da3a14c64d65488723e35b07f0a3b037ccdf566e5db5142b2be437b53406c0ef6cd6018cb521a7f6563f2d87eaa3226f10f7770e4bf5a79a5e9cebf0276882577e99514eadc131111f68a6eb53d5dc048a0567a5a85701cc9b0964338d3b659784bb95845e0e55bb561e3d735e183f98a7923e38d255a1bc62d4e0b57a9a3be386fe63b2b9ec7a2ad619e19d43ba3debcbf4aab163b2575fe183124d76e7ad2bf4f68b535c921f86a0c77751e1d96efc01c027fff499e2d4db650fedf271683f19440af71d0148a78732b32538655494ae2c9f8d2983bc138be894185b046d7dda7d357bd0f457250b52e7a1b988f9e7fa739a284777dfdf29e54f824d1e2714727ad91a5177edad6226b128fecc60b082c8c9fc5cc230300d1dd4097b8921c672ed92cd85fcbc80d94a24febe9037be9a467e419edac12aabdf09df41b7f62310b83f2f210dc0e30859bc84ae1d9fb18565dda23b1dbca95798e1b8b629c16a6084e3e41412ba616e0c26f2a905e8646a0ff92c4521a81f6250d264118a0c3a8decd9bbf839a623c949118537e848fd271a923866fc02784071846f84d324d2210b26d59afff12b7333038b65b9c46c5f0d422536bf6e54c11581c6a7748c128ea7bed34f6276f2fc85f48c94532284870eb29f05a6813ebf67ec239e89347b85a63e30bd24989901bc4512cb720bd099fba85f226881b7340eb7422e6d4cba2884942cf96ffe63a5334c3f5d5e899ffbcb4656ded4308a9f7afd822066bd22a7f8a00f5e3772403566c43fb052e8a03c0bcb372f84198d98edda4cb777adda7335c052acd2aa7bb91894785d9d0dfd14f47839af4639faaf734eb526d3d6e90a42a1bb15cb782ed5f931898894453925b3b3d359281df393c23d1d3b86fd69e0ccf7ca6ebd6856dbc09a9fb42333994748c3fe291f77511cd388a4744f1b0ad9dff9da342dd59fcf26971d86890e120d3e0aa0b8257b1c7b93519e615682ed54789b62e2a4f360ebc173f088ef303c799455e6ddd1f99a7eb0395203b532a678351c91f1bd00904f47666365add7fe7e97377ec3a65e7d3fa67902459dac29d867aafa32185fb5ddd5de5b31c7aac90223be89e14ebbbc731f9e403143a9c60964ef942c6e8ae9783bed9679b88176597c686aa07fbea9525d227611259e39f280c3b7a2d93079e641b18caa588e8a133841a07a05449e0de3ec9ccb0118ea84dc04b37ba4de1c70c5e4eea1d8deedfb5264a4913fe99f67045cccd5699328ee8bf3eba349a47fc5768d9f1c6cb702f980d5c0f6e9bf0f72621b96f424c2b6126e8f1b2a94691c4bccf69f407448559efffeb2648b765ca8c6d593e68d393e921969bbe7e4db554998ee5cef1758d7f843f8d7db7a1cdff21619bc6ba871317b2ca5a22f2840f5903c17285555ac47f0bf65188c470094c9dc49c380dbb7c60764d699a0ac4de7100c2608d9cd12388e3b68c3791d433b412caad023338dea3ab818c07bab95d01d06abe7d1a4664902a1d8b8b9c11c321c179668a69cf80386116b7fe567edbd96089f4279292fc1c3aabf10c0475a9c1aa9eb949950313649cb33d7ba412f346681ccb279a7130b831a773a5358afdc6381de77cd9610a1d5d5964fc26895042f0e235fa03876e1245f3df001cb9451fab18e2844fa31549ce579e3b63105c6f0455625a412c4793fe538f488de6939dd61d7dfc292796cdacaba4d163f89a18662ab28ae97fabb6a2b387f6a32394c81809ccef7f66597a122be1d262bdbcefe063c892e2a0fce97cf6e1146569781bb1e81e349522ca79efc91b863aac25bf058c5a0f13a85a2fed5ff5ad8c1a687bc8aa28343a4192bedf10536f407a0f94b156b20b9a905c27c6ce2d4b4a5440e0b39c84c87666db011639df6c5ee1dcbd9384a1e5f6f26ef1476a97b39772b065003f84e53f3b20c7456973e5db1d262e01b20ada5d9606acf9d012e78bbc4053101f82a4c7a030e2f5f3f5cb0cd25f4f61f950b58422eb66c9019b61c57a1ba29e2755ee3d1a938f97ba877694cbf9d71171576d9ea1f5f04f6c97c08ada20ae0454c6a15ccc07ad5a2e0cd6a2360222857e4e274feda47054b4da9f3bf788b5b84bd9898b1e8fb0d95a357396f53aee3292080323d84d85e68eb5e3d38b54aad77253803aeb695d6b3351b12a98bf954a9a5e2e1ff3c7d004349e5cf5de06f26e19773a2095d26d32545bc9c9cbdc59b07f46b0c9fd3fcd3d6a7c72e435ae8c1313f3ee0996ef4b84ab959de221f1fec699c2597e3972885abe792185827b0f9ae11fda3e33c774e24040d2ff34f5bf0daf4fd046936f64c703b535ceab7ebe783a927db53791c154992bcbdd44e37ecd851d580f7f25e50fa5d6e04edb6d55fd0a2215ceeec8bc50fedf03c1c4f8cf60ab7c708c5a5f8d4af185276f30969e6e9fefcba682708bfcc919519d97c08af619214d7458348d86e3879c859e8133b9dee419c39f1015440503694d08625965eb02defa79ecf46770a54290ee55c52063c2c1f31943b131c00bd28f9878598f9878a8bac7a4055fdb89f0e4449ed28f573ddbd247d4f0f60e04271c6419a3b677bf048813c848a19c13b2af465a6ebe218cfd1a5b651b94e0432f64d54b9d2ed18604105b34c55cf95589c7999c52312c801d74645a6e897def7d767316d3be495f9c061807c6dd3d4bc30228a647414f6be02d0d1a7671384e0fb9839165472911c1a616bf17eba713d58fa36e7520f9ea0d57bf40b78d32a40c9b35fb50904d08d7365b90d623b34e9af4d47db60f401b67eb93c03e39ee87bb8c90d53679a4751c6273f4f171e8172a76f1034fd53884fb651899f25bb50de0a086b10ca28e552bf634d3b295171eb58597671365f76604171e7982130229656f73ccde7c0c05b6b9f0ac43180129203caab4e3ad9787c0c03d115ed7b53c37c8685d004b09bb2049f203eccc12bf46c1ff76350169703def9e033cdb6409ac1852a59e7c3ed91bc63f978778d770a9048225e78bdbb73b9d4b3bcbe78877af9644ae58727fa011792aa0bab6688f813c71757768bd5ea87dd74c0dd6f6259ff829947c173b59365f80cc06e8a1eccb70a98f0968c8c351b3ce411d1f3b791eb9e6b991ba36896404528f6a722e1a4baf14d5d4142850668584a9a75a8489fc604000510f0abe292da036331cfb566b11a3abee780ace284333615a4eb079a88049b59a220b548aa2134f79ee8e8fc15826a59bf09f76c1434e094d5cf4732db8da8da97c13dd7a26306f0d31709e02a196a897f41b72018ad03302fe18069527154c1642fe8b234da6ed8cd6bbe9a6493366ec6971c47cf7c58fe5c08d927b1ea729a79410a37a217ca55d44510049e46cdd05352b4aa5100b230045628a4510a50acb563a196c5c06a7747f0ff1db932ededa4f06df85dbe34f0984199a12cb4c0f6fd3005365d2871b546a232e45f8e9ca9f444bbf0827f630f2e9ba4f0fe2cade18e5938baa185baba04eac89cf604f0670c44fe0452632a0a0d924e6c4280f3314c989c470c104f5d0c4f11b62ccaeddfc72b02a6dde84774a427e1ababb4379f2a1397f437a2e7ce2910bc7c49e0553869173f3ac72386a1cdcc65e87eee7e7013ee6f4405d2786eee6cbf7bec2408b670b0a7b21066c97ae1b514e47b48f9a9a94691c1c187cb00db87ac344a9b6892896fd7e247b1cd2319cc213ab84ac79fcbef11f676ddc946ec97f126ddc078bb4fd837715f0e89fcf8c9377288fe8eac73b34cdab275920a3af94a6bb585c7c9a1b9ae1070e65aebeea95e7ac5aa2c3993a99398d59f64de06deeb63643014144ee264f6d8c1661e3f2023ee5d8728810addda9ca5df52ea29756f6bb3a07e8616df843e6cb0ef9de02a813f9bf87a536e75bdb190d1710b56d2c781389f63af9fe1daa6ba8979549e525cae3b03a93e35e6341408d984700a5831951a2b2c9b7d8557b293fcafe5ef9d487f87057152d65ce562ac45009c1ca5c64ecc1623530477a111b98bd8c98b8e75f9fd15aef70791e5cb5f01b5a173b556ce4dd5ee38501b4994a91830c5b646023df65940a3a4c30342d679b78e9a1b849cde506ab3fd4c4107ee858a9c6f7308b297d76e7389071e53911feef63767dedc0fae481259ed8d411132e55fec950f30a08d77c7485c948be6e51a2b97c00e1e77375907079ee5a1485adb814cb226421ab03e6c23b054822883e49c006d1ccdc78e3f5f88d863134799203c98a306d1f56f985cd352877e029768ce98540008ea405a7984aa99fe10f101f4e1c52414bd77fa6653b7a8a863fed459d397e2d77299ab6c36a6095eb0451e21a8813bb3069faab1111160e8e3576d9738385d104d6e169bed86d80bccdd3be2f019d86deb61450a592782c580bc3f15df13f76b30e25b0a56860dd43b018c2822601fd6164c839b4d248b34acb53d3ee29cd6fe73463dba563cae094bcf2769ee8a72ca21db65b983436e2df7e4671d080647ffaab0acfbaf35781625c83b1228a84d180d48c5a30c08fd16a0cf4541f1ffd0554b4b07d52864969b7ef08979b791eae737a37511d5b865a4749ca8d89fb77e35015bf4c5ca67c7720b235f78a2005e734762425e1c1a719cde0ab8e2b74835b166aa5ff12a41ff030f67e70068bd93e57398eae1444e479b</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-shrink">
      <input class="hbe hbe-input-field hbe-input-field-shrink" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-shrink" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-shrink">您好, 这里需要密码.</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>月度总结</category>
      </categories>
      <tags>
        <tag>月度总结</tag>
      </tags>
  </entry>
  <entry>
    <title>2021-07</title>
    <url>/2021/07/01/2021-07/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码看着不太对, 请再试试." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">
  <script id="hbeData" type="hbeData" data-hmacdigest="4066ed5f243e4930a7fd7a26518b7e9c99315186c29ddc4066ae9a8bba0b1c77">21b5bcc0e4657ce349e1a94ae87ceae177e19bfdd8f117aa27ee9fb5fc3b17b3f8b37f6b40da0d81eb0555adda5d8b08171fdc521fa8de9c5ea080f2959f604df9ac0d04d53e570ceac35b2aa07c53f13bfd8dd6c903c8279af7e0f0ed27c2bcfb2ba222dde9f7eba712ebd6897f9f7fcf768525b2e9687d76fdbba4bb722a77e88545b174655d61b23558675d3c80e382405972dafb5736441a0d0586726bb739008ef7f91f0a95be654ee93b2ec29968f165b0e0a4023088e426b1d96b6f447db36e009837f4df7db55b8ad2cfcedbcf4f4aebb4fd04eaf11395f9143751604482d4a454fccd51b59f2912282be37d11323e8d4e0c720492ad16bd41f5e3fcc27496326d797c13f3af9b85b745c96491b61aeb4422f78ee66d14db869d841ae724f539350ebaa6bfcbe8ecffcb67911fe5fc8c6fe5c9e28ce3bc8778c20b1003502b7c64c233aa4ad29786d09217bf2f77e1b8e91f60f112f8880d8f4ea1a03d95fea400b0c165393d9f95b0c0eb5f550f39511e82cf6db465bf62b932f7eae2b87093cec170260bfc105bfc9948ff82203860a9d0282261449fb36e0290adf754d85e07d6822ec221688c7648b23610c59a8a13ba6d34788687f2f2b05ac5dfc0b1410726010886e2b837dfa6fcababde93810098acc5b6da13cc2130c7219dd942c9023276ff74894de48c6b9dc42ac1967e1997cd49b4c40ef87a0cf94be23365f8b26690b91b1959a3d93579ae18ca6341cbffb5bbd7e57fbdc78c0c99dfe7502b37ba9eead8fc70ade935ef108ce6c0147c1ec619a533cfed3b0f6c1ed2ba06a1533aaeb2faab313121301b9df341d7c1c98ef72f2ad44e17d22bdd30a008fb1b4cb14ae6c6a92444715b7699fac05cad567fc710f4f47b1caab43393aa705f4c793fe9dae840b486a05e99e8000b52b68c275e92561572a585c29e9d9fbf945364b0bd2c2bc1ca2e0bac8b662cec01c571e31d1679f28e6fbb4f66b385d8b1d799861148b37155e16871fa88823e41fdd3a655b2deb3f3f7e85a0461e5f91cf9ae1cc085ff245ee6fa629f2602697e47371500ae3a461d9a7c62b2d3d9c30035401b2fdb22369a67592c9a12b9839d5775efacc4828b155295ca8d4783307a62ca3c9a141cbd02c639232eb2a5faec73eacf717f1484af0d9c78e0d4843c0c346aad875e70aebf30b05adccb2259925d0fd6a0994b2619f0c2ca02ba21e5493ea08375d537c6b8e398302a3959abe58665b4a26066d3aa8f66ff0ca3fb78b8dbe56a31937e179d6bc4892cc2ceb966da791a39ed54843abe8ed0aac0e6995d75472ad01110c2a9c3a6e35633f2585cc7e6674f7f8b587d30a0e9b6f2a085a895ec3bb6cb1bd210dd389491078256a4c8f19e0f6df4e6ff8ad889f1a2e9094b5640afdb58c35d8d5c5922812dcf706576f6bccd8eb34c1101101163e42537e0217a3da02e3dbb517d5229c508a9c3f8d04f151a0a6c2bd648052ec3fd5d1ffbb5c79af78cb9d07919fc911614faae57aaef80a75165be2ba7f40b4be4c4f800b387140b377768a4acc010ab31fbdc79425837a6f767cdcd050ae6b3e5d97d92fcafe0a23c6c65cef4bc86bb8db8e07cf501c1f9d4e999f533f8343e25fc91823ded1b7981aa4f6c6c48632768353e267ffbe592a7a2fe40781a58276288e5b57eef6a0241845e0d481a47f4c390ea9eaddf6f525a5dc10479f6cc805eec3d5b37aecd939512a1199a6c1386a8c6a9c182cdb7895d09055210ffed044a7e8f5290c91994656bc9079a78543e8066dfcccf12143626e7e7c257340463958076f78adaf9023e3c08cc9370fe5b331d3bd2f733d03ae3de3c38f0ecd82ea4c2853e70aaec8d8dde07d76b0d910aa9bb40564885676d285a02faf5db9c9c783a6f1a7a398fe37a7f3371b4aad124ed3376d5aaa7b356eef2f3db50d298ad47393ca061fbeb5e177088f490576f5bbff3a9926913013639d6d957c9c431065af69cead260ab2f67e2555bee19e21771337e1cdb7fecff62881a983fec83a41d0009e3b27f10a3ac723880d57aed57ac8fefcb0b645a4b57399a4985e693a36611a8f7e7d32e4253c977f6ab435c4f4e233a8a85f317996372841680515e1de3c2ddba21df44286880dec840c4f6d3e4a4b600eeb58a3f02e9997bae24980f655b9b68eb3a588cada3237248b3fa758554041d074683bc9d4ae02adac64d63f943167f7304c1b76f0eb69eee936ca3d56ee56a7a3893076ad3557d48d1f3a1754aa923efdabac3be14767a3cf5274e497d9a5d16843fb0ffcb6a71fea34644bba6dbbb4847f8d49142dc56d8cefae5e17b6bccaa8460693f509460cb109801b85f111f9c55db0375d500e76bce48ef6e72ff3a8d49e90acc3e91e8a8d2538fd74e01b66cc84ab6aced9876770fa67fe1c0d9b6876a2a27e34cc25251976eb89a3b2926f5c7cab75f29d5f451e29f4e8c3a26e23b2010d39942eef99f4b5efd63c50d06a103dc96e59a417159d1628d0fa9444394cce72b03b7e584a39f72d8486a3b2073e50f4a940239136509d90cd969a5d968fdeb6171abceccae7cc181a76949ac7c741cf8bd5b018c2d4084d390488b5425b84219add9051e81b8878d759e7070c7a51ff43fe55379f995c46b6d73e2cb23c0f75c7998a16e5dfbb20f04104efaf24d7444761963cffea0bf8642b1599c4020005b92a9eaa5985c7847d7f87d28061ac654fdfa8e220f77e68b6943f6df4ca2b2863862cdf994a274c2779491e46253110701f1496a015fbe34788f4cc7d0ce31d3e21ffef326bcf5013bcd43f2070b933b1ebbd2bb7671c91f5ca073c16e1d482d977ce0caef99a39fe8bd00c65fef1578c4af945610c330e8b9c04db67d4be5e6bf6c93f51ebf1c1e38dbca1f66592ba4399566bc70c3bacdf74c1c817345c8976eaba6a1ae86e15dd54b0f917070a8045adc166ffaafd6bb08c59f3c9ce050e40fd6f2abf9a7e7b9108de121c68c21d7e7b0cb0c00873935075e5e671efbe33d31a19ce1292e4b7949720eea6acba21a7c91d1a64f2438a824fab891691d13486fb302196e6b02c893c3f9bfb56cf5db723cbc49adf0aaef9e01b68a4fd83a39fce35456adb8db9ba3736f04ed2b931d3d21fdbf365609464776d07b496e44643daee00f9a16c3ceaff288fba6acbf8b46db45d956f69208ad0407a1746a50fc1df971b76f7eb55a5d9bc99de45babe9f0beb395629f20b74933f592e9220ebac57a92814f90e20b08d753fbb6fee4f77b2b54de493cd09eacf288b944eafd4040bf751a0922cdb726c577c2a2b78c47cb5903372ea54059d0f3e17f13ff4512eb753c59a08cd1e6c736a1eba4c2f8b745bf391a952cc941dc03f3ea98ec4bc0e312285f348e13e197ac53af04d21583205f7a2e7f9154a336c073ed636fb67e4e194e7fc0d46fb80704ddb8eaaeec04eced5ec7296e27ea8cdda709666f91e47d19219cd6611f5df9a26dc95995da0fe96136c82fb1af9156624dd50fb4c2fcb6b5d883a4e93c130fe55e1ce30ce34c37fa36ed4e6d8082892e0c2a9c3d67fb4a0c38239a4e52c746687c5ece40fb569e69c3dd1ee27772576cf9e2f6115b82e4404d3c5b314d4f0d1f97a95a99761249c181f8216ff3fee92f7b70d6e7355c89889641d359583456e4cf6a213253b5cc5a2fbceabec009c0ce50816f819cb7ecf8698e3c9dd4a269fb01a4fce7c12052aaef179d1abde08c</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-shrink">
      <input class="hbe hbe-input-field hbe-input-field-shrink" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-shrink" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-shrink">您好, 这里需要密码.</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>月度总结</category>
      </categories>
      <tags>
        <tag>月度总结</tag>
      </tags>
  </entry>
  <entry>
    <title>C++笔记</title>
    <url>/2020/03/04/C++%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h1><h2 id="cin"><a href="#cin" class="headerlink" title="cin"></a>cin</h2><p>结束条件：[enter],[space],[tab]<br>处理方法：cin遇到缓冲区中的[enter],[space],[tab]会结束当前输入，并舍弃[enter],[space],[tab]，继续下一项输入，当有连续[space],[enter,[tab]会全部舍弃</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">    <span class="keyword">char</span> a[<span class="number">10</span>],b[<span class="number">10</span>];</span><br><span class="line">    cin &gt;&gt;a;<span class="number">12</span></span><br><span class="line">    cin &gt;&gt;b;</span><br><span class="line">    cout &lt;&lt; a &lt;&lt;endl &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<p><strong>输入</strong>：1234[enter]5678[enter]<br><strong>输出</strong>：1234  【此处换行】   5678</p>
<p><strong>输入</strong>：1234[enter][enter[enter]   …   [enter]5678[enter]<br><strong>输出</strong>：1234  【此处换行】 5678  （说明不管缓冲区中有几个enter，cin都会无视，直到不是enter开始继续读入）tab，space同理<br>综上：cin的输入很简单，整体的看输入，遇到[enter],[space],[tab]表示当前输入结束，下一个输入从非[enter],[sapce],[tab]开始，两输入间无线多个[space][]enter[tab]都是无效的</p>
<h2 id="cin-get"><a href="#cin-get" class="headerlink" title="cin.get()"></a>cin.get()</h2><h3 id="1个参数"><a href="#1个参数" class="headerlink" title="1个参数"></a>1个参数</h3><p>用法：<code>a = cin.get()</code>或者<code>cin.get(a)</code><br>结束条件：输入字符足够后回车<br>说明：这个是单字符的输入，用途是输入一个字符，把它的ASCALL码存入到a中<br>处理方法：与<code>cin</code>不同，<code>cin.get()</code>在缓冲区遇到[enter]，[space]，[tab]不会作为舍弃，而是继续留在缓冲区中</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">char</span> a,b,c,d;</span><br><span class="line">	a = cin.<span class="built_in">get</span>();</span><br><span class="line">	b = cin.<span class="built_in">get</span>();</span><br><span class="line">	c = cin.<span class="built_in">get</span>();</span><br><span class="line">	d = cin.<span class="built_in">get</span>();</span><br><span class="line">	cout&lt;&lt;<span class="built_in"><span class="keyword">int</span></span>(a)&lt;&lt;<span class="string">&#x27;,&#x27;</span>&lt;&lt;<span class="built_in"><span class="keyword">int</span></span>(b)&lt;&lt;<span class="string">&#x27;,&#x27;</span>&lt;&lt;<span class="built_in"><span class="keyword">int</span></span>(c)&lt;&lt;<span class="string">&#x27;,&#x27;</span>&lt;&lt;<span class="built_in"><span class="keyword">int</span></span>(d)&lt;&lt;endl;</span><br></pre></td></tr></table></figure>

<p>输入：[enter]  <br>输出：不会结束，因为需要输入4个字符才结束（结束需要字符数够后回车）</p>
<p>输入：[enter][enter][enter][enter]      <br>输出：10,10,10,10  </p>
<p>输入：abcdef[enter]    <br>输出：97,98,99,100   字符太多时取前几个</p>
<p>输入：[tab][enter][space]a[enter]    <br>输出：9,10,32,97（分别为[tab]，[enter]，[space]，a的ASCALL码）不舍弃[enter],[tab],[space],统一看成字符</p>
<p>综上，一参数的cin.get()当输入字符足够后回车结束输入，把回车[enter],空格[space]也看成字符，在缓冲区中遇到不舍弃。当输入过多时，取前几个</p>
<h3 id="2个参数"><a href="#2个参数" class="headerlink" title="2个参数"></a>2个参数</h3><p>用法：<code>cin.get(arrayname,size)</code> 把字符输入到<code>arrayname</code>中，长度不超过<code>size</code><br>注释：<code>arrayname</code>必须是<code>char[]</code>类型，即<code>char</code>数组类型，不可以为<code>string</code>类型；<code>size</code>是指输入长度，即允许输入的最大长度。<br>处理方法：假设把数据输入到<code>char a[arraylength]</code>,数组长度为<code>arraylength</code><br><code>cin.get(a,size)</code>—<code>size</code>,<code>arraylength</code>不同可以分为四类：</p>
<h4 id="类1：输入串长-lt-size，输入串长-gt-arraylength，"><a href="#类1：输入串长-lt-size，输入串长-gt-arraylength，" class="headerlink" title="类1：输入串长 &lt; size，输入串长 &gt; arraylength，"></a>类1：输入串长 &lt; size，输入串长 &gt; arraylength，</h4><p>会自动扩张arrayname大小，使能保存所有数据</p>
<p>例1：char a[10];cin,get(a,20);</p>
<p>输入：123456789012[enter]<br>输出a数组：123456789012 可以发现，输入12个字符到a[10]中，系统自动扩充a[10]，此时实际数组长为13（‘123456789012’\0’’）。但当计算sizeof(a)时，还是现实为10</p>
<h4 id="类2：输入串长-lt-size，输入串长-lt-arraylength，"><a href="#类2：输入串长-lt-size，输入串长-lt-arraylength，" class="headerlink" title="类2：输入串长 &lt; size，输入串长 &lt; arraylength，"></a>类2：输入串长 &lt; size，输入串长 &lt; arraylength，</h4><p>把串全部输入，后面补‘\0’</p>
<p>例2：char a[10];cin.get(a,20);</p>
<p>输入：12345[enter] <br>输出：12345，此时数组内数据为‘12345‘\0’’</p>
<h4 id="类3：输入串长-gt-size，大于arraylength"><a href="#类3：输入串长-gt-size，大于arraylength" class="headerlink" title="类3：输入串长&gt;size，大于arraylength"></a>类3：输入串长&gt;size，大于arraylength</h4><p>先截取size个字符，若还是大于arraylength，则输入前arraylength-1个字符，最后补充‘\0’</p>
<p>例3：char a[5];cin,get(a,10);</p>
<p>输入：123456789012[enter]<br>输出：123456789   先截取了9个字符变成‘123456789‘/0‘’，然后放入到a中，a自动扩张长度</p>
<h4 id="类4：输入串长-gt-size，小于arraylength"><a href="#类4：输入串长-gt-size，小于arraylength" class="headerlink" title="类4：输入串长&gt;size，小于arraylength"></a>类4：输入串长&gt;size，小于arraylength</h4><p>先截取size个字符，若小于arraylength，则把截取串放入数组中，最后补充‘\0’</p>
<p>例4：char a[15],cin.get(a,10)</p>
<p>输入：123456789012[enter]<br>输出：123456789   此时数组内为‘123456789‘\0’’   注意：前size-1有效，最后一个补‘\0’</p>
<p>综上：当吧大于数组长度的字符串放出char a[arraylength]中，系统自动扩张数组a的长度使a能放得下，但是这么做容易产生运行错误</p>
<h3 id="3个参数"><a href="#3个参数" class="headerlink" title="3个参数"></a>3个参数</h3><p>用法：<code>cin.get(arrayname,size,s)</code> 把数据输入到<code>arrayname</code>字符数组中，当到达长度<code>size</code>时结束或者遇到字符<code>s</code>时结束<br>注释：<code>arrayname</code>必须是字符数组，即<code>char arrayname[]</code>类型，不可为<code>string</code>类型；<code>size</code>为最大的输入长度；<code>s</code>为控制，遇到<code>s</code>则当前输入结束缓存区里的<code>s</code>将被舍弃</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="keyword">char</span> a[<span class="number">10</span>];</span><br><span class="line">	cin.<span class="built_in">get</span>(a,<span class="number">10</span>,<span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">	cout&lt;&lt;a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输入：abc.123<br>输出：abc    遇到  ’.‘ 输入结束</p>
<h2 id="cin-getline"><a href="#cin-getline" class="headerlink" title="cin.getline()"></a>cin.getline()</h2><p><code>cin.getline()</code>的用法和<code>cin.get()</code>用法大致相同，没有一参数用法，只有二参数，三参数两类<br><code>cin.gerline(arrayname,size)</code><br><code>cin.getline(arrayname,size,s)</code>用法与<code>cin.get()</code>效果大致相同，但也有些区别</p>
<h3 id="cin-getline-arrayname-size-与cin-get-arrayname-size-的区别"><a href="#cin-getline-arrayname-size-与cin-get-arrayname-size-的区别" class="headerlink" title="cin.getline(arrayname,size)与cin.get(arrayname,size)的区别"></a>cin.getline(arrayname,size)与cin.get(arrayname,size)的区别</h3><p><code>cin.get(arrayname,size)</code>当遇到[enter]时会结束目前输入，他不会删除缓冲区中的[enter]<br><code>cin.getline(arrayname,size)</code>当遇到[enter]时会结束当前输入，但是会删除缓冲区中的[enter]</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">char</span> a[<span class="number">10</span>];<span class="keyword">char</span> b;</span><br><span class="line">    cin.<span class="built_in">get</span>(a,<span class="number">10</span>);</span><br><span class="line">	cin.<span class="built_in">get</span>(b);</span><br><span class="line">	cout&lt;&lt;a&lt;&lt;endl&lt;&lt;<span class="built_in"><span class="keyword">int</span></span>(b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输入：12345[enter]<br>输出：12345 【换行】 10<br>说明：cin.get(a,10)把12345到a中，遇到[enter]结束，但是不把[enter]删除，则把[enter]输入到b中，（enter的ASCALL码为10）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">char</span> a[<span class="number">10</span>];<span class="keyword">char</span> b;</span><br><span class="line">    cin.<span class="built_in">getline</span>(a,<span class="number">10</span>);</span><br><span class="line">	cin.<span class="built_in">get</span>(b);</span><br><span class="line">	cout&lt;&lt;a&lt;&lt;endl&lt;&lt;<span class="built_in"><span class="keyword">int</span></span>(b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输入：12345[enter]a[enter]<br>输出：12345【换行】97<br>说明：cin.getline(a,10)吧12345输入到a中，遇到[enter]结束，并把缓冲区中[enter]删除，把接下来的a输入到b中</p>
<h3 id="cin-getline-arrayname-size-s-与cin-gei-arrayname-size-s-的区别"><a href="#cin-getline-arrayname-size-s-与cin-gei-arrayname-size-s-的区别" class="headerlink" title="cin.getline(arrayname,size,s)与cin.gei(arrayname,size,s)的区别"></a>cin.getline(arrayname,size,s)与cin.gei(arrayname,size,s)的区别</h3><p><code>cin.get（arrayname,size,s）</code>当遇到s时会结束输入，但不会删除缓冲区中的s<br><code>cin.getline(arrayname,size,s)</code>当遇到s时会结束输入，并把s从缓冲区中删除</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">char</span> a[<span class="number">10</span>];<span class="keyword">char</span> b;</span><br><span class="line">    cin.<span class="built_in">get</span>(a,<span class="number">10</span>,<span class="string">&#x27;,&#x27;</span>);</span><br><span class="line">	cin.<span class="built_in">get</span>(b);</span><br><span class="line">	cout&lt;&lt;a&lt;&lt;endl&lt;&lt;b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输入：12345,[enter]<br>输出：12345【换行】，<br>说明：cin.get不会删除缓冲区的，缓存中的，被写入b中</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">char</span> a[<span class="number">10</span>];<span class="keyword">char</span> b;</span><br><span class="line">    cin.<span class="built_in">getline</span>(a,<span class="number">10</span>,<span class="string">&#x27;,&#x27;</span>);</span><br><span class="line">	cin.<span class="built_in">get</span>(b);</span><br><span class="line">	cout&lt;&lt;a&lt;&lt;endl&lt;&lt;<span class="built_in"><span class="keyword">int</span></span>(b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输入：12345，[enter]<br>输出：12345【换行】10<br>说明：cin.getline吧12345输入到a中，遇到’，‘结束，并删除缓冲区的’，‘，后面的[enter]输入到b中</p>
<h1 id="类中static和const关键字声明变量的初始化方式"><a href="#类中static和const关键字声明变量的初始化方式" class="headerlink" title="类中static和const关键字声明变量的初始化方式"></a>类中static和const关键字声明变量的初始化方式</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestClass</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">TestClass</span>() <span class="comment">//:a(16)</span></span><br><span class="line">  	&#123;</span><br><span class="line">  		cout &lt;&lt; <span class="string">&quot;TestClass Constructor .&quot;</span> &lt;&lt; endl;</span><br><span class="line">   	&#125;</span><br><span class="line">   	~<span class="built_in">TestClass</span>()</span><br><span class="line"> 	&#123;</span><br><span class="line">  		cout &lt;&lt; <span class="string">&quot;TestClass Destructor .&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">   	<span class="keyword">int</span> temp_a; <span class="comment">// = 5;</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> temp_b;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> temp_c; <span class="comment">// = 25;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">static</span> <span class="keyword">int</span> temp_d; <span class="comment">// = 35;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">static</span> <span class="keyword">float</span> temp_e;    </span><br><span class="line"> &#125;;</span><br></pre></td></tr></table></figure>

<h2 id="int-temp-a"><a href="#int-temp-a" class="headerlink" title="int temp_a;"></a>int temp_a;</h2><ol>
<li>在声明处初始化；</li>
<li>在构造函数初始化列表中初始化；</li>
</ol>
<p>对于非static、非const声明的变量，这两种初始化可以同时使用，同时使用时列表中的值会自动覆盖声明处的值。初始化不是必须的，若不进行初始化，其值是不确定的，可简单认为是随机的。该变量属于对象。</p>
<h2 id="static-int-temp-b"><a href="#static-int-temp-b" class="headerlink" title="static int temp_b;"></a>static int temp_b;</h2><p>必须在类的声明体外进行定义(若在定义时不给初值，则编译器自动赋予默认值，<code>int</code>型变量的默认值为0，定义时不使用关键字<code>static</code>。例如：<code>int TestClass::temp_b = 12</code>;<br>该变量属于类，不属于特定的对象，可以理解为全局的，为所有所实例化的对象所共享。可在程序中通过类名作用域符号的方式访问（如：<code>TestClass::temp_b = 18;</code>)，也可以通过对象访问。</p>
<h2 id="const-int-temp-c"><a href="#const-int-temp-c" class="headerlink" title="const int temp_c;"></a>const int temp_c;</h2><ol>
<li>在声明处初始化；</li>
<li>在构造函数初始化列表中初始化；</li>
</ol>
<p>必须初始化，这两种初始化可以同时使用，同时使用时构造函数初始化列表中的值会自动覆盖声明处给的初值。<br>该常量属于对象，在对象声明时进行初始化，对象声明以后就不能再改变常量的值，即在对象的生存周期内其值不变。</p>
<h2 id="const-static-int-temp-d-char-short-int-long"><a href="#const-static-int-temp-d-char-short-int-long" class="headerlink" title="const static int temp_d;//char short int long"></a>const static int temp_d;//char short int long</h2><ol>
<li>在声明处初始化；（在声明处初始化，则可以不用在类的声明体外进行定义）</li>
<li>在类的声明体外进行定义并初始化；<code>const int TestClass::temp_d = 15</code>;</li>
</ol>
<p>必须初始化，并且只能有一次初始化赋值（即1和2中，二选一）。<code>char</code>、<code>short</code>、<code>long</code>型静态常量都属于这种情况。<br>静态常量属于类，为所有的对象共享，既然是常量，初始化以后肯定就不能再有赋值操作。</p>
<h2 id="const-static-float-temp-e-float-double"><a href="#const-static-float-temp-e-float-double" class="headerlink" title="const static float temp_e; //float double"></a>const static float temp_e; //float double</h2><p>只能且必须在类的声明体外进行定义和初始化<code>const float TestClass::temp_e = 0.234f;</code> 静态常量的浮点型数据属于这种情况。</p>
<h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><ol>
<li>仅仅有关键字<code>const</code>，由于是常量，就必须进行初始化；可在声明处和构造函数列表中进行初始化，可以二选一，亦可以在这两处都初始化，初始化列表中的赋值会自动覆盖声明处的值。</li>
<li>仅仅有<code>static</code>,由于是静态变量，属于类本身，则必须在类的生命体外进行定义（若不给初值，则为默认值）</li>
<li>同时又<code>static</code>和<code>const</code>，这两个关键字的前后顺序无所谓，由于是静态常量，即同时具有静态和长常量的属性，使用条件就更加苛刻（即为一个常量，那就必须有初始化，并且还是静态的，那就自然属于类本身了）。整形数据可以在声明处初始化或者在类的声明体外进行定义并初始化，二选一。浮点型数据只能且必须在类的声明体外进行定义并初始化。</li>
</ol>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>C++</category>
      </categories>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>Git笔记</title>
    <url>/2021/08/05/Git%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="基础命令"><a href="#基础命令" class="headerlink" title="基础命令"></a>基础命令</h1><table>
<thead>
<tr>
<th>命令</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>git config –global user.name 用户名</td>
<td>设置用户签名</td>
</tr>
<tr>
<td>git config –global user.email 邮箱</td>
<td>设置用户签名</td>
</tr>
<tr>
<td>git init</td>
<td>初始化本地库</td>
</tr>
<tr>
<td>git status</td>
<td>查看本地库状态</td>
</tr>
<tr>
<td>git add 文件名</td>
<td>添加到暂存区</td>
</tr>
<tr>
<td>git commit -m “日志信息” 文件名</td>
<td>提交到本地库</td>
</tr>
<tr>
<td>git reflog</td>
<td>查看历史记录</td>
</tr>
<tr>
<td>git reset –hard 版本号</td>
<td>版本穿梭</td>
</tr>
</tbody></table>
<ol>
<li><p>进入要管理的文件夹，初始化命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git init</span><br></pre></td></tr></table></figure></li>
<li><p>管理目录下的文件状态</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git status</span><br><span class="line">注：新增的文件和修改后的文件都是红色</span><br></pre></td></tr></table></figure></li>
</ol>
<span id="more"></span>

<ol start="3">
<li><p>提交到暂存区，管理指定文件（红变录）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git add 文件名</span><br><span class="line">git add .</span><br></pre></td></tr></table></figure></li>
<li><p>再查看状态</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git status</span><br></pre></td></tr></table></figure></li>
<li><p>个人信息配置：用户名、邮箱【一次即可】,<br>这里设置用户签名和将来登录 GitHub（或其他代码托管中心）的账号没有任何关系</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git config --global user.email &quot;you@example.com&quot;</span><br><span class="line">git config --global user.name &quot;Your Name&quot;</span><br></pre></td></tr></table></figure></li>
<li><p>提交到版本库，生成版本</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git commit -m &#39;日志信息&#39; 文件名</span><br><span class="line">git commit -m &quot;my first commit&quot; hello.txt</span><br></pre></td></tr></table></figure></li>
<li><p>查看状态（没有文件需要提交）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git status</span><br></pre></td></tr></table></figure></li>
</ol>
<p><img data-src="git%E5%B7%A5%E4%BD%9C%E5%8C%BA.png" alt="git工作区" title="git工作区"></p>
<h1 id="历史版本"><a href="#历史版本" class="headerlink" title="历史版本"></a>历史版本</h1><h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git reflog  查看版本信息</span><br><span class="line">git log     查看版本详细信息</span><br></pre></td></tr></table></figure>

<h2 id="版本穿梭"><a href="#版本穿梭" class="headerlink" title="版本穿梭"></a>版本穿梭</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git reset --hard 版本号</span><br></pre></td></tr></table></figure>

<p><img data-src="https://cdn.jsdelivr.net/gh/JulyForever/Photos/article/%E7%89%88%E6%9C%AC%E7%A9%BF%E6%A2%AD.png" alt="版本穿梭"></p>
<h1 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h1><table>
<thead>
<tr>
<th>命令</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>git branch 分支名称</td>
<td>创建分支</td>
</tr>
<tr>
<td>git branch -v</td>
<td>查看分支</td>
</tr>
<tr>
<td>git checkout 分支名称</td>
<td>切换分支</td>
</tr>
<tr>
<td>git merge 分支名称</td>
<td>把指定的分支合并到当前分支上</td>
</tr>
</tbody></table>
<ol>
<li><p>查看分支</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git branch</span><br><span class="line">git branch -v  &#x2F;&#x2F;查看每一个分支的最后一次提交</span><br></pre></td></tr></table></figure></li>
<li><p>创建分支</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git branch 分支名称</span><br></pre></td></tr></table></figure></li>
<li><p>切换分支</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git checkout 分支名称</span><br></pre></td></tr></table></figure></li>
<li><p>合并分支（其它的合并到当前的）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git merge 要合并的分支</span><br><span class="line">注意：切换到当前主分支后，再合并其它新分支。如产生冲突需手动处理</span><br></pre></td></tr></table></figure></li>
<li><p>处理冲突<br>冲突产生的表现：后面状态为 MERGING<br>编辑有冲突的文件，删除特殊符号，决定要使用的内容。<br>特殊符号：&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD 当前分支的代码 ======= 合并过来的代码 &gt;&gt;&gt;&gt;&gt;&gt;&gt; hot-fix</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git add hello.txt    &#x2F;&#x2F;添加到暂存区</span><br><span class="line">git commit -m &quot;merge hot-fix&quot;    &#x2F;&#x2F;此时使用 git commit 命令时不能带文件名</span><br></pre></td></tr></table></figure>

<p>发现后面 MERGING 消失，变为正常</p>
</li>
</ol>
<ol start="6">
<li>删除分支<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git branch -d 分支名称</span><br></pre></td></tr></table></figure></li>
</ol>
<p><img data-src="%E5%B7%A5%E4%BD%9C%E6%B5%81.png" alt="工作流" title="工作流"></p>
<p><img data-src="bug%E5%88%86%E6%94%AF.png" alt="bug"></p>
<h1 id="远程仓库"><a href="#远程仓库" class="headerlink" title="远程仓库"></a>远程仓库</h1><table>
<thead>
<tr>
<th>命令</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>git remote -v</td>
<td>查看当前所有远程地址别名</td>
</tr>
<tr>
<td>git remote add 别名 远程地址</td>
<td>起别名</td>
</tr>
<tr>
<td>git push 别名 分支</td>
<td>推送本地分支上的内容到远程仓库</td>
</tr>
<tr>
<td>git clone 远程地址</td>
<td>将远程仓库的内容克隆到本地</td>
</tr>
<tr>
<td>git pull 远程库地址别名 远程分支名</td>
<td>将远程仓库对于分支最新内容拉下来后与当前本地分支直接合并</td>
</tr>
</tbody></table>
<h2 id="初次连接远程仓库"><a href="#初次连接远程仓库" class="headerlink" title="初次连接远程仓库"></a>初次连接远程仓库</h2><ol start="0">
<li><p>查看当前所有远程地址别名</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git remote -v 查看当前所有远程地址别名</span><br></pre></td></tr></table></figure></li>
<li><p>连接远程仓库起别名</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git remote add origin（别名） 远程仓库地址</span><br></pre></td></tr></table></figure></li>
<li><p>向远程推送代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git push -u origin（别名） 分支   </span><br><span class="line">&#x2F;&#x2F;指定一个默认主机，这样后面就可以不加任何参数使用git push</span><br><span class="line">&#x2F;&#x2F;不带任何参数的git push，默认只推送当前分支</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="新电脑克隆远程仓库到本地"><a href="#新电脑克隆远程仓库到本地" class="headerlink" title="新电脑克隆远程仓库到本地"></a>新电脑克隆远程仓库到本地</h2><ol>
<li><p>新电脑克隆远程仓库代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git clone 远程仓库地址</span><br><span class="line">注：已实现git remote add origin（别名） 远程仓库地址</span><br></pre></td></tr></table></figure></li>
<li><p>切换分支</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git checkout dev   &#x2F;&#x2F;切换</span><br><span class="line">git merge master  &#x2F;&#x2F;将master合并到dev</span><br><span class="line">git add. </span><br><span class="line">git commit -m &#39;提交说明&#39;</span><br><span class="line">git push origin dev</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="原电脑同步代码"><a href="#原电脑同步代码" class="headerlink" title="原电脑同步代码"></a>原电脑同步代码</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 切换到dev分支进行开发</span><br><span class="line">git checkout dev</span><br><span class="line">&#x2F;&#x2F; 拉代码同步</span><br><span class="line">git pull origin dev</span><br><span class="line">&#x2F;&#x2F; 开发完成后提交代码</span><br><span class="line">git add .</span><br><span class="line">git commit -m &#39;代码说明&#39;</span><br><span class="line">git push origin dev</span><br></pre></td></tr></table></figure>

<h2 id="新电脑继续开发（同上）"><a href="#新电脑继续开发（同上）" class="headerlink" title="新电脑继续开发（同上）"></a>新电脑继续开发（同上）</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 切换到dev分支进行开发</span><br><span class="line">git checkout dev</span><br><span class="line">&#x2F;&#x2F; 拉代码同步</span><br><span class="line">git pull origin dev</span><br><span class="line">&#x2F;&#x2F; 开发完成后提交代码</span><br><span class="line">git add .</span><br><span class="line">git commit -m &#39;代码说明&#39;</span><br><span class="line">git push origin dev</span><br></pre></td></tr></table></figure>

<h2 id="上线"><a href="#上线" class="headerlink" title="上线"></a>上线</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; dev分支合并到master进行上线</span><br><span class="line">git checkout master</span><br><span class="line">git merge dev</span><br><span class="line">git push origin master</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;dev分支也推送到远程</span><br><span class="line">git checkout dev</span><br><span class="line">git merge master</span><br><span class="line">git push origin dev</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git pull origin dev</span><br><span class="line">等价于</span><br><span class="line">git fetch origin dev</span><br><span class="line">git merge origin&#x2F;dev</span><br></pre></td></tr></table></figure>

<h1 id="rebase"><a href="#rebase" class="headerlink" title="rebase"></a>rebase</h1><p>将分支合并为一条<br>详细的得再查查</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git checkout bugFix</span><br><span class="line">git rebase master   &#x2F;&#x2F;bugFix分支头放到了master分支末尾。有冲突需解决</span><br><span class="line">git checkout master  &#x2F;&#x2F;切换回master，此时head还在原末尾</span><br><span class="line">git merge bugFix     &#x2F;&#x2F;合并，head指向新的末尾了</span><br></pre></td></tr></table></figure>

<h1 id="快速解决冲突"><a href="#快速解决冲突" class="headerlink" title="快速解决冲突"></a>快速解决冲突</h1><ol>
<li><p>安装beyond compare软件</p>
</li>
<li><p>在git中配置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;local为本地的工程里面添加单独的配置</span><br><span class="line">git config --local merge.tool bc3</span><br><span class="line">git config --local mergetool.path &#39;&#x2F;usr&#x2F;local&#x2F;bin&#x2F;bcomp&#39;</span><br><span class="line">git config --local mergetool.keepBackup false</span><br></pre></td></tr></table></figure></li>
<li><p>使用beyond compare解决冲突</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git mergetool</span><br></pre></td></tr></table></figure></li>
</ol>
<h1 id="多人协同开发"><a href="#多人协同开发" class="headerlink" title="多人协同开发"></a>多人协同开发</h1><p>github项目可以邀请成员加入设置对应权限，可以建立组织并设置成员权限</p>
<h2 id="tag标签管理"><a href="#tag标签管理" class="headerlink" title="tag标签管理"></a>tag标签管理</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git tag -a v1.0 -m  &#39;版本介绍&#39;    创建本地tag信息</span><br><span class="line">git tag -d v1.0                  删除tag</span><br><span class="line">git push origin --tags           将本地tag信息推送到远程仓库</span><br><span class="line">git pull origin --tags           更新本地tag版本信息</span><br><span class="line"></span><br><span class="line">git checkout v.10                切换tag</span><br><span class="line">git clone -b v0.1  地址          指定tag下载代码</span><br></pre></td></tr></table></figure>

<h2 id="新成员在自己电脑下载代码并开发"><a href="#新成员在自己电脑下载代码并开发" class="headerlink" title="新成员在自己电脑下载代码并开发"></a>新成员在自己电脑下载代码并开发</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;oldboy-org&#x2F;dbhot.git</span><br><span class="line">cd dbhot</span><br><span class="line">git checkout dev</span><br><span class="line">git checkout -b dzz</span><br><span class="line"></span><br><span class="line">写代码</span><br><span class="line"></span><br><span class="line">git add .</span><br><span class="line">git commit -m &#39;开发完成&#39;</span><br><span class="line">git push origin ddz</span><br></pre></td></tr></table></figure>

<h2 id="github配置代码review后才能合并"><a href="#github配置代码review后才能合并" class="headerlink" title="github配置代码review后才能合并"></a>github配置代码review后才能合并</h2><h2 id="提测上线（预发布）"><a href="#提测上线（预发布）" class="headerlink" title="提测上线（预发布）"></a>提测上线（预发布）</h2><ol>
<li>基于dev分支创建release分支</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git checkout dev         &#x2F;&#x2F; 切换到dev</span><br><span class="line">git checkout -b release  &#x2F;&#x2F;创建并切换到release分支</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p>测试等</p>
</li>
<li><p>合并到master</p>
</li>
</ol>
<p>使用pull request 或 本地将release合并到master</p>
<ol start="4">
<li>在master分支打tag</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git tag -a v2 -m &#39;第二版 斗地主功能&#39;</span><br><span class="line">git push origin --tags</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>运维上线</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git clone -b v2 地址</span><br></pre></td></tr></table></figure>

<h1 id="给开源软件贡献代码"><a href="#给开源软件贡献代码" class="headerlink" title="给开源软件贡献代码"></a>给开源软件贡献代码</h1><ol>
<li>fork源代码 将别人源代码拷贝到自己的远程仓库</li>
<li>在自己的仓库进行修改源代码</li>
<li>给原代码的作者提交修复bug的申请（pull request）</li>
</ol>
<h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><ul>
<li>项目配置文件：项目/.git/config</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git config --local user.name &#39;wupeiqi&#39;</span><br><span class="line">git config --local user.email &#39;wupeiqi@xx.com&#39;</span><br></pre></td></tr></table></figure>

<ul>
<li>全局配置文件：~/.gitconfig</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git config --global user.name &#39;wupeiq&#39;</span><br><span class="line">git config --global user.name &#39;wupeiqi@xx.com&#39;</span><br></pre></td></tr></table></figure>

<ul>
<li>系统配置文件：/etc/.gitconfig</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;需要有root权限</span><br><span class="line">git config --system user.name &#39;wupeiq&#39;</span><br><span class="line">git config --system user.name &#39;wupeiqi@xx.com&#39;</span><br></pre></td></tr></table></figure>

<h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git config --local user.name &#39;wupeiqi&#39;</span><br><span class="line">git config --local user.email &#39;wupeiqi@xx.com&#39;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;软件解决冲突</span><br><span class="line">git config --local merge.tool bc3</span><br><span class="line">git config --local mergetool.path &#39;&#x2F;usr&#x2F;local&#x2F;bin&#x2F;bcomp&#39;</span><br><span class="line">git config --local mergetool.keepBackup false</span><br><span class="line"></span><br><span class="line">git remote add origin 地址  &#x2F;&#x2F;默认添加在本地配置文件中(--local)</span><br></pre></td></tr></table></figure>

<h1 id="免密登录"><a href="#免密登录" class="headerlink" title="免密登录"></a>免密登录</h1><ul>
<li>URL中体现</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">原来的地址：https:&#x2F;&#x2F;github.com&#x2F;WuPeiqi&#x2F;dbhot.git</span><br><span class="line">修改的地址：https:&#x2F;&#x2F;用户名:密码@github.com&#x2F;WuPeiqi&#x2F;dbhot.git</span><br><span class="line"></span><br><span class="line">git remote add origin https:&#x2F;&#x2F;户名:密码@github.com&#x2F;WuPeiqi&#x2F;dbhot.git</span><br><span class="line">git push origin master</span><br></pre></td></tr></table></figure>

<ul>
<li>SSH实现</li>
</ul>
<ol>
<li>生成公钥和私钥，默认放在~/.ssh目录下，id_rsa.pub公钥、id_rsa私钥。<br><code>ssh-keygen</code></li>
<li>拷贝公钥的内容，并设置到GitHub中</li>
<li>在git本地中配置SSH地址<br><code>git remote add origin git@github.com:WuPeiqi/dbhot.git</code></li>
<li>以后使用<br><code>git push origin master</code></li>
</ol>
<ul>
<li>git自动管理凭证</li>
</ul>
<h1 id="git忽略文件"><a href="#git忽略文件" class="headerlink" title="git忽略文件"></a>git忽略文件</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">*.h</span><br><span class="line">!a.h</span><br><span class="line">files&#x2F;</span><br><span class="line">*.py[c|a|d]</span><br></pre></td></tr></table></figure>

<h1 id="github任务管理相关"><a href="#github任务管理相关" class="headerlink" title="github任务管理相关"></a>github任务管理相关</h1><ul>
<li>issues，文档以及任务管理</li>
<li>wiki，项目文档</li>
</ul>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>HTML笔记</title>
    <url>/2019/01/27/HTML%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h1><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"># 段落标签</span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>My cat is very grumpy<span class="tag">&lt;/<span class="name">p</span>&gt;</span>  </span><br><span class="line"></span><br><span class="line"># 斜体</span><br><span class="line"><span class="tag">&lt;<span class="name">em</span>&gt;</span>This is my text.<span class="tag">&lt;/<span class="name">em</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h1 id="块级元素和内联元素"><a href="#块级元素和内联元素" class="headerlink" title="块级元素和内联元素"></a>块级元素和内联元素</h1><ul>
<li>块级元素在页面中以块的形式展现 —— 相对与其前面的内容它会出现在新的一行，其后的内容也会被挤到下一行展现。块级元素通常用于展示页面上结构化的内容，例如段落、列表、导航菜单、页脚等等。一个以<code>block</code>形式展现的块级元素不会被嵌套进内联元素中，但可以嵌套在其它块级元素中。</li>
<li>内联元素通常出现在块级元素中并包裹文档内容的一小部分，而不是一整个段落或者一组内容。内联元素不会导致文本换行：它通常出现在一堆文字之间例如超链接元素<code>&lt;a&gt;</code>或者强调元素<code>&lt;em&gt;</code>和<code>&lt;strong&gt;</code>。</li>
</ul>
<h1 id="空元素"><a href="#空元素" class="headerlink" title="空元素"></a>空元素</h1><p>不是所有元素都拥有开始标签，内容和结束标记. 一些元素只有一个标签，通常用来在此元素所在位置插入/嵌入一些东西 。例如：元素<code>&lt;img&gt;</code>是用来在元素<code>&lt;img&gt;</code>所在位置插入一张指定的图片。例子如下：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;https://raw.githubusercontent.com/mdn/beginner-html-site/gh-pages/images/firefox-icon.png&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h1 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h1><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;editor-note&quot;</span>&gt;</span>My cat is very grumpy<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>这个class属性给元素赋了一个识别的名字（id），这个名字此后可以被用来识别此元素的样式信息和其他信息。</p>
<p>元素<code>&lt;a&gt;</code>是锚，它使被标签包裹的内容成为一个超链接。此元素也可以添加大量的属性，其中几个如下：</p>
<ul>
<li><code>href</code>: 这个属性声明超链接的web地址，当这个链接被点击浏览器会跳转至href声明的web地址。例如： <code>href=&quot;https://www.mozilla.org/&quot;</code>。</li>
<li><code>title</code>: 标题title 属性为超链接声明额外的信息，比如你将链接至那个页面。例如：<code>title=&quot;The Mozilla homepage&quot;</code>。当鼠标悬浮时，将出现一个工具提示。</li>
<li><code>target</code>: 目标target 属性指定将用于显示链接的浏览上下文。例如，<code>target=&quot;_blank&quot;</code>将在新标签页中显示链接。如果你希望在目前标签页显示链接，只需忽略这个属性。</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>A link to my <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;https://www.mozilla.org/&quot;</span> <span class="attr">title</span>=<span class="string">&quot;The Mozilla homepage&quot;</span>&gt;</span>favorite website<span class="tag">&lt;/<span class="name">a</span>&gt;</span>.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="布尔属性"><a href="#布尔属性" class="headerlink" title="布尔属性"></a>布尔属性</h2><p>有时你会看到没有值的属性，它是合法的。这些属性被称为布尔属性，他们只能有跟它的属性名一样的属性值。例如 disabled 属性，他们可以标记表单输入使之变为不可用(变灰色)，此时用户不能向他们输入任何数据。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">disabled</span>=<span class="string">&quot;disabled&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"># 可以简写为</span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">disabled</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h1 id="分析html文档"><a href="#分析html文档" class="headerlink" title="分析html文档"></a>分析html文档</h1><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>My test page<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>This is my page<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ol>
<li><code>&lt;!DOCTYPE html&gt;</code>: 声明文档类型. 很久以前，早期的HTML(大约1991年2月)，文档类型声明类似于链接，规定了HTML页面必须遵从的良好规则，能自动检测错误和其他有用的东西。使用如下：</li>
</ol>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span> <span class="meta-keyword">PUBLIC</span> <span class="meta-string">&quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot;</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">&quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>然而现在没有人再这样写，需要保证每一个东西都正常工作已成为历史。你只需要知道<code>&lt;!DOCTYPE html&gt;</code>是最短的有效的文档声明。<br>2. <code>&lt;html&gt;&lt;/html&gt;</code>: <code>&lt;html&gt;</code>元素。这个元素包裹了整个完整的页面，是一个根元素。<br>3. <code>&lt;head&gt;&lt;/head&gt;</code>: <code>&lt;head&gt;</code>元素. 这个元素是一个容器，它包含了所有你想包含在HTML页面中但不想在HTML页面中显示的内容。这些内容包括你想在搜索结果中出现的关键字和页面描述，CSS样式，字符集声明等等。以后的章节能学到更多关于<head>元素的内容。<br>4. <code>&lt;meta charset=&quot;utf-8&quot;&gt;</code>: 这个元素设置文档使用<code>utf-8</code>字符集编码，<code>utf-8</code>字符集包含了人类大部分的文字。基本上他能识别你放上去的所有文本内容。毫无疑问要使用它，并且它能在以后避免很多其他问题。<br>5. <code>&lt;title&gt;&lt;/title&gt;</code>: 设置页面标题，出现在浏览器标签上，当你标记/收藏页面时它可用来描述页面。<br>6. <code>&lt;body&gt;&lt;/body&gt;</code>: <code>&lt;body&gt;</code>元素。 包含了你访问页面时所有显示在页面上的内容，文本，图片，音频，游戏等等。</p>
<h1 id="实体引用"><a href="#实体引用" class="headerlink" title="实体引用"></a>实体引用</h1><p>| 原义字符 | 等价字符引用 |<br>| —- | —- | —- |<br>| &lt; | <code>&amp;lt;</code> |<br>| &gt; | <code>&amp;gt;</code> |<br>| “ | <code>&amp;quot;</code> |<br>| ‘ | <code>&amp;apos;</code> |<br>| &amp; | <code>&amp;amp;</code> |</p>
<h1 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h1><p>为了将一段HTML中的内容置为注释，你需要将其用特殊的记号<code>&lt;!--和--&gt;</code>包括起来， 比如：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- &lt;p&gt;I am!&lt;/p&gt; --&gt;</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>HTML</category>
      </categories>
      <tags>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title>django笔记 - 虚拟环境</title>
    <url>/2019/01/09/django%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="虚拟环境"><a href="#虚拟环境" class="headerlink" title="虚拟环境"></a>虚拟环境</h1><p>以下命令均在win10的cmd中执行</p>
<h2 id="virtualenv"><a href="#virtualenv" class="headerlink" title="virtualenv"></a>virtualenv</h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pip install virtualenv  <span class="comment">#virtual environment</span></span><br></pre></td></tr></table></figure>

<h3 id="创建虚拟环境"><a href="#创建虚拟环境" class="headerlink" title="创建虚拟环境"></a>创建虚拟环境</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">virtualenv abc-env   <span class="comment">#在当前目录位置，创建名为abc-env的虚拟环境</span></span><br></pre></td></tr></table></figure>

<h3 id="进入虚拟环境（Windows）"><a href="#进入虚拟环境（Windows）" class="headerlink" title="进入虚拟环境（Windows）"></a>进入虚拟环境（Windows）</h3><p>进入<code>Scripts</code>文件夹，如<code>\abc-env\Scripts</code>，然后执行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">activate</span><br></pre></td></tr></table></figure>

<h3 id="退出虚拟环境"><a href="#退出虚拟环境" class="headerlink" title="退出虚拟环境"></a>退出虚拟环境</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">deactivate</span><br></pre></td></tr></table></figure>

<h3 id="创建时指定Python解释器"><a href="#创建时指定Python解释器" class="headerlink" title="创建时指定Python解释器"></a>创建时指定<code>Python</code>解释器</h3><p>一般不用，如果装了多个，<code>-p</code>参数指定具体的<code>Python</code>解释器</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">virtualenv -p C:\Python36\python.exe [virtualenv name]</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="virtualenvwrapper"><a href="#virtualenvwrapper" class="headerlink" title="virtualenvwrapper"></a>virtualenvwrapper</h2><p>//wrapper 包装材料，包装纸</p>
<h3 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h3><p>可以直接安装这个，会自动安装virtualenv</p>
<ol>
<li>Windows：<code>pip install virtualenvwrapper-win</code></li>
<li>Linux： <code>pip install virtualenvwrapper</code></li>
</ol>
<h3 id="创建虚拟环境-1"><a href="#创建虚拟环境-1" class="headerlink" title="创建虚拟环境"></a>创建虚拟环境</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mkvirtualenv my_env   <span class="comment">#创建名为`my_env`的虚拟环境</span></span><br></pre></td></tr></table></figure>

<p>会在当前用户下创建一个Env的文件夹，将虚拟环境安装到这个目录下</p>
<h3 id="切换到某个虚拟环境"><a href="#切换到某个虚拟环境" class="headerlink" title="切换到某个虚拟环境"></a>切换到某个虚拟环境</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">workon my_env</span><br></pre></td></tr></table></figure>

<h3 id="退出当前虚拟环境"><a href="#退出当前虚拟环境" class="headerlink" title="退出当前虚拟环境"></a>退出当前虚拟环境</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">deactivate</span><br></pre></td></tr></table></figure>

<h3 id="删除虚拟环境"><a href="#删除虚拟环境" class="headerlink" title="删除虚拟环境"></a>删除虚拟环境</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rmvirtualenv my_env</span><br></pre></td></tr></table></figure>

<h3 id="列出所有虚拟环境"><a href="#列出所有虚拟环境" class="headerlink" title="列出所有虚拟环境"></a>列出所有虚拟环境</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">lsvirtualenv</span><br></pre></td></tr></table></figure>

<h3 id="进入当前虚拟环境所在的目录"><a href="#进入当前虚拟环境所在的目录" class="headerlink" title="进入当前虚拟环境所在的目录"></a>进入当前虚拟环境所在的目录</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cdvirtualenv</span><br></pre></td></tr></table></figure>

<h3 id="修改mkvirtualenv的默认路径"><a href="#修改mkvirtualenv的默认路径" class="headerlink" title="修改mkvirtualenv的默认路径"></a>修改<code>mkvirtualenv</code>的默认路径</h3><p>在<code>环境变量-&gt;系统变量</code>中，新建一个变量，变量名为<code>WORKON_HOME</code>，变量值为目标路径，我用了<code>E:\Projects\Envs</code></p>
<h3 id="创建时指定Python版本"><a href="#创建时指定Python版本" class="headerlink" title="创建时指定Python版本"></a>创建时指定Python版本</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mkvirtualenv  --python==C:\Python36\python.exe hy_env</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>学习笔记</category>
        <category>django</category>
      </categories>
      <tags>
        <tag>django</tag>
      </tags>
  </entry>
  <entry>
    <title>django笔记01 - 新建项目</title>
    <url>/2019/01/10/django%E7%AC%94%E8%AE%B001/</url>
    <content><![CDATA[<h1 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h1><h2 id="命令行"><a href="#命令行" class="headerlink" title="命令行"></a>命令行</h2><ol>
<li>创建项目：<code>django-admin startproject [项目名称]</code></li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">django startproject first_project</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>创建应用：在项目根目录，<code>python manage.py startapp [项目名称]</code></li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">python manage.py startapp first_app</span><br></pre></td></tr></table></figure>

<h2 id="pycharm专业版"><a href="#pycharm专业版" class="headerlink" title="pycharm专业版"></a>pycharm专业版</h2><p><strong>注</strong>：配置单例运行，防止无意中运行多个，造成新代码不生效<br>我选择vscode，没用pycharm</p>
<h1 id="运行项目（命令行）"><a href="#运行项目（命令行）" class="headerlink" title="运行项目（命令行）"></a>运行项目（命令行）</h1><p>在项目根目录</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">python manage.py runserver</span><br></pre></td></tr></table></figure>

<p>指定端口，如9000</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">python manage.py runserver 9000  </span><br></pre></td></tr></table></figure>

<h2 id="局域网访问"><a href="#局域网访问" class="headerlink" title="局域网访问"></a>局域网访问</h2><p>让局域网其它设备可以访问到</p>
<ol>
<li>运行IP为<code>0.0.0.0:[端口号]</code>，端口号要有</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">python manage.py runserver 0.0.0.0:8000  </span><br></pre></td></tr></table></figure>

<ol start="2">
<li><code>settings.py</code>文件中<code>ALLOWED_HOSTS</code>加入运行项目的本机IP，如<code>ALLOWED_HOSTS = [192.168.1.102]</code></li>
</ol>
<p><strong>注</strong>：仍然访问不到的话，检查防火墙</p>
<h1 id="settings-py文件中"><a href="#settings-py文件中" class="headerlink" title="settings.py文件中"></a>settings.py文件中</h1><p><code>DEBUG = False</code>后，，只能通过<code>ALLOWED_HOSTS = []</code>中的IP地址或者域名来进行访问</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>django</category>
      </categories>
      <tags>
        <tag>django</tag>
      </tags>
  </entry>
  <entry>
    <title>django笔记02 - 视图和url</title>
    <url>/2019/01/10/django%E7%AC%94%E8%AE%B002/</url>
    <content><![CDATA[<h1 id="视图函数"><a href="#视图函数" class="headerlink" title="视图函数"></a>视图函数</h1><ol>
<li>第一个参数必须是request</li>
<li>返回值必须是<code>django.http.response.HttpResponseBase</code>的子类的对象</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.http <span class="keyword">import</span> HttpResponse</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">book</span>(<span class="params">request</span>):</span></span><br><span class="line">    <span class="keyword">return</span> HttpResponse(<span class="string">&#x27;图书首页&#x27;</span>)</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h1 id="urls-py"><a href="#urls-py" class="headerlink" title="urls.py"></a>urls.py</h1><p><code>settings.py</code>文件中配置了<code>ROOT_URLCONF</code>为<code>urls.py</code>，所以会在这个文件中寻找映射<br>路径和视图函数对应</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.contrib <span class="keyword">import</span> admin</span><br><span class="line"><span class="keyword">from</span> django.urls <span class="keyword">import</span> path</span><br><span class="line"><span class="keyword">from</span> book <span class="keyword">import</span> views</span><br><span class="line"></span><br><span class="line">urlpatterns = [</span><br><span class="line">    path(<span class="string">&#x27;admin/&#x27;</span>, admin.site.urls),</span><br><span class="line">    path(<span class="string">&#x27;book/&#x27;</span>, views.book),</span><br><span class="line">    <span class="comment"># /book/detail/1/</span></span><br><span class="line">    path(<span class="string">&#x27;book/detail/&lt;book_id&gt;/&lt;category_id&gt;/&#x27;</span>, views.book_detail),</span><br><span class="line">    path(<span class="string">&#x27;book/author/&#x27;</span>, views.author_detail)，</span><br><span class="line">    path(<span class="string">&#x27;book/publisher/&lt;int:publisher_id&gt;/&#x27;</span>, views.publisher_detail),</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<h2 id="url传递参数"><a href="#url传递参数" class="headerlink" title="url传递参数"></a>url传递参数</h2><ol>
<li><code>urls.py</code>文件，<code>&lt;参数名&gt;</code>传递，默认使用<code>str</code>转换器，如<code>&lt;int:publisher_id&gt;</code>。视图函数中，参数名要和它一致</li>
<li>查询字符串的方式，访问浏览器时参数如<code>?id=2</code>，<code>http://127.0.0.1:8000/book/author/?id=2</code></li>
<li>转换器：<code>int</code>,<code>path</code>,<code>slug</code>,<code>str</code>,<code>uuid</code></li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">author_detail</span>(<span class="params">request</span>):</span></span><br><span class="line">    author_id = request.GET.get(<span class="string">&#x27;id&#x27;</span>)</span><br><span class="line">    <span class="comment">#author_id = request.GET[&#x27;id&#x27;]   #这种写法也可以，GET类似字典，获取值方式与字典相同</span></span><br><span class="line">    text = <span class="string">&#x27;作者的id是：%s&#x27;</span> % author_id</span><br><span class="line">    <span class="keyword">return</span> HttpResponse(text)</span><br></pre></td></tr></table></figure>

<h3 id="url映射时指定默认参数"><a href="#url映射时指定默认参数" class="headerlink" title="url映射时指定默认参数"></a>url映射时指定默认参数</h3><p><code>views.py</code>中，可以给函数指定默认参数，<code>url</code>中没有传递的话，使用默认参数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">books</span>(<span class="params">request, page=<span class="number">0</span></span>):</span></span><br><span class="line">    <span class="keyword">return</span> HttpResponse(book_list[page])</span><br></pre></td></tr></table></figure>

<h3 id="url参数内置的转换器"><a href="#url参数内置的转换器" class="headerlink" title="url参数内置的转换器"></a>url参数内置的转换器</h3><ol>
<li>str：除了<code>/</code>以外的所有字符</li>
<li>int：一个或多个数字</li>
<li>path：所有字符</li>
<li>uuid：只有满足<code>uuid.uuid4()</code>函数返回的字符串格式</li>
<li>slug：<code>-</code>，<code>_</code>，英文字母，数字任意组合</li>
</ol>
<h3 id="自定义url-path-转换器"><a href="#自定义url-path-转换器" class="headerlink" title="自定义url(path)转换器"></a>自定义url(path)转换器</h3><ol>
<li>定义一个类，直接继承自object就可以了</li>
<li>在类中定义一个属性regex，这个属性是用来保存url转换器规则的正则表达式</li>
<li>实现to_python(self, value)方法，作用是将url中的值转换一下，然后传给视图函数</li>
<li>实现to_url(self, value)方法，作用是在做url反转时，将传进来的参数转换后拼接成一个正确的url</li>
<li>将定义好的转换器，使用<code>django.urls.converters.register_converter</code>方法注册到django中</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.urls <span class="keyword">import</span> converters, register_converter</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CategoryConverter</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    regex = <span class="string">r&#x27;\w+|(\w+\+\w+)+&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">to_python</span>(<span class="params">self, value</span>):</span></span><br><span class="line">        <span class="comment"># python+django+flask</span></span><br><span class="line">        <span class="comment"># [&#x27;python&#x27;, &#x27;django&#x27;, &#x27;flask&#x27;]</span></span><br><span class="line">        result = value.split(<span class="string">&#x27;+&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">to_url</span>(<span class="params">self,value</span>):</span></span><br><span class="line">        <span class="comment"># value: [&#x27;python&#x27;, &#x27;django&#x27;, &#x27;flask&#x27;]</span></span><br><span class="line">        <span class="comment"># python+django+flask</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">isinstance</span>(value, <span class="built_in">list</span>):</span><br><span class="line">            result = <span class="string">&#x27;+&#x27;</span>.join(value)</span><br><span class="line">            <span class="keyword">return</span> result</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">raise</span> RuntimeError(<span class="string">&#x27;转换url时，分类参数必须为列表&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 注册</span></span><br><span class="line">register_converter(CategoryConverter, <span class="string">&#x27;cate&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p><strong>注</strong>：可以将以上代码单独存为<code>converters.py</code>文件，在<code>__init__.py</code>中导入，<code>from . import converters</code>，自动执行</p>
<h2 id="urls模块化"><a href="#urls模块化" class="headerlink" title="urls模块化"></a>urls模块化</h2><ol>
<li>主url对app的url引用，将url进行拼接，注意<code>/</code>，只写在末尾</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#主url</span></span><br><span class="line"><span class="keyword">from</span> django.contrib <span class="keyword">import</span> admin</span><br><span class="line"><span class="keyword">from</span> django.urls <span class="keyword">import</span> path, include</span><br><span class="line"></span><br><span class="line">urlpatterns = [</span><br><span class="line">    path(<span class="string">&#x27;admin/&#x27;</span>, admin.site.urls),</span><br><span class="line">    path(<span class="string">&#x27;book/&#x27;</span>,include(<span class="string">&#x27;book.urls&#x27;</span>))</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>app中的url单独放在自己的<code>urls.py</code>文件中，如下面名为的<code>book</code>的app</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#app的url</span></span><br><span class="line"><span class="keyword">from</span> django.urls <span class="keyword">import</span> path</span><br><span class="line"><span class="keyword">from</span> . <span class="keyword">import</span> views</span><br><span class="line"></span><br><span class="line">urlpatterns = [</span><br><span class="line">    <span class="comment">#book/</span></span><br><span class="line">    path(<span class="string">&#x27;&#x27;</span>, views.book),</span><br><span class="line">    path(<span class="string">&#x27;detail/&lt;book_id&gt;/&#x27;</span>, views.book_detail),</span><br><span class="line">    path(<span class="string">&#x27;list/&#x27;</span>,views.book_list),</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<h2 id="url命名"><a href="#url命名" class="headerlink" title="url命名"></a>url命名</h2><p>url经常变换，取个名字，调用时用<code>reverse(&#39;name&#39;)</code>进行反转，方便调用修改等</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.urls <span class="keyword">import</span> path</span><br><span class="line"><span class="keyword">from</span> . <span class="keyword">import</span> views</span><br><span class="line"></span><br><span class="line">urlpatterns = [</span><br><span class="line">    path(<span class="string">&#x27;&#x27;</span>, views.index, name=<span class="string">&#x27;index&#x27;</span>),</span><br><span class="line">    path(<span class="string">&#x27;login/&#x27;</span>, views.login, name= <span class="string">&#x27;login&#x27;</span>),</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<h3 id="应用（app）命名空间"><a href="#应用（app）命名空间" class="headerlink" title="应用（app）命名空间"></a>应用（app）命名空间</h3><p>多个app中，有可能出现同名的url，避免混淆，使用应用命名空间。<br>在<code>app</code>的<code>urls.py</code>中，定义一个叫<code>app_name</code>的变量。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.urls <span class="keyword">import</span> path</span><br><span class="line"><span class="keyword">from</span> . <span class="keyword">import</span> views</span><br><span class="line"></span><br><span class="line">app_name = <span class="string">&#x27;front&#x27;</span>   <span class="comment">#命名空间</span></span><br><span class="line"></span><br><span class="line">urlpatterns = [</span><br><span class="line">    path(<span class="string">&#x27;&#x27;</span>, views.index, name=<span class="string">&#x27;index&#x27;</span>),</span><br><span class="line">    path(<span class="string">&#x27;login/&#x27;</span>, views.login, name= <span class="string">&#x27;login&#x27;</span>),</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>反转时使用<code>应用命名空间:url名称</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">login_url = reverse(<span class="string">&#x27;front:login&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="实例命名空间"><a href="#实例命名空间" class="headerlink" title="实例命名空间"></a>实例命名空间</h3><p>一个app，可以创建多个实例，可以用多个url映射同一个app。为了避免在url反转时发生混淆，使用实例命名空间。<br>在项目根目录的<code>urls.py</code>文件中，在<code>include</code>函数中传递一个<code>namespace</code>变量即可。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">urlpatterns = [</span><br><span class="line">    path(<span class="string">&#x27;&#x27;</span>, include(<span class="string">&#x27;front.urls&#x27;</span>)),</span><br><span class="line">    <span class="comment">#同一个app下有两个实例</span></span><br><span class="line">    path(<span class="string">&#x27;cms1/&#x27;</span>, include(<span class="string">&#x27;cms.urls&#x27;</span>,namespace=<span class="string">&#x27;cms1&#x27;</span>)),</span><br><span class="line">    path(<span class="string">&#x27;cms2/&#x27;</span>, include(<span class="string">&#x27;cms.urls&#x27;</span>,namespace=<span class="string">&#x27;cms2&#x27;</span>)),</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>在url反转时，根据实例命名空间来指定具体的url。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span>(<span class="params">request</span>):</span></span><br><span class="line">    username = request.GET.get(<span class="string">&#x27;username&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> username:</span><br><span class="line">        <span class="keyword">return</span> HttpResponse(<span class="string">&#x27;CMS首页&#x27;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        current_namespace = request.resolver_match.namespace   <span class="comment">#获得当前实例命名空间</span></span><br><span class="line">        <span class="keyword">return</span> redirect(reverse(<span class="string">&#x27;%s:login&#x27;</span>%current_namespace))</span><br></pre></td></tr></table></figure>

<h2 id="include函数"><a href="#include函数" class="headerlink" title="include函数"></a>include函数</h2><p>根目录<code>urls.py</code>中，<code>path()</code>中</p>
<ol>
<li><code>include(module, namespace=None)</code></li>
</ol>
<ul>
<li><p><code>module</code>：子url的模块字符串</p>
</li>
<li><p><code>namespace</code>：实例命名空间，需先指定应用命名空间。即在子<code>urls.py</code>中添加<code>app_name</code>变量</p>
<p>  <code>path(&#39;cms1/&#39;, include(&#39;cms.urls&#39;,namespace=&#39;cms1&#39;))</code></p>
</li>
</ul>
<ol start="2">
<li><p><code>include((pattern_list, app_namespace), namespace=None)</code></p>
<p> 元组（tuple）第一个参数是<code>urls.py</code>模块字符串，第二个参数是应用命名空间。<br> 应用命名空间，可以在子<code>urls.py</code>中通过<code>app_name</code>指定，也可以在<code>include</code>函数中指定。</p>
<p> <code>path(&#39;book/&#39;, include((&#39;book.urls&#39;, &#39;book&#39;), namespace=&#39;book&#39;))</code></p>
</li>
<li><p><code>include(pattern_list)</code></p>
<p> <code>pattern_list</code>是一个列表，元素为<code>path</code>或<code>re_path</code></p>
</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">path(<span class="string">&#x27;movie/&#x27;</span>, include([</span><br><span class="line">    path(<span class="string">&#x27;&#x27;</span>, views.movie),</span><br><span class="line">    path(<span class="string">&#x27;list/&#x27;</span>, views.movie_list),</span><br><span class="line">]))</span><br></pre></td></tr></table></figure>

<h2 id="re-path"><a href="#re-path" class="headerlink" title="re_path"></a>re_path</h2><ol>
<li>推荐使用原生字符串，即<code>r</code>开头的字符串</li>
<li>定义的变量，需要用<code>()</code>括起来，<code>?P&lt;参数的名字&gt;</code>，后面添加正则表达式规则</li>
<li>优先用<code>path</code></li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.urls <span class="keyword">import</span> re_path</span><br><span class="line"><span class="keyword">from</span> . <span class="keyword">import</span> views</span><br><span class="line"></span><br><span class="line">urlpatterns = [</span><br><span class="line">    re_path(<span class="string">&#x27;^$&#x27;</span>, views.article),</span><br><span class="line">    <span class="comment"># /article/list/&lt;year&gt;/</span></span><br><span class="line">    re_path(<span class="string">r&#x27;^list/(?P&lt;year&gt;\d&#123;4&#125;)/$&#x27;</span>, views.article_list),</span><br><span class="line">    re_path(<span class="string">r&#x27;^list/(?P&lt;month&gt;\d&#123;2&#125;)/$&#x27;</span>, views.article_list_month),</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<h2 id="reverse"><a href="#reverse" class="headerlink" title="reverse()"></a>reverse()</h2><ol>
<li>反转url时，如果需要添加参数，使用<code>kwargs</code>参数传递</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.shortcuts <span class="keyword">import</span> redirect, reverse</span><br><span class="line"></span><br><span class="line">detail_url = reverse(<span class="string">&#x27;detail&#x27;</span>, kwargs=&#123;<span class="string">&#x27;article_id&#x27;</span>:<span class="number">1</span>, <span class="string">&#x27;page&#x27;</span>:<span class="number">2</span>&#125;)</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>如果添加查询字符串的参数，必须手动进行拼接</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">login_url = reverse(<span class="string">&#x27;login&#x27;</span>) + <span class="string">&#x27;?next=/&#x27;</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>django</category>
      </categories>
      <tags>
        <tag>django</tag>
      </tags>
  </entry>
  <entry>
    <title>django笔记05 - 视图高级</title>
    <url>/2019/03/03/django%E7%AC%94%E8%AE%B005/</url>
    <content><![CDATA[<h1 id="Django限制请求method"><a href="#Django限制请求method" class="headerlink" title="Django限制请求method"></a>Django限制请求method</h1><h2 id="常用的请求method："><a href="#常用的请求method：" class="headerlink" title="常用的请求method："></a>常用的请求method：</h2><ol>
<li>GET请求：GET请求一般用来向服务器索取数据，但不会向服务器提交数据，不会对服务器的状态进行更改。比如向服务器获取某篇文章的详情。</li>
<li>POST请求：POST请求一般是用来向服务器提交数据，会对服务器的状态进行更改。比如提交一篇文章给服务器。</li>
</ol>
<span id="more"></span>

<h2 id="限制请求装饰器："><a href="#限制请求装饰器：" class="headerlink" title="限制请求装饰器："></a>限制请求装饰器：</h2><p>Django内置的视图装饰器可以给视图提供一些限制。比如这个视图只能通过GET的method访问等。以下将介绍一些常用的内置视图装饰器。</p>
<ol>
<li><code>django.http.decorators.http.require_http_methods</code>：这个装饰器需要传递一个允许访问的方法的列表。比如只能通过<code>GET</code>的方式访问。那么示例代码如下：</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.views.decorators.http <span class="keyword">import</span> require_http_methods</span><br><span class="line"></span><br><span class="line"><span class="meta">@require_http_methods(<span class="params">[<span class="string">&quot;GET&quot;</span>]</span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_view</span>(<span class="params">request</span>):</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li><code>django.views.decorators.http.require_GET</code>：这个装饰器相当于是<code>require_http_methods([&#39;GET&#39;])</code>的简写形式，只允许使用<code>GET</code>的<code>method</code>来访问视图。示例代码如下：</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.views.decorators.http <span class="keyword">import</span> require_GET</span><br><span class="line"></span><br><span class="line"><span class="meta">@require_GET</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_view</span>(<span class="params">request</span>):</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li><code>django.views.decorators.http.require_POST</code>：这个装饰器相当于是<code>require_http_methods([&#39;POST&#39;])</code>的简写形式，只允许使用POST的method来访问视图。示例代码如下：</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.views.decorators.http <span class="keyword">import</span> require_POST</span><br><span class="line"></span><br><span class="line"><span class="meta">@require_POST</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_view</span>(<span class="params">request</span>):</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>

<ol start="4">
<li><code>django.views.decorators.http.require_safe</code>：这个装饰器相当于是<code>require_http_methods([&#39;GET&#39;,&#39;HEAD&#39;])</code>的简写形式，只允许使用相对安全的方式来访问视图。因为GET和HEAD不会对服务器产生增删改的行为。因此是一种相对安全的请求方式。示例代码如下：</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.views.decorators.http <span class="keyword">import</span> require_safe</span><br><span class="line"></span><br><span class="line"><span class="meta">@require_safe</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_view</span>(<span class="params">request</span>):</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>学习笔记</category>
        <category>django</category>
      </categories>
      <tags>
        <tag>django</tag>
      </tags>
  </entry>
  <entry>
    <title>markdown语法笔记</title>
    <url>/2019/01/09/markdown%E8%AF%AD%E6%B3%95%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h1><p>第一级标题，开头就是一个 #<br>第二级标题，开头就是两个 #<br>第三级标题，开头就是三个 #</p>
<p>注意：标题需要独自占据一行，并且在标题的文字和 # 之间需要有一个空格。<br>在标题的这一行，上下都需要一个空行分割</p>
<span id="more"></span>

<h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><h2 id="单行引用"><a href="#单行引用" class="headerlink" title="单行引用"></a>单行引用</h2><blockquote>
<p>悲剧将人生的有价值的东西毁灭给人看，喜剧将那无价值的撕破给人看。——鲁迅。</p>
</blockquote>
<h2 id="多行引用"><a href="#多行引用" class="headerlink" title="多行引用"></a>多行引用</h2><blockquote>
<p>悲剧将人生的有价值的东西毁灭给人看，喜剧将那无价值的撕破给人看。<br>————鲁迅</p>
</blockquote>
<h1 id="代码标记"><a href="#代码标记" class="headerlink" title="代码标记"></a>代码标记</h1><h2 id="行内标记"><a href="#行内标记" class="headerlink" title="行内标记"></a>行内标记</h2><p>我要把这行里的<code>hello world</code>标记出来</p>
<h2 id="普通代码块标记"><a href="#普通代码块标记" class="headerlink" title="普通代码块标记"></a>普通代码块标记</h2><pre><code>var executeSync = function()&#123;
    var args = Array.prototype.slice.call(arguments);
    if (typeof args[0] === &#39;function&#39;)&#123;
        args[0].apply(null, args.splice(1));
    &#125;
&#125;;
</code></pre>
<h2 id="高亮代码块标记"><a href="#高亮代码块标记" class="headerlink" title="高亮代码块标记"></a>高亮代码块标记</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, path=<span class="string">&#x27;&#x27;</span></span>):</span></span><br><span class="line">    self._path = path</span><br></pre></td></tr></table></figure>

<h1 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h1><ol>
<li>你拍一</li>
<li>我拍二</li>
<li>她拍三</li>
</ol>
<ul>
<li>你拍一</li>
<li>我拍二</li>
<li>她拍三</li>
</ul>
<h1 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h1><p><a href="https://11.tt/">这是一个链接</a></p>
<p><a href="https://11.tt/">这是一个链接</a></p>
<p><a href="#%E5%88%97%E8%A1%A8">链接列表</a></p>
<h1 id="插入图片"><a href="#插入图片" class="headerlink" title="插入图片"></a>插入图片</h1><p>![Markdown 创始人 John Gruber](John Gruber.jpg)</p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>markdwon</tag>
      </tags>
  </entry>
  <entry>
    <title>python笔记</title>
    <url>/2019/01/14/python%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="join"><a href="#join" class="headerlink" title="join()"></a>join()</h1><p>join() 方法用于将序列中的元素以指定的字符连接生成一个新的字符串。<br><code>str.join(item)</code>，join函数是一个字符串操作函数。<br><code>str</code>表示字符串（字符），<code>item</code>表示一个成员，注意括号里必须只能有一个成员，比如<code>&#39;,&#39;.join(&#39;a&#39;,&#39;b&#39;)</code>这种写法是行不通的。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#将字符串abc中的每个成员，以字符&#x27;,&#x27;分隔开再拼接成一个字符串</span></span><br><span class="line"><span class="string">&#x27;,&#x27;</span>.join(<span class="string">&#x27;abc&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>输出结果为<code>&#39;a,b,c&#39;</code></p>
<p>join里放列表、元组、字典也是可以的</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;;&#x27;</span>.join([a,b,c])</span><br><span class="line">&gt;&gt;  <span class="string">&#x27;a;b;c&#x27;</span></span><br></pre></td></tr></table></figure>

<p>参考：<a href="https://blog.csdn.net/chixujohnny/article/details/53301995">Python中的 .join()用法</a></p>
<span id="more"></span>

<h1 id="split"><a href="#split" class="headerlink" title="split()"></a>split()</h1><p><code>str.split(sep=&quot;&quot;,num=string.count(str))[n]</code><br>拆分字符串。通过指定分隔符对字符串进行切片，并返回分割后的字符串列表（list），如果参数 num 有指定值，则仅分隔 num+1 个子字符串。</p>
<ul>
<li><code>sep</code>：表示为分隔符，默认为所有的空字符，包括空格、换行(\n)、制表符(\t)等，但是不能为空(‘’)。若字符串中没有分隔符，则把整个字符串作为列表的一个元素</li>
<li><code>num</code>：表示分割次数。如果存在参数num，则仅分隔成 num+1 个子字符串，并且每一个子字符串可以赋给新的变量</li>
<li><code>[n]</code>：表示选取第n个分片</li>
</ul>
<ol>
<li>无参数的情况</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a=<span class="string">&quot;my name is zhangkang&quot;</span></span><br><span class="line">b=<span class="string">&quot;my\nname\nis\nzhangkang&quot;</span></span><br><span class="line">c=<span class="string">&quot;my\tname\tis\tzhangkang&quot;</span></span><br><span class="line"></span><br><span class="line">a=a.split()</span><br><span class="line">b=b.split()</span><br><span class="line">c=c.split()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="built_in">print</span>(b)</span><br><span class="line"><span class="built_in">print</span>(c)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出：</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[<span class="string">&#x27;my&#x27;</span>, <span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;is&#x27;</span>, <span class="string">&#x27;zhangkang&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[<span class="string">&#x27;my&#x27;</span>, <span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;is&#x27;</span>, <span class="string">&#x27;zhangkang&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[<span class="string">&#x27;my&#x27;</span>, <span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;is&#x27;</span>, <span class="string">&#x27;zhangkang&#x27;</span>]</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>有参数的情况</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">d=<span class="string">&quot;my,name,is,zhangkang&quot;</span></span><br><span class="line">e=<span class="string">&quot;my;name;is;zhangkang&quot;</span></span><br><span class="line">f=<span class="string">&quot;my-name-is-zhangkang&quot;</span></span><br><span class="line"></span><br><span class="line">d=d.split(<span class="string">&quot;,&quot;</span>)</span><br><span class="line">e=e.split(<span class="string">&quot;;&quot;</span>)</span><br><span class="line">f=f.split(<span class="string">&quot;-&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(d)</span><br><span class="line"><span class="built_in">print</span>(e)</span><br><span class="line"><span class="built_in">print</span>(f)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出：</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[<span class="string">&#x27;my&#x27;</span>, <span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;is&#x27;</span>, <span class="string">&#x27;zhangkang&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[<span class="string">&#x27;my&#x27;</span>, <span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;is&#x27;</span>, <span class="string">&#x27;zhangkang&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[<span class="string">&#x27;my&#x27;</span>, <span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;is&#x27;</span>, <span class="string">&#x27;zhangkang&#x27;</span>]</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>有两个参数的情况</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a=<span class="string">&quot;My,name,is,zhangkang,and,I,am,a,student&quot;</span></span><br><span class="line">b1=a.split(<span class="string">&quot;,&quot;</span>,<span class="number">1</span>)</span><br><span class="line">b2=a.split(<span class="string">&quot;,&quot;</span>,<span class="number">2</span>)</span><br><span class="line">b8=a.split(<span class="string">&quot;,&quot;</span>,<span class="number">8</span>)</span><br><span class="line">b9=a.split(<span class="string">&quot;,&quot;</span>,<span class="number">9</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(b1)</span><br><span class="line"><span class="built_in">print</span>(b2)</span><br><span class="line"><span class="built_in">print</span>(b8)</span><br><span class="line"><span class="built_in">print</span>(b9)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出：</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[<span class="string">&#x27;My&#x27;</span>, <span class="string">&#x27;name,is,zhangkang,and,I,am,a,student&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[<span class="string">&#x27;My&#x27;</span>, <span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;is,zhangkang,and,I,am,a,student&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[<span class="string">&#x27;My&#x27;</span>, <span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;is&#x27;</span>, <span class="string">&#x27;zhangkang&#x27;</span>, <span class="string">&#x27;and&#x27;</span>, <span class="string">&#x27;I&#x27;</span>, <span class="string">&#x27;am&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;student&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[<span class="string">&#x27;My&#x27;</span>, <span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;is&#x27;</span>, <span class="string">&#x27;zhangkang&#x27;</span>, <span class="string">&#x27;and&#x27;</span>, <span class="string">&#x27;I&#x27;</span>, <span class="string">&#x27;am&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;student&#x27;</span>] <span class="comment">#超过最大分割次数，还是最大分割，不报错</span></span><br></pre></td></tr></table></figure>

<p>参考：<a href="https://blog.csdn.net/csdn15698845876/article/details/74012511">python中split()函数讲解</a></p>
<h1 id="strip"><a href="#strip" class="headerlink" title="strip()"></a>strip()</h1><p>声明：<code>s</code>为字符串，<code>rm</code>为要删除的字符序列。<br>当<code>rm</code>为空时，默认删除空白符（包括<code>\n</code>, <code>\r</code>,  <code>\t</code>,  <code>&#39; &#39;</code>)</p>
<p><code>s.strip(rm)</code>，删除s字符串中开头、结尾处，位于rm删除序列的字符<br><code>s.lstrip(rm)</code>，删除s字符串中开头处，位于rm删除序列的字符<br><code>s.rstrip(rm)</code>，删除s字符串中结尾处，位于rm删除序列的字符</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">b = <span class="string">&#x27;123abc&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b.strip(<span class="string">&#x27;12&#x27;</span>)</span><br><span class="line"><span class="string">&#x27;3abc&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b.strip(<span class="string">&#x27;21&#x27;</span>) <span class="comment"># 没有顺序</span></span><br><span class="line"><span class="string">&#x27;3abc&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b.strip(<span class="string">&#x27;31&#x27;</span>) <span class="comment"># 只要开头和结尾中含有rm中的字符 就删除</span></span><br><span class="line"><span class="string">&#x27;23abc&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b.strip(<span class="string">&#x27;bc&#x27;</span>)</span><br><span class="line"><span class="string">&#x27;123a&#x27;</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>七天带你玩转MySQL之SQL语句</title>
    <url>/2019/02/09/%E4%B8%83%E5%A4%A9%E5%B8%A6%E4%BD%A0%E7%8E%A9%E8%BD%ACMySQL%E4%B9%8BSQL%E8%AF%AD%E5%8F%A5/</url>
    <content><![CDATA[<h1 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h1><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> ... <span class="keyword">from</span> ....</span><br><span class="line"><span class="keyword">where</span> ...</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> ...</span><br><span class="line"><span class="keyword">having</span> ...</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> ...</span><br><span class="line">limit ...;</span><br></pre></td></tr></table></figure>

<p>执行顺序：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> <span class="keyword">from</span></span><br><span class="line"><span class="number">2</span> <span class="keyword">where</span></span><br><span class="line"><span class="number">3</span> <span class="keyword">group</span> <span class="keyword">by</span></span><br><span class="line"><span class="number">4</span> <span class="keyword">select</span></span><br><span class="line"><span class="number">5</span> <span class="keyword">having</span></span><br><span class="line"><span class="number">6</span> <span class="keyword">order</span> <span class="keyword">by</span></span><br><span class="line"><span class="number">7</span> limit</span><br></pre></td></tr></table></figure>

<h1 id="group-by"><a href="#group-by" class="headerlink" title="group by"></a>group by</h1><p>MySql从5.7版本开始默认开启<code>only_full_group_by</code>规则，规则核心原则如下，没有遵循原则的sql会被认为是不合法的sql</p>
<ol>
<li><code>order by</code>后面的列必须是在<code>select</code>后面存在的</li>
<li><code>select</code>、<code>having</code>或<code>order by</code>后面存在的非聚合列必须全部在<code>group by</code>中存在</li>
</ol>
<h1 id="count-、count-1-、count-主键-、count-字段-的区别"><a href="#count-、count-1-、count-主键-、count-字段-的区别" class="headerlink" title="count(*)、count(1)、count(主键)、count(字段)的区别"></a>count(*)、count(1)、count(主键)、count(字段)的区别</h1><p>以下，基于 InnoDB</p>
<h2 id="含义区别"><a href="#含义区别" class="headerlink" title="含义区别"></a>含义区别</h2><p>count()是一个聚合函数，对于返回的结果集，会逐行判断，若返回的不是 NULL，就会加 1，否则不加。<br>因此，count(*)、count(主键 id)和count(1)都表示返回满足条件的结果集的总行数；而count(字段），则表示返回满足条件的数据行里面，参数“字段”不为 NULL 的总个数。</p>
<h2 id="性能区别"><a href="#性能区别" class="headerlink" title="性能区别"></a>性能区别</h2><p>分析性能，考虑以下几个原则：</p>
<ol>
<li>server 层要什么就会返回什么；</li>
<li>InnoDB 只返回必要的值；</li>
<li>优化器只优化了count(*)</li>
</ol>
<ul>
<li>对于count(主键id)，InnoDB 会遍历全表，取每行的主键 id，返回给 server 层，server 层拿到数据后，进行判断累加。</li>
<li>对于count(1)，InnoDB 仍遍历全表，但是不取值，server 层对返回的每一行数据新增一个 1，然后进行判断累加；<br>因此，count(1)要更快些，因为无需取值。从引擎返回 id 会涉及到解析数据行，以及拷贝字段值的操作。</li>
<li>对于count(字段)：</li>
</ul>
<ol>
<li>如果这个“字段”是定义为 not null 的话，一行行地从记录里面读出这个字段，判断不能为 null，按行累加；</li>
<li>如果这个“字段”定义允许为 null，那么执行的时候，判断到有可能是null，还要把值取出来再判断一下，不是 null 才累加。</li>
</ol>
<ul>
<li>但是<code>count(*)</code>是例外，并不会把全部字段取出来，而是专门做了优化，不取值。<code>count(*)</code>肯定不是<code>null</code>，按行累加。</li>
</ul>
<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>按照效率排序的话</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">count(字段) &lt; count(主键 id) &lt; count(1) ≈ count(*)</span><br></pre></td></tr></table></figure>

<p>所以我建议你，尽量使用<code>count(*)</code></p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>手机摄影教程@贾树森（大树）</title>
    <url>/2021/05/09/%E6%89%8B%E6%9C%BA%E6%91%84%E5%BD%B1%E6%95%99%E7%A8%8B-%E8%B4%BE%E6%A0%91%E6%A3%AE%EF%BC%88%E5%A4%A7%E6%A0%91%EF%BC%89/</url>
    <content><![CDATA[<h1 id="第4课-摄影之眼是怎样炼成的？"><a href="#第4课-摄影之眼是怎样炼成的？" class="headerlink" title="第4课 摄影之眼是怎样炼成的？"></a>第4课 摄影之眼是怎样炼成的？</h1><ol>
<li>好照片的标准：明确的主题，主体突出，画面简洁</li>
<li>学会发现生活中的没，提高自己的摄影眼力</li>
</ol>
<span id="more"></span>

<h1 id="第8课：不同环境中如何运用光线？"><a href="#第8课：不同环境中如何运用光线？" class="headerlink" title="第8课：不同环境中如何运用光线？"></a>第8课：不同环境中如何运用光线？</h1><ol>
<li>正确认知和把握光线能够拍出好照片</li>
</ol>
<ul>
<li>顺光——光感均匀但是比较平</li>
<li>侧光——立体感、质感、突出照片主体</li>
<li>逆光——剪影、画面氛围感</li>
<li>顶光(骷髅光) ——室内光、中午的太阳光、不推荐</li>
<li>曝光——亮的时候调高，暗的时候调低</li>
</ul>
<ol start="2">
<li>由静到动由浅入深有助于熟练运用光线</li>
<li>日出后俩小时、日落前俩小时是黄金时间，尽量不在正午室外拍照</li>
<li>室内拍照尽量靠近窗户，光源明亮、稳定  营造多种光线（顺光、逆光、侧光），拉上纱窗光线更柔和。或者打开室内灯光</li>
</ol>
<h1 id="第10课：手机摄影构图有哪些？"><a href="#第10课：手机摄影构图有哪些？" class="headerlink" title="第10课：手机摄影构图有哪些？"></a>第10课：手机摄影构图有哪些？</h1><ol>
<li>对角线构图具有强烈的动感视觉冲击</li>
<li>中心构图简单直接，主体突出</li>
<li>对称式构图有助于表现比较平衡稳定的画面</li>
<li>三分法构图是获得黄金视觉的简单方法</li>
<li>框架式构图有助于屏蔽杂乱背景，突出主体，增加画面趣味性</li>
</ol>
<h1 id="第11课：如何在复杂背景下突出拍摄主体？"><a href="#第11课：如何在复杂背景下突出拍摄主体？" class="headerlink" title="第11课：如何在复杂背景下突出拍摄主体？"></a>第11课：如何在复杂背景下突出拍摄主体？</h1><ol>
<li>线条可以充当引导线，将视线引导到视觉中心（主体）</li>
<li>用好前景有助于表现画面的纵深感</li>
<li>背景选择是照片成败的关键</li>
<li>构图的实质是想方设法突出主体</li>
</ol>
<h1 id="第12课：照片的横平竖直是怎么回事儿？"><a href="#第12课：照片的横平竖直是怎么回事儿？" class="headerlink" title="第12课：照片的横平竖直是怎么回事儿？"></a>第12课：照片的横平竖直是怎么回事儿？</h1><ol>
<li>横平竖直的照片看起来比较舒服</li>
<li>依靠取景边框以及参考线作为辅助有助于拍出横平竖直的照片</li>
<li>横平和竖直可以分开满足</li>
<li>绝大部分的照片需要遵循横平竖直这一基本原则</li>
</ol>
<h1 id="第15课：怎样才能拍出视角独特的照片？"><a href="#第15课：怎样才能拍出视角独特的照片？" class="headerlink" title="第15课：怎样才能拍出视角独特的照片？"></a>第15课：怎样才能拍出视角独特的照片？</h1><ol>
<li>复牌有利于表现地平面上的景物层次、数量、位置等等，能够给人一种辽阔、深远的感受</li>
<li>仰拍有利于突出被摄体高达的气势，适合表现上部空间</li>
<li>平拍时被摄对象不变形，会使人感到平等和亲切</li>
<li>尝试从仰拍俯拍以及平拍多个角度去拍摄，容易寻找到不寻常的视角</li>
</ol>
<h1 id="第16课：如何拍出刷爆朋友圈的美食？"><a href="#第16课：如何拍出刷爆朋友圈的美食？" class="headerlink" title="第16课：如何拍出刷爆朋友圈的美食？"></a>第16课：如何拍出刷爆朋友圈的美食？</h1><ol>
<li>拍摄美食尽量选择靠窗的位置获得良好光线，侧光和逆光有助于更好的表现美食，构图时注意景别的变化</li>
<li>美食摄影的APP推荐：foodie美食相机</li>
</ol>
<h1 id="第17课：怎样在不同环境下把人像拍美？"><a href="#第17课：怎样在不同环境下把人像拍美？" class="headerlink" title="第17课：怎样在不同环境下把人像拍美？"></a>第17课：怎样在不同环境下把人像拍美？</h1><ol>
<li>采取“动起来”的方式，可以使拍摄的人像照片不死板</li>
<li>靠近被摄对象，采取低角度仰拍会使腿显得修长</li>
<li>选择和环境颜色差异大的服装有助于突出主体</li>
<li>特写人像主要突出人物面部轮廓及表情，全身人像囊括更多的风景，半身人像则兼而得之</li>
</ol>
<h1 id="第18课：如何拍摄活泼好动的孩子？"><a href="#第18课：如何拍摄活泼好动的孩子？" class="headerlink" title="第18课：如何拍摄活泼好动的孩子？"></a>第18课：如何拍摄活泼好动的孩子？</h1><ol>
<li>在光线明亮处拍照，拍照时稳住手机，光线不好时不拍快速激烈的动作等，会让拍孩子的照片不虚</li>
<li>熟练手机拍照各项功能，让自己处于时刻可以拍照的状态有助于抓住孩子的精彩瞬间</li>
<li>搭配服装时，颜色不宜过多，尽量选择跟背景差异比较大的颜色衣服</li>
</ol>
<h1 id="第19课：怎样自拍好看又不落俗套？"><a href="#第19课：怎样自拍好看又不落俗套？" class="headerlink" title="第19课：怎样自拍好看又不落俗套？"></a>第19课：怎样自拍好看又不落俗套？</h1><ol>
<li>手持相机自拍时，可以采取闭眼睛，拍影子，通过镜子自拍等方法让自拍照与众不同</li>
<li>使用自拍杆进行自拍时，通过尽力少露或不露自拍杆使照片跟生活照有所区别</li>
<li>把手机固定在三脚架上进行自拍，可以进行跳跃等各种富有创意的自拍</li>
<li>矿泉水瓶，杯子等都可以临时充当三脚架来进行自拍</li>
</ol>
<h1 id="第20课：如何拍好花卉？"><a href="#第20课：如何拍好花卉？" class="headerlink" title="第20课：如何拍好花卉？"></a>第20课：如何拍好花卉？</h1><ol>
<li>通过虚实对比，色彩对比，明暗对比和选择尽量干净的背景可以使花朵更突出</li>
<li>最适合拍花的光线是侧光、侧逆光、逆光和局部光线</li>
<li>拍花忌构图太满，可以采取疏密有致、留白、对角线构图等</li>
<li>拍花除了采用干净背景，更要把现场背景有机搭配，丰富画面</li>
<li>通过变幻视角，拍摄花的影子甚至是水中倒影等使照片别具一格</li>
</ol>
<h1 id="第21课：怎样拍好全家福？"><a href="#第21课：怎样拍好全家福？" class="headerlink" title="第21课：怎样拍好全家福？"></a>第21课：怎样拍好全家福？</h1><ol>
<li>拍摄全家福要选择干净的背景，明亮均匀的光线</li>
<li>使用三脚架拍摄全家福方便取景</li>
<li>焦点放在前排中间人的面部，并锁定焦点和曝光</li>
<li>服装穿着要讲究</li>
<li>对待不爱拍照的孩子要有耐心，不能心急勉强</li>
</ol>
<h1 id="第22课：雨雪天气怎么拍？"><a href="#第22课：雨雪天气怎么拍？" class="headerlink" title="第22课：雨雪天气怎么拍？"></a>第22课：雨雪天气怎么拍？</h1><ol>
<li>“恶劣”天气的光线特点是光线亮度比较低，光线均匀，反差小</li>
<li>建议：</li>
</ol>
<ul>
<li>采用框架式和留白构图</li>
<li>拍摄阴天的天空，拍摄水中的倒影，拍摄玻璃上的水珠</li>
<li>运用鲜艳的色彩</li>
</ul>
<h1 id="第25课：如何让照片具有故事性？"><a href="#第25课：如何让照片具有故事性？" class="headerlink" title="第25课：如何让照片具有故事性？"></a>第25课：如何让照片具有故事性？</h1><ol>
<li>尽量横构图，拍摄有故事的场景，设定一个剧情，拍摄背景，拍摄身体的某一部分，只拍眼睛，明暗对比，动静结合，拍摄情绪，尝试不同视角，利用组照等</li>
<li>建议大家平时多看电影，从中汲取营养，提高用照片讲故事的能力</li>
</ol>
<h1 id="第26课：怎么拍摄剪影类型的照片？"><a href="#第26课：怎么拍摄剪影类型的照片？" class="headerlink" title="第26课：怎么拍摄剪影类型的照片？"></a>第26课：怎么拍摄剪影类型的照片？</h1><ol>
<li>主体处于逆光，并且主体和背景有比较的高度差适合拍摄剪影</li>
<li>拍摄剪影时最好提前对焦并锁定焦点，同事按照背景的亮度调整曝光</li>
<li>明亮并且简洁无遮挡的背景适合拍摄剪影</li>
<li>拍摄剪影时需要主体的轮廓或形状要好看</li>
<li>拍摄半剪影照片时要注意控制曝光，使之兼顾主体的背景</li>
</ol>
<h1 id="第27课：旅行时如何避免“游客照”？"><a href="#第27课：旅行时如何避免“游客照”？" class="headerlink" title="第27课：旅行时如何避免“游客照”？"></a>第27课：旅行时如何避免“游客照”？</h1><ol>
<li>可以采取蹲下，改变摄影方向和地点来避开游人</li>
<li>随时改变拍摄地点和视角，避免照片单调</li>
<li>把焦点放在吃穿住行以及所见所闻等诸多方面</li>
</ol>
<h1 id="第28课：全景和夜景怎么拍？"><a href="#第28课：全景和夜景怎么拍？" class="headerlink" title="第28课：全景和夜景怎么拍？"></a>第28课：全景和夜景怎么拍？</h1><ol>
<li>全景拍摄不仅可以横着拍，也可以竖着拍，还可以玩同一画面有多个自己的创意</li>
<li>拍摄夜景需要三脚架，充电宝等辅助器材，日落前到达拍摄地做好准备，在拍摄夜景“黄金时刻”到来的前后抓紧时间连续拍摄</li>
</ol>
<h1 id="第30课：如何拍日出日落？"><a href="#第30课：如何拍日出日落？" class="headerlink" title="第30课：如何拍日出日落？"></a>第30课：如何拍日出日落？</h1><ol>
<li>拍摄日出和日落最好事先踩点，选好合适的地面景物配合天空</li>
<li>拍摄日出要“早出”，拍摄日落要“晚归”</li>
<li>拍摄日出和日落曝光要以天空为主，兼顾地面景物的层次</li>
<li>选用合适的前景来烘托气氛，利用倒影，拍摄剪影，拍摄第一缕阳光和在飞机上拍摄等，会让日出日落的照片不俗</li>
</ol>
<h1 id="第31课：手机能拍月亮么？"><a href="#第31课：手机能拍月亮么？" class="headerlink" title="第31课：手机能拍月亮么？"></a>第31课：手机能拍月亮么？</h1><ol>
<li>相比于晚上，早晨和傍晚才熟拍月亮的最佳时机</li>
<li>拍月亮时曝光要以月亮为基准，打开HDR功能</li>
<li>拍月亮时对焦要仔细，如果月亮很难对焦，可以寻找适合的参照物</li>
<li>使用手机拍月亮要寻找适当的前景，让画面更丰富</li>
</ol>
<h1 id="第32课：追随拍摄如何操作？"><a href="#第32课：追随拍摄如何操作？" class="headerlink" title="第32课：追随拍摄如何操作？"></a>第32课：追随拍摄如何操作？</h1><ol>
<li>技术要领是三同：同一方向，同一速度，同时快门</li>
<li>适合追拍的光线是逆光，侧逆光和测光。使用手机追拍需要比较暗的光线</li>
<li>学习追随拍摄要循序渐进，先从比较简单的定点追拍开始</li>
</ol>
<h1 id="第33课：怎样延时拍摄和拍摄视频？"><a href="#第33课：怎样延时拍摄和拍摄视频？" class="headerlink" title="第33课：怎样延时拍摄和拍摄视频？"></a>第33课：怎样延时拍摄和拍摄视频？</h1><ol>
<li>需要将手机架在三脚架上，光线变化比较大的时候不要锁定焦点和曝光</li>
<li>用手机拍摄视频时最重要是稳定画面，正确使用推拉摇移</li>
<li>后期可以用Vue、美拍、小影等来剪辑视频</li>
</ol>
<h1 id="第37课：照片怎么调黑白？"><a href="#第37课：照片怎么调黑白？" class="headerlink" title="第37课：照片怎么调黑白？"></a>第37课：照片怎么调黑白？</h1><p>适合调黑白的条件：</p>
<ul>
<li>阴影占大部分</li>
<li>摆脱干扰因素，如背景（颜色过于强烈）</li>
<li>主体涉及纹理，砖瓦线条</li>
<li>表达情绪</li>
</ul>
<h1 id="第40课：如何去掉照片中的路人甲？"><a href="#第40课：如何去掉照片中的路人甲？" class="headerlink" title="第40课：如何去掉照片中的路人甲？"></a>第40课：如何去掉照片中的路人甲？</h1><p>TouchRetouch抠图软件</p>
<ul>
<li>删除物体</li>
<li>快速修复</li>
<li>线条删除</li>
<li>克隆印章</li>
</ul>
<h1 id="第41课：照片如何调出虚化效果？"><a href="#第41课：照片如何调出虚化效果？" class="headerlink" title="第41课：照片如何调出虚化效果？"></a>第41课：照片如何调出虚化效果？</h1><p>AfterFocus景深处理软件，支持“镜头模糊”和“运动模糊”两种效果</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>摄影</category>
      </categories>
      <tags>
        <tag>摄影</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构</title>
    <url>/2019/06/21/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<h1 id="第二章-线性表"><a href="#第二章-线性表" class="headerlink" title="第二章 线性表"></a>第二章 线性表</h1><h2 id="线性表的顺序表示"><a href="#线性表的顺序表示" class="headerlink" title="线性表的顺序表示"></a>线性表的顺序表示</h2><h3 id="顺序表的定义"><a href="#顺序表的定义" class="headerlink" title="顺序表的定义"></a>顺序表的定义</h3><ol>
<li>静态分配</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">define</span> MaxSize 50</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    Elemtype data[MaxSize];</span><br><span class="line">    <span class="keyword">int</span> length;</span><br><span class="line">&#125;Sqlist;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>动态分配</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">define</span> InitSize 100</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    ElemType *data;</span><br><span class="line">    <span class="keyword">int</span> MaxSize,length;</span><br><span class="line">&#125;SeqList;</span><br><span class="line"></span><br><span class="line"><span class="comment">// C初始动态分配</span></span><br><span class="line">L.data = (ElemType*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(ElemType)*InitSize);</span><br><span class="line"></span><br><span class="line"><span class="comment">// C++初始动态分配</span></span><br><span class="line">L.data = <span class="keyword">new</span> ElemType[InitSize];</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h3 id="顺序表基本操作的实现"><a href="#顺序表基本操作的实现" class="headerlink" title="顺序表基本操作的实现"></a>顺序表基本操作的实现</h3><h4 id="插入操作"><a href="#插入操作" class="headerlink" title="插入操作"></a>插入操作</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">ListInsert</span><span class="params">(SqList &amp;L, <span class="keyword">int</span> i, ElemType e)</span> <span class="comment">//将元素e插入到顺序表L中的第i个位置</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i&lt;<span class="number">1</span> || i&gt;L.length+<span class="number">1</span>)    <span class="comment">//无效范围</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(L.length&gt;MaxSize)     <span class="comment">//空间已满</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j=L.length;j&gt;=i;j--)   <span class="comment">//将第i个元素及之后的元素后移</span></span><br><span class="line">        L.data[j]=L.data[j<span class="number">-1</span>];</span><br><span class="line">    L.data[i<span class="number">-1</span>]=e;     <span class="comment">//第i个位置放入e</span></span><br><span class="line">    L.length++;        <span class="comment">//线性表长度+1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="删除操作"><a href="#删除操作" class="headerlink" title="删除操作"></a>删除操作</h4><pre><code class="c">bool ListDelete(SqList &amp;L, int i, Elemtype &amp;e)&#123;
    //删除顺序表L中的第i个位置元素，使用引用变量e返回
    if(i&lt;1||i&gt;L.length)    //无效范围
        return false;
    e = L.data[i-1];      //赋值给e
    for(int j=i;j&lt;L.length;j++)   //将第i个位置后的元素前移
        L.data[j-1] = L.data[j];
    L.length--;           //线性表长度-1
    return true;
&#125;

#### 按值查找

```c
int LocateElem(SqList L, ElemType e)&#123;
    //查找第一个值等于e的元素，返回位序
    int i;
    for(i=0;i&lt;L.length;i++)
        if(L.data[i]==e)
            return i+1;   //下标为i的元素值等于e，返回其位序i+1
    return 0   //没找到
&#125;
</code></pre>
]]></content>
      <categories>
        <category>考研</category>
      </categories>
      <tags>
        <tag>考研，数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>爬虫笔记01 - 数据解析</title>
    <url>/2019/02/17/%E7%88%AC%E8%99%AB%E7%AC%94%E8%AE%B001/</url>
    <content><![CDATA[<h1 id="Xpath"><a href="#Xpath" class="headerlink" title="Xpath"></a>Xpath</h1><h2 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h2><p>使用//获取整个页面中的元素，然后写标签名，然后在写谓词进行提取。比如：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">//div[@class=&#x27;abc&#x27;]</span><br></pre></td></tr></table></figure>

<h3 id="选取节点"><a href="#选取节点" class="headerlink" title="选取节点"></a>选取节点</h3><table>
<thead>
<tr>
<th align="center">表达式</th>
<th align="center">描述</th>
<th align="center">示例</th>
<th align="center">结果</th>
</tr>
</thead>
<tbody><tr>
<td align="center">nodename</td>
<td align="center">选取此节点的所有子节点</td>
<td align="center">bookstroe</td>
<td align="center">选取bookstore下的所有子节点</td>
</tr>
<tr>
<td align="center">/</td>
<td align="center">如果是在最前面，代表从根节点选取。<br>否则选择某节点下的某个节点</td>
<td align="center">/bookstore</td>
<td align="center">选取根元素下所有的bookstore节点</td>
</tr>
<tr>
<td align="center">//</td>
<td align="center">从全局节点中选择节点，随便在哪个位置</td>
<td align="center">//book</td>
<td align="center">从全局节点中找到所有的book节点</td>
</tr>
<tr>
<td align="center">@</td>
<td align="center">选取某个节点的属性</td>
<td align="center">//book[@price]</td>
<td align="center">选择所有拥有price属性的book节点</td>
</tr>
<tr>
<td align="center">.</td>
<td align="center">当前节点</td>
<td align="center">./a</td>
<td align="center">选取当前节点下的a标签</td>
</tr>
</tbody></table>
<span id="more"></span>

<h3 id="谓语"><a href="#谓语" class="headerlink" title="谓语"></a>谓语</h3><p>谓语用来查找某个特定的节点或者包含某个指定的值的节点，被嵌在方括号中。</p>
<table>
<thead>
<tr>
<th>路径表达式</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>/bookstore/book[1]</td>
<td>选取bookstore下的第一个子元素</td>
</tr>
<tr>
<td>/bookstore/book[last()]</td>
<td>选取bookstore下最后一个book元素</td>
</tr>
<tr>
<td>bookstore/book[position()&lt;3]</td>
<td>选取bookstore下前面两个子元素</td>
</tr>
<tr>
<td>//book[@price]</td>
<td>选取拥有price属性的book元素</td>
</tr>
<tr>
<td>//book[@price=10]</td>
<td>选取所有属性price等于10的book元素</td>
</tr>
</tbody></table>
<h3 id="通配符"><a href="#通配符" class="headerlink" title="通配符"></a>通配符</h3><table>
<thead>
<tr>
<th>通配符</th>
<th>描述</th>
<th>示例</th>
<th>结果</th>
</tr>
</thead>
<tbody><tr>
<td>*</td>
<td>匹配任意节点</td>
<td>/bookstore/*</td>
<td>选取bookstore下的所有子元素</td>
</tr>
<tr>
<td>@*</td>
<td>匹配节点中的任何属性</td>
<td>//book[@*]</td>
<td>选取所有带有属性的book元素</td>
</tr>
</tbody></table>
<h3 id="选取多个路径"><a href="#选取多个路径" class="headerlink" title="选取多个路径"></a>选取多个路径</h3><p>通过在路径表达式中使用<code>|</code>运算符，可以选取若干个路径。示例如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 选取所有book元素以及book元素下所有的title元素</span></span><br><span class="line">//bookstore/book | //book/title</span><br></pre></td></tr></table></figure>

<h3 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h3><p>可以使用<code>and</code>，<code>or</code>，<code>=</code>，<code>&gt;</code>等，太多就不全列了，用到再说</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">//dl[@class=&#x27;job_detail&#x27; and @id=&#x27;job_detail&#x27;]</span><br></pre></td></tr></table></figure>

<h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><ol>
<li><code>/</code>和<code>//</code>的区别：<code>/</code>代表只获取直接子节点。<code>//</code>获取子孙节点。<code>//</code>用的多。</li>
<li><code>contains</code>：有时候某个属性中包含了多个值，可以使用<code>contains</code>函数：</li>
</ol>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">//div[contains(@class,&#x27;job_tail&#x27;)]</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>谓词的下标是从1开始的，不是0开始</li>
</ol>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>爬虫</category>
      </categories>
      <tags>
        <tag>XPath</tag>
      </tags>
  </entry>
  <entry>
    <title>爬虫笔记02 - 数据存储</title>
    <url>/2019/02/18/%E7%88%AC%E8%99%AB%E7%AC%94%E8%AE%B002/</url>
    <content><![CDATA[<h1 id="json"><a href="#json" class="headerlink" title="json"></a>json</h1><h2 id="什么是json"><a href="#什么是json" class="headerlink" title="什么是json"></a>什么是json</h2><p>JSON(JavaScript Object Notation, JS 对象标记) 是一种轻量级的数据交换格式。它基于 ECMAScript (w3c制定的js规范)的一个子集，采用完全独立于编程语言的文本格式来存储和表示数据。简洁和清晰的层次结构使得 JSON 成为理想的数据交换语言。 易于人阅读和编写，同时也易于机器解析和生成，并有效地提升网络传输效率。</p>
<span id="more"></span>

<h2 id="JSON支持数据格式"><a href="#JSON支持数据格式" class="headerlink" title="JSON支持数据格式"></a>JSON支持数据格式</h2><ol>
<li>对象（字典）。使用花括号。</li>
<li>数组（列表）。使用方括号。</li>
<li>整形、浮点型、布尔类型还有null类型。</li>
<li>字符串类型（字符串必须要用双引号，不能用单引号）。</li>
</ol>
<p>多个数据之间使用逗号分开。<br><strong>注意</strong>：json本质上就是一个字符串。</p>
<h2 id="字典和列表转JSON"><a href="#字典和列表转JSON" class="headerlink" title="字典和列表转JSON"></a>字典和列表转JSON</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line">books = [</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">&#x27;title&#x27;</span>: <span class="string">&#x27;钢铁是怎样练成的&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;price&#x27;</span>: <span class="number">9.8</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">&#x27;title&#x27;</span>: <span class="string">&#x27;红楼梦&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;price&#x27;</span>: <span class="number">9.9</span></span><br><span class="line">    &#125;</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">json_str = json.dumps(books,ensure_ascii=<span class="literal">False</span>)</span><br><span class="line"><span class="built_in">print</span>(json_str)</span><br></pre></td></tr></table></figure>

<p>因为<code>json</code>在<code>dump</code>的时候，只能存放<code>ascii</code>的字符，因此会将中文进行转义，这时候我们可以使用<code>ensure_ascii=False</code>关闭这个特性。<br>在<code>Python</code>中。只有基本数据类型才能转换成<code>JSON</code>格式的字符串。也即：<code>int</code>、<code>float</code>、<code>str</code>、<code>list</code>、<code>dict</code>、<code>tuple</code>。</p>
<h2 id="将json数据直接dump到文件中"><a href="#将json数据直接dump到文件中" class="headerlink" title="将json数据直接dump到文件中"></a>将<code>json</code>数据直接<code>dump</code>到文件中</h2><p><code>json</code>模块中除了<code>dumps</code>函数，还有一个<code>dump</code>函数，这个函数可以传入一个文件指针，直接将字符串<code>dump</code>到文件中。示例代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">books = [</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">&#x27;title&#x27;</span>: <span class="string">&#x27;钢铁是怎样练成的&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;price&#x27;</span>: <span class="number">9.8</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">&#x27;title&#x27;</span>: <span class="string">&#x27;红楼梦&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;price&#x27;</span>: <span class="number">9.9</span></span><br><span class="line">    &#125;</span><br><span class="line">]</span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;a.json&#x27;</span>,<span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> fp:</span><br><span class="line">    json.dump(books,fp)</span><br></pre></td></tr></table></figure>

<h2 id="将一个json字符串load成Python对象"><a href="#将一个json字符串load成Python对象" class="headerlink" title="将一个json字符串load成Python对象"></a>将一个json字符串load成Python对象</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 注意编码格式</span></span><br><span class="line">json_str = <span class="string">&#x27;[&#123;&quot;title&quot;: &quot;钢铁是怎样练成的&quot;, &quot;price&quot;: 9.8&#125;, &#123;&quot;title&quot;: &quot;红楼梦&quot;, &quot;price&quot;: 9.9&#125;]&#x27;</span></span><br><span class="line">books = json.loads(json_str,encoding=<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(books))   <span class="comment">#字典类型</span></span><br><span class="line"><span class="built_in">print</span>(books)</span><br></pre></td></tr></table></figure>

<h2 id="直接从文件中读取json"><a href="#直接从文件中读取json" class="headerlink" title="直接从文件中读取json"></a>直接从文件中读取json</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 注意编码格式</span></span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;a.json&#x27;</span>,<span class="string">&#x27;r&#x27;</span>,encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> fp:</span><br><span class="line">    json_str = json.load(fp)</span><br><span class="line">    <span class="built_in">print</span>(json_str)</span><br></pre></td></tr></table></figure>

<h1 id="MySQL数据库操作"><a href="#MySQL数据库操作" class="headerlink" title="MySQL数据库操作"></a>MySQL数据库操作</h1><h2 id="数据库连接"><a href="#数据库连接" class="headerlink" title="数据库连接"></a>数据库连接</h2><p>数据库连接之前。首先先确认以下工作完成，这里我们以一个<code>pymysql_test</code>数据库.以下将介绍连接<code>mysql</code>的示例代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pymysql</span><br><span class="line"></span><br><span class="line"><span class="comment"># port必须是int类型</span></span><br><span class="line">db = pymysql.connect(</span><br><span class="line">    host=<span class="string">&quot;127.0.0.1&quot;</span>,</span><br><span class="line">    user=<span class="string">&#x27;root&#x27;</span>,</span><br><span class="line">    password=<span class="string">&#x27;root&#x27;</span>,</span><br><span class="line">    database=<span class="string">&#x27;pymysql_test&#x27;</span>,</span><br><span class="line">    port=<span class="number">3306</span></span><br><span class="line">)</span><br><span class="line">cursor = db.cursor()</span><br><span class="line">cursor.execute(<span class="string">&quot;select 1&quot;</span>)</span><br><span class="line">data = cursor.fetchone()</span><br><span class="line"><span class="built_in">print</span>(data)</span><br><span class="line">db.close()</span><br></pre></td></tr></table></figure>

<h2 id="插入数据"><a href="#插入数据" class="headerlink" title="插入数据"></a>插入数据</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pymysql</span><br><span class="line"></span><br><span class="line">db = pymysql.connect(</span><br><span class="line">    host=<span class="string">&quot;127.0.0.1&quot;</span>,</span><br><span class="line">    user=<span class="string">&#x27;root&#x27;</span>,</span><br><span class="line">    password=<span class="string">&#x27;root&#x27;</span>,</span><br><span class="line">    database=<span class="string">&#x27;pymysql_test&#x27;</span>,</span><br><span class="line">    port=<span class="number">3306</span></span><br><span class="line">)</span><br><span class="line">cursor = db.cursor()</span><br><span class="line">sql = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">insert into user(</span></span><br><span class="line"><span class="string">    id,username,gender,age,password</span></span><br><span class="line"><span class="string">    )</span></span><br><span class="line"><span class="string">    values(null,&#x27;abc&#x27;,1,18,&#x27;111111&#x27;);</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">cursor.execute(sql)</span><br><span class="line">db.commit()</span><br><span class="line">db.close()</span><br></pre></td></tr></table></figure>

<p>如果在数据还不能保证的情况下，可以使用以下方式来插入数据：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">sql = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">insert into user(</span></span><br><span class="line"><span class="string">    id,username,gender,age,password</span></span><br><span class="line"><span class="string">    )</span></span><br><span class="line"><span class="string">    values(null,%s,%s,%s,%s);   # 都是%s，无论mysql表里是什么类型，pymysql处理</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">cursor.execute(sql,(<span class="string">&#x27;spider&#x27;</span>,<span class="number">1</span>,<span class="number">20</span>,<span class="string">&#x27;222222&#x27;</span>))  <span class="comment">#元组</span></span><br></pre></td></tr></table></figure>

<h2 id="查找数据"><a href="#查找数据" class="headerlink" title="查找数据"></a>查找数据</h2><p>使用<code>pymysql</code>查询数据。可以使用<code>fetch*</code>方法。</p>
<ol>
<li><code>fetchone()</code>：这个方法每次之获取一条数据。</li>
<li><code>fetchall()</code>：这个方法接收全部的返回结果。</li>
<li><code>fetchmany(size)</code>：可以获取指定条数的数据。</li>
</ol>
<p>示例代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">cursor = db.cursor()</span><br><span class="line"></span><br><span class="line">sql = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">select * from user</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">cursor.execute(sql)</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    result = cursor.fetchone()</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> result:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    <span class="built_in">print</span>(result)</span><br><span class="line">db.close()</span><br></pre></td></tr></table></figure>

<p>或者是直接使用<code>fetchall</code>，一次性可以把所有满足条件的数据都取出来：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">cursor = db.cursor()</span><br><span class="line"></span><br><span class="line">sql = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">select * from user</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">cursor.execute(sql)</span><br><span class="line">results = cursor.fetchall()</span><br><span class="line"><span class="keyword">for</span> result <span class="keyword">in</span> results:</span><br><span class="line">    <span class="built_in">print</span>(result)</span><br><span class="line">db.close()</span><br></pre></td></tr></table></figure>

<p>或者是使用<code>fetchmany</code>，指定获取多少条数据：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">cursor = db.cursor()</span><br><span class="line"></span><br><span class="line">sql = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">select * from user</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">cursor.execute(sql)</span><br><span class="line">results = cursor.fetchmany(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">for</span> result <span class="keyword">in</span> results:</span><br><span class="line">    <span class="built_in">print</span>(result)</span><br><span class="line">db.close()</span><br></pre></td></tr></table></figure>

<h2 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">cursor = db.cursor()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 一定加where条件</span></span><br><span class="line">sql = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">delete from user where id=1</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">cursor.execute(sql)</span><br><span class="line">db.commit()</span><br><span class="line">db.close()</span><br></pre></td></tr></table></figure>

<h2 id="更新数据"><a href="#更新数据" class="headerlink" title="更新数据"></a>更新数据</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">conn = pymysql.connect(host=<span class="string">&#x27;localhost&#x27;</span>,user=<span class="string">&#x27;root&#x27;</span>,password=<span class="string">&#x27;root&#x27;</span>,database=<span class="string">&#x27;pymysql_demo&#x27;</span>,port=<span class="number">3306</span>)</span><br><span class="line">cursor = conn.cursor()</span><br><span class="line"></span><br><span class="line">sql = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">update user set username=&#x27;aaa&#x27; where id=1</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">cursor.execute(sql)</span><br><span class="line"><span class="comment"># 插入、删除、更新，都需要执行commit操作</span></span><br><span class="line">conn.commit()</span><br><span class="line">conn.close()</span><br></pre></td></tr></table></figure>

<h1 id="MongoDB"><a href="#MongoDB" class="headerlink" title="MongoDB"></a>MongoDB</h1><h2 id="概念介绍"><a href="#概念介绍" class="headerlink" title="概念介绍"></a>概念介绍</h2><table>
<thead>
<tr>
<th>SQL术语/概念</th>
<th>MongoDB术语/概念</th>
<th>解释/说明</th>
</tr>
</thead>
<tbody><tr>
<td>database</td>
<td>database</td>
<td>数据库</td>
</tr>
<tr>
<td>table</td>
<td>collection</td>
<td>数据库表/集合</td>
</tr>
<tr>
<td>row</td>
<td>document</td>
<td>数据记录行/文档</td>
</tr>
<tr>
<td>column</td>
<td>field</td>
<td>数据字段/域</td>
</tr>
<tr>
<td>index</td>
<td>index</td>
<td>索引</td>
</tr>
<tr>
<td>joins</td>
<td>joins</td>
<td>表连接，MongoDB不支持</td>
</tr>
<tr>
<td>primary key</td>
<td>primary key</td>
<td>主键，MongoDB自动将_id字段设置为主键</td>
</tr>
</tbody></table>
<h2 id="MongoDB三元素"><a href="#MongoDB三元素" class="headerlink" title="MongoDB三元素"></a>MongoDB三元素</h2><p>数据库、集合、文档</p>
<ol>
<li>文档（document）：就是关系型数据库中的一行。文档是一个对象，由键值对构成，是<code>json</code>的扩展形式。</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&#123;<span class="string">&#x27;name&#x27;</span>:<span class="string">&#x27;abc&#x27;</span>, <span class="string">&#x27;gender&#x27;</span>: <span class="string">&#x27;1&#x27;</span>&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>集合（collection）：就是关系型数据库中的表。可以存储多个文档，结构可以不固定。如可以存储如下文档在一个集合中：</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&#123;<span class="string">&quot;name&quot;</span>:<span class="string">&quot;abc&quot;</span>,<span class="string">&quot;gender&quot;</span>:<span class="string">&quot;1&quot;</span>&#125;</span><br><span class="line">&#123;<span class="string">&quot;name&quot;</span>:<span class="string">&quot;xxx&quot;</span>,<span class="string">&quot;age&quot;</span>:<span class="number">18</span>&#125;</span><br><span class="line">&#123;<span class="string">&quot;title&quot;</span>:<span class="string">&quot;yyy&quot;</span>,<span class="string">&quot;price&quot;</span>:<span class="number">20.9</span>&#125;</span><br></pre></td></tr></table></figure>

<h2 id="MongoDB基本操作命令"><a href="#MongoDB基本操作命令" class="headerlink" title="MongoDB基本操作命令"></a>MongoDB基本操作命令</h2><ol>
<li>db：查看当前的数据库</li>
<li>show dbs：查看所有的数据库</li>
<li>use 数据库名：切换数据库。如果数据库不存在，则创建一个。（创建完成后需要插入数据库才算创建成功）</li>
<li>db.dropDatabase()：删除当前指向的数据库</li>
<li>db.集合名.insert(value)：添加数据到指定的集合中</li>
<li>db.集合名.find()：从指定的集合中查找数据</li>
</ol>
<h2 id="python操作MongoDB"><a href="#python操作MongoDB" class="headerlink" title="python操作MongoDB"></a>python操作MongoDB</h2><h3 id="安装pymongo"><a href="#安装pymongo" class="headerlink" title="安装pymongo"></a>安装pymongo</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pip install pymongo</span><br></pre></td></tr></table></figure>

<h3 id="连接MongoDB"><a href="#连接MongoDB" class="headerlink" title="连接MongoDB"></a>连接MongoDB</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pymongo</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取连接的对象</span></span><br><span class="line">client = pymongo.MongoClient(<span class="string">&#x27;127.0.0.1&#x27;</span>, port=<span class="number">27017</span>)</span><br><span class="line"><span class="comment"># 获取数据库</span></span><br><span class="line">db = client.zhihu</span><br><span class="line"><span class="comment"># 获取集合（表）</span></span><br><span class="line">collection = db.qa</span><br><span class="line"><span class="comment"># 插入一条数据到集合中</span></span><br><span class="line">collection.insert_one(&#123;</span><br><span class="line">    <span class="string">&quot;username&quot;</span>: <span class="string">&quot;abc&quot;</span>,</span><br><span class="line">    <span class="string">&quot;password&quot;</span>: <span class="string">&quot;hello&quot;</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><table>
<thead>
<tr>
<th>类型</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Object ID</td>
<td>文档ID</td>
</tr>
<tr>
<td>String</td>
<td>字符串，最常用，必须是有效的UTF-8</td>
</tr>
<tr>
<td>Boolean</td>
<td>存储一个布尔值，True和False</td>
</tr>
<tr>
<td>Integer</td>
<td>整数可以是32位或64位，取决于服务器</td>
</tr>
<tr>
<td>Double</td>
<td>存储浮点值</td>
</tr>
<tr>
<td>Arrays</td>
<td>数组或列表，多个值存储到一个键</td>
</tr>
<tr>
<td>Object</td>
<td>用于嵌入式的文档，即一个值为一个文档</td>
</tr>
<tr>
<td>Null</td>
<td>存储Null值</td>
</tr>
<tr>
<td>Timestamp</td>
<td>时间戳，表示从1970-1-1 到现在的总秒数</td>
</tr>
<tr>
<td>Date</td>
<td>存储当前日期或时间的UNIX时间格式</td>
</tr>
</tbody></table>
<h3 id="操作MongoDB"><a href="#操作MongoDB" class="headerlink" title="操作MongoDB"></a>操作MongoDB</h3><ol>
<li><code>insert_one</code>：加入一条文档数据到集合中</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">collection.insert_one(&#123;</span><br><span class="line">    <span class="string">&quot;username&quot;</span>:<span class="string">&quot;abc&quot;</span>,</span><br><span class="line">    <span class="string">&quot;password&quot;</span>:<span class="string">&quot;hello&quot;</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><code>insert_many</code>：加入多条文档数据到集合中</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">collection.insert_many(&#123;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">&quot;username&quot;</span>: <span class="string">&quot;abc&quot;</span>,</span><br><span class="line">        <span class="string">&quot;password&quot;</span>: <span class="string">&quot;11111&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">&quot;username&quot;</span>: <span class="string">&quot;bbbb&quot;</span>,</span><br><span class="line">        <span class="string">&quot;password&quot;</span>: <span class="string">&quot;2222&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><code>find_one</code>：查找一条文档对象</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">result = collection.find_one()</span><br><span class="line"><span class="built_in">print</span>(result)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 或者指定条件</span></span><br><span class="line">result = collection.find_one(&#123;<span class="string">&quot;username&quot;</span>: <span class="string">&quot;abc&quot;</span>&#125;)</span><br><span class="line"><span class="built_in">print</span>(result)</span><br></pre></td></tr></table></figure>

<ol start="4">
<li><code>update_one</code>：更新一条文档对象</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">collection.update_one(&#123;<span class="string">&quot;username&quot;</span>:<span class="string">&quot;abc&quot;</span>&#125;,&#123;<span class="string">&quot;$set&quot;</span>:&#123;<span class="string">&quot;username&quot;</span>:<span class="string">&quot;aaa&quot;</span>&#125;&#125;)</span><br></pre></td></tr></table></figure>

<ol start="5">
<li><code>update_many</code>：更新多条文档对象</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">collection.update_many(&#123;<span class="string">&quot;username&quot;</span>:<span class="string">&quot;abc&quot;</span>&#125;,&#123;<span class="string">&quot;$set&quot;</span>:&#123;<span class="string">&quot;username&quot;</span>:<span class="string">&quot;aaa&quot;</span>&#125;&#125;)</span><br></pre></td></tr></table></figure>

<ol start="6">
<li><code>delete_one</code>：删除一条文档对象</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">collection.delete_one(&#123;<span class="string">&quot;username&quot;</span>:<span class="string">&quot;abc&quot;</span>&#125;)</span><br></pre></td></tr></table></figure>

<ol start="7">
<li><code>delete_many</code>：删除多条文档对象</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">collection.delete_one(&#123;<span class="string">&quot;username&quot;</span>:<span class="string">&quot;abc&quot;</span>&#125;)</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>学习笔记</category>
        <category>爬虫</category>
      </categories>
      <tags>
        <tag>json</tag>
      </tags>
  </entry>
  <entry>
    <title>爬虫笔记03 - 网络请求</title>
    <url>/2019/02/19/%E7%88%AC%E8%99%AB%E7%AC%94%E8%AE%B003/</url>
    <content><![CDATA[<h1 id="urllib"><a href="#urllib" class="headerlink" title="urllib"></a>urllib</h1><p><code>urllib</code>库是<code>Python</code>中一个最基本的网络请求库。可以模拟浏览器的行为，向指定的服务器发送一个请求，并可以保存服务器返回的数据。</p>
<span id="more"></span>

<h2 id="urlopen函数"><a href="#urlopen函数" class="headerlink" title="urlopen函数"></a>urlopen函数</h2><p>在<code>Python3</code>的<code>urllib</code>库中，所有和网络请求相关的方法，都被集到<code>urllib.request</code>模块下面了，以先来看下<code>urlopen</code>函数基本的使用：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> urllib <span class="keyword">import</span> request</span><br><span class="line">resp = request.urlopen(<span class="string">&#x27;http://www.baidu.com&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(resp.read())</span><br></pre></td></tr></table></figure>

<p><code>urlopen</code>函数参数为：</p>
<ul>
<li><code>url</code>：请求的url。</li>
<li><code>data</code>：请求的data，如果设置了这个值，那么将变成post请求。</li>
</ul>
<p><code>urlopen</code>的返回值是一个<code>http.client.HTTPResponse</code>对象，这个对象是一个类文件句柄对象。有<code>read(size)</code>、<code>readline</code>、<code>readlines</code>以及<code>getcode</code>等方法。</p>
<h2 id="urlretrieve函数"><a href="#urlretrieve函数" class="headerlink" title="urlretrieve函数"></a>urlretrieve函数</h2><p>这个函数可以方便的将网页上的一个文件保存到本地。以下代码可以非常方便的将百度的首页下载到本地：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> urllib <span class="keyword">import</span> request</span><br><span class="line">request.urlretrieve(<span class="string">&#x27;http://www.baidu.com/&#x27;</span>,<span class="string">&#x27;baidu.html&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h2 id="urlencode函数"><a href="#urlencode函数" class="headerlink" title="urlencode函数"></a>urlencode函数</h2><p>用浏览器发送请求的时候，如果<code>url</code>中包含了中文或者其他特殊字符，那么浏览器会自动的给我们进行编码。而如果使用代码发送请求，那么就必须手动的进行编码，这时候就应该使用<code>urlencode</code>函数来实现。<code>urlencode</code>可以把字典数据转换为<code>URL</code>编码的数据。示例代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> urllib <span class="keyword">import</span> parse</span><br><span class="line">data = &#123;<span class="string">&#x27;name&#x27;</span>:<span class="string">&#x27;爬虫基础&#x27;</span>,<span class="string">&#x27;greet&#x27;</span>:<span class="string">&#x27;hello world&#x27;</span>,<span class="string">&#x27;age&#x27;</span>:<span class="number">100</span>&#125;</span><br><span class="line">qs = parse.urlencode(data)</span><br><span class="line"><span class="built_in">print</span>(qs)</span><br></pre></td></tr></table></figure>

<h2 id="parse-qs函数"><a href="#parse-qs函数" class="headerlink" title="parse_qs函数"></a>parse_qs函数</h2><p>可以将经过编码后的url参数进行解码。示例代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> urllib <span class="keyword">import</span> parse</span><br><span class="line">qs = <span class="string">&quot;name=%E7%88%AC%E8%99%AB%E5%9F%BA%E7%A1%80&amp;greet=hello+world&amp;age=100&quot;</span></span><br><span class="line"><span class="built_in">print</span>(parse.parse_qs(qs))</span><br></pre></td></tr></table></figure>

<h2 id="urlparse和urlsplit"><a href="#urlparse和urlsplit" class="headerlink" title="urlparse和urlsplit"></a><code>urlparse</code>和<code>urlsplit</code></h2><p>有时候拿到一个url，想要对这个url中的各个组成部分进行分割，那么这时候就可以使用<code>urlparse</code>或者是<code>urlsplit</code>来进行分割。示例代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> urllib <span class="keyword">import</span> parse</span><br><span class="line"></span><br><span class="line">url = <span class="string">&#x27;http://www.baidu.com/s?username=zhiliao&#x27;</span></span><br><span class="line"></span><br><span class="line">result = parse.urlsplit(url)</span><br><span class="line"><span class="comment"># result = parse.urlparse(url)</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;scheme:&#x27;</span>,result.scheme)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;netloc:&#x27;</span>,result.netloc)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;path:&#x27;</span>,result.path)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;query:&#x27;</span>,result.query)</span><br></pre></td></tr></table></figure>

<p><code>urlparse</code>和<code>urlsplit</code>基本上是一模一样的。唯一不一样的地方是，<code>urlparse</code>里面多了一个<code>params</code>属性，而<code>urlsplit</code>没有这个<code>params</code>属性。比如有一个url为：<code>url = &#39;http://www.baidu.com/s;hello?wd=python&amp;username=abc#1&#39;</code>，那么<code>urlparse</code>可以获取到<code>hello</code>，而<code>urlsplit</code>不可以获取到。<code>url</code>中的<code>params</code>也用得比较少。</p>
<h2 id="request-Request类"><a href="#request-Request类" class="headerlink" title="request.Request类"></a>request.Request类</h2><p>如果想要在请求的时候增加一些请求头，那么就必须使用<code>request.Request</code>类来实现。比如要增加一个<code>User-Agent</code>，示例代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> urllib <span class="keyword">import</span> request</span><br><span class="line"></span><br><span class="line">headers = &#123;</span><br><span class="line"><span class="string">&#x27;User-Agent&#x27;</span>: <span class="string">&#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/62.0.3202.94 Safari/537.36&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">req = request.Request(<span class="string">&quot;http://www.baidu.com/&quot;</span>,headers=headers)</span><br><span class="line">resp = request.urlopen(req)</span><br><span class="line"><span class="built_in">print</span>(resp.read())</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>学习笔记</category>
        <category>爬虫</category>
      </categories>
      <tags>
        <tag>urllib</tag>
      </tags>
  </entry>
  <entry>
    <title>爬虫笔记04 - 进阶</title>
    <url>/2019/02/21/%E7%88%AC%E8%99%AB%E7%AC%94%E8%AE%B004/</url>
    <content><![CDATA[<h1 id="动态网页数据抓取"><a href="#动态网页数据抓取" class="headerlink" title="动态网页数据抓取"></a>动态网页数据抓取</h1><h2 id="AJAX简介"><a href="#AJAX简介" class="headerlink" title="AJAX简介"></a>AJAX简介</h2><p><code>AJAX（Asynchronouse JavaScript And XML）</code>异步<code>JavaScript</code>和<code>XML</code>。过在后台与服务器进行少量数据交换，<code>Ajax</code> 可以使网页实现异步更新。这意味着可以在不重新加载整个网页的情况下，对网页的某部分进行更新。传统的网页（不使用<code>Ajax</code>）如果需要更新内容，必须重载整个网页页面。因为传统的在传输数据格式方面，使用的是<code>XML</code>语法。因此叫做<code>AJAX</code>，其实现在数据交互基本上都是使用<code>JSON</code>。使用<code>AJAX</code>加载的数据，即使使用了<code>JS</code>，将数据渲染到了浏览器中，在右键-&gt;查看网页源代码还是不能看到通过<code>ajax</code>加载的数据，只能看到使用这个<code>url</code>加载的<code>html</code>代码。</p>
<span id="more"></span>

<h2 id="获取ajax数据的方式"><a href="#获取ajax数据的方式" class="headerlink" title="获取ajax数据的方式"></a>获取ajax数据的方式</h2><ol>
<li>直接分析<code>ajax</code>调用的接口。然后通过代码请求这个接口。</li>
<li>使用<code>Selenium+chromedriver</code>模拟浏览器行为获取数据。</li>
</ol>
<table>
<thead>
<tr>
<th>方式</th>
<th>优点</th>
<th>缺点</th>
</tr>
</thead>
<tbody><tr>
<td>分析接口</td>
<td>直接可以请求到数据。不需要做一些解析工作。<br>代码量少，性能高</td>
<td>分析接口比较复杂，特别是一些通过js混淆的接口，<br>要有一定的js功底。容易被发现是爬虫</td>
</tr>
<tr>
<td>selenium</td>
<td>直接模拟浏览器的行为。浏览器能请求到的，<br>使用selenium也能请求到。爬虫更稳定</td>
<td>代码量多。性能低</td>
</tr>
</tbody></table>
<h2 id="Selenium-chromedriver获取动态数据"><a href="#Selenium-chromedriver获取动态数据" class="headerlink" title="Selenium+chromedriver获取动态数据"></a>Selenium+chromedriver获取动态数据</h2><p><code>Selenium</code>相当于是一个机器人。可以模拟人类在浏览器上的一些行为，自动处理浏览器上的一些行为，比如点击，填充数据，删除<code>cookie</code>等。<code>chromedriver</code>是一个驱动<code>Chrome</code>浏览器的驱动程序，使用他才可以驱动浏览器。当然针对不同的浏览器有不同的<code>driver</code>。以下列出了不同浏览器及其对应的<code>driver</code>：</p>
<ol>
<li>Chrome：<a href="https://sites.google.com/a/chromium.org/chromedriver/downloads">下载地址</a></li>
<li>Firefox：<a href="https://github.com/mozilla/geckodriver/releases">下载地址</a></li>
<li>Edge：<a href="https://developer.microsoft.com/en-us/microsoft-edge/tools/webdriver/">下载地址</a></li>
<li>Safari：<a href="https://webkit.org/blog/6900/webdriver-support-in-safari-10/">下载地址</a></li>
</ol>
<h2 id="安装Selenium和chromedriver"><a href="#安装Selenium和chromedriver" class="headerlink" title="安装Selenium和chromedriver"></a>安装Selenium和chromedriver</h2><ol>
<li>安装<code>Selenium</code>：Selenium有很多语言的版本，有java、ruby、python等。我们下载python版本的就可以了。</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pip install selenium</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>安装<code>chromedriver</code>：下载完成后，放到不需要权限的纯英文目录下就可以了。</li>
</ol>
<h2 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">from</span> lxml <span class="keyword">import</span> etree</span><br><span class="line"></span><br><span class="line"><span class="comment"># chromedriver的绝对路径</span></span><br><span class="line">driver_path = <span class="string">r&#x27;D:\ProgramApp\chromedriver\chromedriver.exe&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 初始化一个driver，并且指定chromedriver的路径</span></span><br><span class="line">driver = webdriver.Chrome(executable_path=driver_path)</span><br><span class="line"><span class="comment"># 请求网页</span></span><br><span class="line">driver.get(<span class="string">&quot;https://www.baidu.com/&quot;</span>)</span><br><span class="line"><span class="comment"># 通过page_source获取网页源代码</span></span><br><span class="line"><span class="built_in">print</span>(driver.page_source)</span><br><span class="line"></span><br><span class="line">html = etree.HTML(driver.page_source)</span><br><span class="line">html.xpath(<span class="string">&quot;&quot;</span>)</span><br></pre></td></tr></table></figure>

<ol>
<li>如果只是想要解析网页中的数据，那么推荐将网页源代码扔给<code>lxml</code>来解析。因为<code>lxml</code>底层使用的是c语言，所以解析效率会更高。</li>
<li>如果是想要对元素进行一些操作，比如给一个文本框输入值，或者是点击某个按钮，那么就必须使用<code>selenium</code>提供的查找元素的方法。</li>
</ol>
<h1 id="selenium常用操作"><a href="#selenium常用操作" class="headerlink" title="selenium常用操作"></a>selenium常用操作</h1><h2 id="关闭界面"><a href="#关闭界面" class="headerlink" title="关闭界面"></a>关闭界面</h2><ol>
<li><code>driver.close()</code>：关闭当前页面。</li>
<li><code>driver.quit()</code>：退出整个浏览器。</li>
</ol>
<h2 id="定位元素"><a href="#定位元素" class="headerlink" title="定位元素"></a>定位元素</h2><ol>
<li><code>find_element_by_id</code>：根据<code>id</code>来查找某个元素。等价于：</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">submitTag = driver.find_element_by_id(<span class="string">&#x27;su&#x27;</span>)</span><br><span class="line">submitTag1 = driver.find_element(By.ID,<span class="string">&#x27;su&#x27;</span>)</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><code>find_element_by_class_name</code>：根据类名查找元素。 等价于：</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">submitTag = driver.find_element_by_class_name(<span class="string">&#x27;su&#x27;</span>)</span><br><span class="line">submitTag1 = driver.find_element(By.CLASS_NAME,<span class="string">&#x27;su&#x27;</span>)</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><code>find_element_by_name</code>：根据<code>name</code>属性的值来查找元素。等价于：</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">submitTag = driver.find_element_by_name(<span class="string">&#x27;email&#x27;</span>)</span><br><span class="line">submitTag1 = driver.find_element(By.NAME,<span class="string">&#x27;email&#x27;</span>)</span><br></pre></td></tr></table></figure>

<ol start="4">
<li><code>find_element_by_tag_name</code>：根据标签名来查找元素。等价于：</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">submitTag = driver.find_element_by_tag_name(<span class="string">&#x27;div&#x27;</span>)</span><br><span class="line">submitTag1 = driver.find_element(By.TAG_NAME,<span class="string">&#x27;div&#x27;</span>)</span><br></pre></td></tr></table></figure>

<ol start="5">
<li><code>find_element_by_xpath</code>：根据<code>xpath</code>语法来获取元素。等价于：</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">submitTag = driver.find_element_by_xpath(<span class="string">&#x27;//div&#x27;</span>)</span><br><span class="line">submitTag1 = driver.find_element(By.XPATH,<span class="string">&#x27;//div&#x27;</span>)</span><br></pre></td></tr></table></figure>

<ol start="6">
<li><code>find_element_by_css_selector</code>：根据<code>css选择器</code>选择元素。等价于：</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">submitTag = driver.find_element_by_css_selector(<span class="string">&#x27;//div&#x27;</span>)</span><br><span class="line">submitTag1 = driver.find_element(By.CSS_SELECTOR,<span class="string">&#x27;//div&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>要注意，<code>find_element</code>是获取第一个满足条件的元素。<code>find_elements</code>是获取所有满足条件的元素。</p>
<h2 id="操作表单元素"><a href="#操作表单元素" class="headerlink" title="操作表单元素"></a>操作表单元素</h2><h3 id="操作输入框"><a href="#操作输入框" class="headerlink" title="操作输入框"></a>操作输入框</h3><p>第一步：找到这个元素。<br>第二步：使用<code>send_keys(value)</code>，将数据填充进去。示例代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">inputTag = driver.find_element_by_id(<span class="string">&#x27;kw&#x27;</span>)</span><br><span class="line">inputTag.send_keys(<span class="string">&#x27;python&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>使用<code>clear</code>方法可以清除输入框中的内容。示例代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">inputTag.clear()</span><br></pre></td></tr></table></figure>

<h3 id="操作checkbox"><a href="#操作checkbox" class="headerlink" title="操作checkbox"></a>操作checkbox</h3><p>因为要选中<code>checkbox</code>标签，在网页中是通过鼠标点击的。因此想要选中<code>checkbox</code>标签，那么先选中这个标签，然后执行<code>click</code>事件。示例代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">rememberTag = driver.find_element_by_name(<span class="string">&quot;rememberMe&quot;</span>)</span><br><span class="line">rememberTag.click()</span><br></pre></td></tr></table></figure>

<h3 id="选择select"><a href="#选择select" class="headerlink" title="选择select"></a>选择select</h3><p><code>select</code>元素不能直接点击。因为点击后还需要选中元素。这时候<code>selenium</code>就专门为<code>select</code>标签提供了一个类<code>selenium.webdriver.support.ui.Select</code>。将获取到的元素当成参数传到这个类中，创建这个对象。以后就可以使用这个对象进行选择了。示例代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium.webdriver.support.ui <span class="keyword">import</span> Select</span><br><span class="line"></span><br><span class="line"><span class="comment"># 选中这个标签，然后使用Select创建对象</span></span><br><span class="line">selectTag = Select(driver.find_element_by_name(<span class="string">&quot;jumpMenu&quot;</span>))</span><br><span class="line"><span class="comment"># 根据索引选择</span></span><br><span class="line">selectTag.select_by_index(<span class="number">1</span>)</span><br><span class="line"><span class="comment"># 根据值选择</span></span><br><span class="line">selectTag.select_by_value(<span class="string">&quot;http://www.95yueba.com&quot;</span>)</span><br><span class="line"><span class="comment"># 根据可视的文本选择</span></span><br><span class="line">selectTag.select_by_visible_text(<span class="string">&quot;95秀客户端&quot;</span>)</span><br><span class="line"><span class="comment"># 取消选中所有选项</span></span><br><span class="line">selectTag.deselect_all()</span><br></pre></td></tr></table></figure>

<h3 id="操作按钮"><a href="#操作按钮" class="headerlink" title="操作按钮"></a>操作按钮</h3><p>操作按钮有很多种方式。比如单击、右击、双击等。这里讲一个最常用的。就是点击。直接调用<code>click</code>函数就可以了。示例代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">inputTag = driver.find_element_by_id(<span class="string">&#x27;su&#x27;</span>)</span><br><span class="line">inputTag.click()</span><br></pre></td></tr></table></figure>

<h3 id="行为链"><a href="#行为链" class="headerlink" title="行为链"></a>行为链</h3><p>有时候在页面中的操作可能要有很多步，那么这时候可以使用鼠标行为链类<code>ActionChains</code>来完成。比如现在要将鼠标移动到某个元素上并执行点击事件。那么示例代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">inputTag = driver.find_element_by_id(<span class="string">&#x27;kw&#x27;</span>)</span><br><span class="line">submitTag = driver.find_element_by_id(<span class="string">&#x27;su&#x27;</span>)</span><br><span class="line"></span><br><span class="line">actions = ActionChains(driver)</span><br><span class="line">actions.move_to_element(inputTag)</span><br><span class="line">actions.send_keys_to_element(inputTag,<span class="string">&#x27;python&#x27;</span>)</span><br><span class="line">actions.move_to_element(submitTag)</span><br><span class="line">actions.click(submitTag)</span><br><span class="line">actions.perform()</span><br></pre></td></tr></table></figure>

<p>还有更多的鼠标相关的操作。</p>
<ul>
<li><code>click_and_hold(element)</code>：点击但不松开鼠标。</li>
<li><code>context_click(element)</code>：右键点击。</li>
<li><code>double_click(element)</code>：双击。</li>
</ul>
<h2 id="Cookie操作"><a href="#Cookie操作" class="headerlink" title="Cookie操作"></a>Cookie操作</h2><h3 id="获取所有的cookie"><a href="#获取所有的cookie" class="headerlink" title="获取所有的cookie"></a>获取所有的cookie</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> cookie <span class="keyword">in</span> driver.get_cookies():</span><br><span class="line">    <span class="built_in">print</span>(cookie)</span><br></pre></td></tr></table></figure>

<h3 id="根据cookie的key获取value："><a href="#根据cookie的key获取value：" class="headerlink" title="根据cookie的key获取value："></a>根据cookie的key获取value：</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">value = driver.get_cookie(key)</span><br></pre></td></tr></table></figure>

<h3 id="删除所有的cookie"><a href="#删除所有的cookie" class="headerlink" title="删除所有的cookie"></a>删除所有的cookie</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">driver.delete_all_cookies()</span><br></pre></td></tr></table></figure>

<h3 id="删除某个cookie："><a href="#删除某个cookie：" class="headerlink" title="删除某个cookie："></a>删除某个cookie：</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">driver.delete_cookie(key)</span><br></pre></td></tr></table></figure>

<h2 id="页面等待"><a href="#页面等待" class="headerlink" title="页面等待"></a>页面等待</h2><p>现在的网页越来越多采用了<code>Ajax</code>技术，这样程序便不能确定何时某个元素完全加载出来了。如果实际页面等待时间过长导致某个元素还没出来，但是你的代码直接使用了这个<code>WebElement</code>，那么就会抛出<code>NullPointer</code>的异常。为了解决这个问题。所以<code>Selenium</code>提供了两种等待方式：一种是隐式等待、一种是显式等待。</p>
<h3 id="隐式等待"><a href="#隐式等待" class="headerlink" title="隐式等待"></a>隐式等待</h3><p>调用<code>driver.implicitly_wait</code>。那么在获取不可用的元素之前，会先等待10秒中的时间。示例代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">driver = webdriver.Chrome(executable_path=driver_path)</span><br><span class="line">driver.implicitly_wait(<span class="number">10</span>)</span><br><span class="line"><span class="comment"># 请求网页</span></span><br><span class="line">driver.get(<span class="string">&quot;https://www.douban.com/&quot;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="显示等待"><a href="#显示等待" class="headerlink" title="显示等待"></a>显示等待</h3><p>显示等待是表明某个条件成立后才执行获取元素的操作。也可以在等待的时候指定一个最大的时间，如果超过这个时间那么就抛出一个异常。显示等待应该使用<code>selenium.webdriver.support.excepted_conditions</code>期望的条件和<code>selenium.webdriver.support.ui.WebDriverWait</code>来配合完成。示例代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.common.by <span class="keyword">import</span> By</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.support.ui <span class="keyword">import</span> WebDriverWait</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.support <span class="keyword">import</span> expected_conditions <span class="keyword">as</span> EC</span><br><span class="line"></span><br><span class="line">driver = webdriver.Firefox()</span><br><span class="line">driver.get(<span class="string">&quot;http://somedomain/url_that_delays_loading&quot;</span>)</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    element = WebDriverWait(driver, <span class="number">10</span>).until(</span><br><span class="line">        EC.presence_of_element_located((By.ID, <span class="string">&quot;myDynamicElement&quot;</span>))</span><br><span class="line">    )</span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    driver.quit()</span><br></pre></td></tr></table></figure>

<p>一些其他的等待条件：</p>
<ul>
<li><code>presence_of_element_located</code>：某个元素已经加载完毕了。</li>
<li><code>presence_of_all_emement_located</code>：网页中所有满足条件的元素都加载完毕了。</li>
<li><code>element_to_be_cliable</code>：某个元素是可以点击了。</li>
</ul>
<h2 id="切换页面"><a href="#切换页面" class="headerlink" title="切换页面"></a>切换页面</h2><p>有时候窗口中有很多子<code>tab</code>页面。这时候肯定是需要进行切换的。<code>selenium</code>提供了一个叫做<code>switch_to_window</code>来进行切换，具体切换到哪个页面，可以从<code>driver.window_handles</code>中找到。示例代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 打开一个新的页面</span></span><br><span class="line">self.driver.execute_script(<span class="string">&quot;window.open(&#x27;&quot;</span>+url+<span class="string">&quot;&#x27;)&quot;</span>)</span><br><span class="line"><span class="comment"># 切换到这个新的页面中</span></span><br><span class="line">self.driver.switch_to_window(self.driver.window_handles[<span class="number">1</span>])</span><br></pre></td></tr></table></figure>

<h2 id="设置代理ip"><a href="#设置代理ip" class="headerlink" title="设置代理ip"></a>设置代理ip</h2><p>有时候频繁爬取一些网页。服务器发现你是爬虫后会封掉你的ip地址。这时候我们可以更改代理ip。更改代理ip，不同的浏览器有不同的实现方式。这里以Chrome浏览器为例来讲解：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"></span><br><span class="line">options = webdriver.ChromeOptions()</span><br><span class="line">options.add_argument(<span class="string">&quot;--proxy-server=http://110.73.2.248:8123&quot;</span>)</span><br><span class="line">driver_path = <span class="string">r&quot;D:\ProgramApp\chromedriver\chromedriver.exe&quot;</span></span><br><span class="line">driver = webdriver.Chrome(executable_path=driver_path,chrome_options=options)</span><br><span class="line"></span><br><span class="line">driver.get(<span class="string">&#x27;http://httpbin.org/ip&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h2 id="WebElement元素："><a href="#WebElement元素：" class="headerlink" title="WebElement元素："></a>WebElement元素：</h2><p><code>from selenium.webdriver.remote.webelement import WebElement</code>类是每个获取出来的元素的所属类。<br>有一些常用的属性：</p>
<ul>
<li><code>get_attribute</code>：这个标签的某个属性的值。</li>
<li><code>screentshot</code>：获取当前页面的截图。这个方法只能在<code>driver</code>上使用。</li>
</ul>
<p><code>driver</code>的对象类，也是继承自<code>WebElement</code>。</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>爬虫</category>
      </categories>
      <tags>
        <tag>Selenium</tag>
      </tags>
  </entry>
  <entry>
    <title>django笔记 - 虚拟环境</title>
    <url>/2019/01/09/%E3%80%8AMySQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%E3%80%8B%E7%AC%94%E8%AE%B0/django%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="虚拟环境"><a href="#虚拟环境" class="headerlink" title="虚拟环境"></a>虚拟环境</h1><p>以下命令均在win10的cmd中执行</p>
<h2 id="virtualenv"><a href="#virtualenv" class="headerlink" title="virtualenv"></a>virtualenv</h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pip install virtualenv  <span class="comment">#virtual environment</span></span><br></pre></td></tr></table></figure>

<h3 id="创建虚拟环境"><a href="#创建虚拟环境" class="headerlink" title="创建虚拟环境"></a>创建虚拟环境</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">virtualenv abc-env   <span class="comment">#在当前目录位置，创建名为abc-env的虚拟环境</span></span><br></pre></td></tr></table></figure>

<h3 id="进入虚拟环境（Windows）"><a href="#进入虚拟环境（Windows）" class="headerlink" title="进入虚拟环境（Windows）"></a>进入虚拟环境（Windows）</h3><p>进入<code>Scripts</code>文件夹，如<code>\abc-env\Scripts</code>，然后执行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">activate</span><br></pre></td></tr></table></figure>

<h3 id="退出虚拟环境"><a href="#退出虚拟环境" class="headerlink" title="退出虚拟环境"></a>退出虚拟环境</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">deactivate</span><br></pre></td></tr></table></figure>

<h3 id="创建时指定Python解释器"><a href="#创建时指定Python解释器" class="headerlink" title="创建时指定Python解释器"></a>创建时指定<code>Python</code>解释器</h3><p>一般不用，如果装了多个，<code>-p</code>参数指定具体的<code>Python</code>解释器</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">virtualenv -p C:\Python36\python.exe [virtualenv name]</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="virtualenvwrapper"><a href="#virtualenvwrapper" class="headerlink" title="virtualenvwrapper"></a>virtualenvwrapper</h2><p>//wrapper 包装材料，包装纸</p>
<h3 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h3><p>可以直接安装这个，会自动安装virtualenv</p>
<ol>
<li>Windows：<code>pip install virtualenvwrapper-win</code></li>
<li>Linux： <code>pip install virtualenvwrapper</code></li>
</ol>
<h3 id="创建虚拟环境-1"><a href="#创建虚拟环境-1" class="headerlink" title="创建虚拟环境"></a>创建虚拟环境</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mkvirtualenv my_env   <span class="comment">#创建名为`my_env`的虚拟环境</span></span><br></pre></td></tr></table></figure>

<p>会在当前用户下创建一个Env的文件夹，将虚拟环境安装到这个目录下</p>
<h3 id="切换到某个虚拟环境"><a href="#切换到某个虚拟环境" class="headerlink" title="切换到某个虚拟环境"></a>切换到某个虚拟环境</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">workon my_env</span><br></pre></td></tr></table></figure>

<h3 id="退出当前虚拟环境"><a href="#退出当前虚拟环境" class="headerlink" title="退出当前虚拟环境"></a>退出当前虚拟环境</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">deactivate</span><br></pre></td></tr></table></figure>

<h3 id="删除虚拟环境"><a href="#删除虚拟环境" class="headerlink" title="删除虚拟环境"></a>删除虚拟环境</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rmvirtualenv my_env</span><br></pre></td></tr></table></figure>

<h3 id="列出所有虚拟环境"><a href="#列出所有虚拟环境" class="headerlink" title="列出所有虚拟环境"></a>列出所有虚拟环境</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">lsvirtualenv</span><br></pre></td></tr></table></figure>

<h3 id="进入当前虚拟环境所在的目录"><a href="#进入当前虚拟环境所在的目录" class="headerlink" title="进入当前虚拟环境所在的目录"></a>进入当前虚拟环境所在的目录</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cdvirtualenv</span><br></pre></td></tr></table></figure>

<h3 id="修改mkvirtualenv的默认路径"><a href="#修改mkvirtualenv的默认路径" class="headerlink" title="修改mkvirtualenv的默认路径"></a>修改<code>mkvirtualenv</code>的默认路径</h3><p>在<code>环境变量-&gt;系统变量</code>中，新建一个变量，变量名为<code>WORKON_HOME</code>，变量值为目标路径，我用了<code>E:\Projects\Envs</code></p>
<h3 id="创建时指定Python版本"><a href="#创建时指定Python版本" class="headerlink" title="创建时指定Python版本"></a>创建时指定Python版本</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mkvirtualenv  --python==C:\Python36\python.exe hy_env</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>学习笔记</category>
        <category>django</category>
      </categories>
      <tags>
        <tag>django</tag>
      </tags>
  </entry>
  <entry>
    <title>django笔记03 - 模板</title>
    <url>/2019/01/14/django%E7%AC%94%E8%AE%B003/</url>
    <content><![CDATA[<h1 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h1><p>模板放在根目录的<code>templates</code>文件夹下，如果找不到可能要修改<code>settings.py</code>文件，具体的之后再说</p>
<h2 id="渲染模板"><a href="#渲染模板" class="headerlink" title="渲染模板"></a>渲染模板</h2><ol>
<li><code>render_to_string</code></li>
</ol>
<p>将模板编译后，渲染成python的字符串格式，最后通过<code>HttpResponse</code>类包装成一个<code>HttpResponse</code>对象返回</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.template.loader <span class="keyword">import</span> render_to_string</span><br><span class="line"><span class="keyword">from</span> django.http <span class="keyword">import</span> HttpResponse</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span>(<span class="params">request</span>):</span></span><br><span class="line">    html = render_to_string(<span class="string">&#x27;index.html&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> HttpResponse(html)</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><code>render</code>更简单</li>
</ol>
<p>将模板渲染成字符串和包装成HttpResponse对象一部到位完成</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.shortcuts <span class="keyword">import</span> render</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span>(<span class="params">request</span>):</span></span><br><span class="line">    <span class="keyword">return</span> render(request, <span class="string">&#x27;index.html&#x27;</span>)</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h2 id="模板查找路径"><a href="#模板查找路径" class="headerlink" title="模板查找路径"></a>模板查找路径</h2><p><code>settings.py</code>文件的<code>templates</code>部分进行配置</p>
<ol>
<li><p><code>DIRS</code>列表：，在这个列表中可以存放所有的模板路径，以后在视图中使用render或者render_to_string渲染模板的时候，会在这个列表的路径中查找模板</p>
</li>
<li><p><code>APP_DIRS</code>：默认为<code>True</code>，这个设置为<code>True</code>后，会在<code>INSTALLED_APPS</code>（已安装的APP）下的<code>templates</code>文件夹中查找模板，文件夹名必须为<code>templates</code></p>
</li>
<li><p>查找顺序：优先级为，<code>DIRS</code>-&gt; 当前APP的<code>templates</code>文件夹-&gt; 其它<code>INSTALLED_APPS</code>的<code>templates</code>文件夹。比如代码render(‘list.html’)。先会在DIRS这个列表中依次查找路径下有没有这个模板，如果有，就返回。如果DIRS列表中所有的路径都没有找到，那么会先检查当前这个视图所处的app是否已经安装，如果已经安装了，那么就先在当前这个app下的templates文件夹中查找模板，如果没有找到，那么会在其他已经安装了的app中查找。如果所有路径下都没有找到，那么会抛出一个TemplateDoesNotExist的异常。</p>
</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">TEMPLATES = [</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">&#x27;BACKEND&#x27;</span>: <span class="string">&#x27;django.template.backends.django.DjangoTemplates&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;DIRS&#x27;</span>: [os.path.join(BASE_DIR, <span class="string">&quot;templates&quot;</span>)],</span><br><span class="line">        <span class="string">&#x27;APP_DIRS&#x27;</span>: <span class="literal">True</span>,</span><br><span class="line">        <span class="string">&#x27;OPTIONS&#x27;</span>: &#123;</span><br><span class="line">            <span class="string">&#x27;context_processors&#x27;</span>: [</span><br><span class="line">                <span class="string">&#x27;django.template.context_processors.debug&#x27;</span>,</span><br><span class="line">                <span class="string">&#x27;django.template.context_processors.request&#x27;</span>,</span><br><span class="line">                <span class="string">&#x27;django.contrib.auth.context_processors.auth&#x27;</span>,</span><br><span class="line">                <span class="string">&#x27;django.contrib.messages.context_processors.messages&#x27;</span>,</span><br><span class="line">            ],</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<h2 id="模板变量"><a href="#模板变量" class="headerlink" title="模板变量"></a>模板变量</h2><ol>
<li>视图中，以字典的形式传入模板</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> render(request, <span class="string">&#x27;index.html&#x27;</span>, context=context) <span class="comment">#context是字典</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>在模板中使用变量，以<code>{{ 变量 }}</code>的形式</li>
<li>访问对象的属性，通过<code>对象.属性名</code>来访问，如访问<code>person</code>对象的<code>username</code>属性，通过<code>person.username</code></li>
<li>访问字典的<code>key</code>对应的<code>value</code>，通过<code>字典.key</code>的方式访问，不能通过中括号<code>[]</code>的形式访问，不能使用字典本身的属性名作为<code>key</code>，防止自身属性被忽略，无法访问</li>
<li>列表和元组，同样使用点<code>.</code>的方式访问，不能通过中括号<code>[]</code>，<code>{{ person.0 }}</code></li>
</ol>
<h2 id="模板标签"><a href="#模板标签" class="headerlink" title="模板标签"></a>模板标签</h2><h3 id="if标签"><a href="#if标签" class="headerlink" title="if标签"></a><code>if</code>标签</h3><ol>
<li>所有的标签都是在<code>{% %}</code>之间</li>
<li><code>if</code>标签有闭合标签，<code>{% endif %}</code></li>
<li><code>if</code>标签的判断运算符，与<code>python</code>相同，<code>==、!=、&lt;、&lt;=、&gt;、&gt;=、in、not in、is、is not</code>等</li>
<li>还可以使用<code>elif</code>,<code>else</code>等标签</li>
</ol>
<h3 id="for-in-标签"><a href="#for-in-标签" class="headerlink" title="for...in...标签"></a><code>for...in...</code>标签</h3><p>类似于<code>Python</code>中的<code>for...in...</code>。可以遍历列表、元组、字符串、字典等一切可以遍历的对象。<br>没有<code>continue</code>和<code>break</code>语句</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&#123;% <span class="keyword">for</span> person <span class="keyword">in</span> persons %&#125;</span><br><span class="line">    &lt;p&gt;&#123;&#123; person.name &#125;&#125;&lt;/p&gt;</span><br><span class="line">&#123;% endfor %&#125;</span><br></pre></td></tr></table></figure>

<p>如果想要反向遍历，那么在遍历的时候就加上一个<code>reversed</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&#123;% <span class="keyword">for</span> person <span class="keyword">in</span> persons <span class="built_in">reversed</span> %&#125;</span><br><span class="line">    &lt;p&gt;&#123;&#123; person.name &#125;&#125;&lt;/p&gt;</span><br><span class="line">&#123;% endfor %&#125;</span><br></pre></td></tr></table></figure>

<p>遍历字典的时候，需要使用<code>items</code>、<code>keys</code>和<code>values</code>等方法。在DTL中，执行一个方法不能使用圆括号的形式</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&#123;% <span class="keyword">for</span> key,value <span class="keyword">in</span> person.items %&#125;</span><br><span class="line">    &lt;p&gt;key：&#123;&#123; key &#125;&#125;&lt;/p&gt;</span><br><span class="line">    &lt;p&gt;value：&#123;&#123; value &#125;&#125;&lt;/p&gt;</span><br><span class="line">&#123;% endfor %&#125;</span><br></pre></td></tr></table></figure>

<p>在<code>for</code>循环中，DTL提供了一些变量可供使用。这些变量如下：</p>
<ul>
<li><code>forloop.counter</code>：当前循环的下标。以1作为起始值。</li>
<li><code>forloop.counter0</code>：当前循环的下标。以0作为起始值。</li>
<li><code>forloop.revcounter</code>：当前循环的反向下标值。比如列表有5个元素，那么第一次遍历这个属性是等于5，第二次是4，以此类推。并且是以1作为最后一个元素的下标。</li>
<li><code>forloop.revcounter0</code>：类似于<code>forloop.revcounter</code>。不同的是最后一个元素的下标是从0开始。</li>
<li><code>forloop.first</code>：是否是第一次遍历。</li>
<li><code>forloop.last</code>：是否是最后一次遍历。</li>
<li><code>forloop.parentloop</code>：如果有多个循环嵌套，那么这个属性代表的是上一级的for循环。</li>
</ul>
<h4 id="for…in…empty标签"><a href="#for…in…empty标签" class="headerlink" title="for…in…empty标签"></a>for…in…empty标签</h4><p>这个标签使用跟<code>for...in...</code>是一样的，只不过是在遍历的对象如果没有元素的情况下，会执行empty中的内容</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&#123;% <span class="keyword">for</span> person <span class="keyword">in</span> persons %&#125;</span><br><span class="line">    &lt;li&gt;&#123;&#123; person &#125;&#125;&lt;/li&gt;</span><br><span class="line">&#123;% empty %&#125;</span><br><span class="line">    暂时还没有任何人</span><br><span class="line">&#123;% endfor %&#125;</span><br></pre></td></tr></table></figure>

<h3 id="with标签"><a href="#with标签" class="headerlink" title="with标签"></a>with标签</h3><ol>
<li>在模板中，通过<code>with</code>语句来定义变量</li>
<li><code>with</code>语句有两种使用方式，一种是<code>with xx=xxx</code>的形式（<code>=</code>左右没有空格），第二种是<code>with xxx as xx</code>的形式</li>
<li>定义的变量只能在with语句块中使用，在<code>with</code>语句块外面取不到这个变量</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&#123;% <span class="keyword">with</span> person<span class="number">.0</span>  <span class="keyword">as</span> zs %&#125;</span><br><span class="line">    &lt;p&gt;&#123;&#123; zs &#125;&#125;&lt;/p&gt;</span><br><span class="line">    &lt;p&gt;&#123;&#123; zs &#125;&#125;&lt;/p&gt;</span><br><span class="line">    &lt;p&gt;&#123;&#123; zs &#125;&#125;&lt;/p&gt;</span><br><span class="line">&#123;% endwith %&#125;</span><br></pre></td></tr></table></figure>

<h3 id="url标签"><a href="#url标签" class="headerlink" title="url标签"></a>url标签</h3><p>在模版中，我们经常要写一些url，比如某个a标签中需要定义href属性。通过硬编码的方式直接将这个url写死的话，对于以后项目维护不方便。因此建议使用这种反转的方式来实现，类似于django中的reverse一样</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;a href=&quot;&#123;% url &#x27;book:list&#x27; %&#125;&quot;&gt;图书列表页面&lt;/a&gt;  #book可能是app名，或命名空间的名，有待验证。一般直接写name就好</span><br></pre></td></tr></table></figure>

<p>如果<code>url</code>反转的时候需要传递参数，那么可以在后面传递。但是参数分位置参数和关键字参数。位置参数和关键字参数不能同时使用</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="comment"># path部分</span></span><br><span class="line">path(<span class="string">&#x27;detail/&lt;book_id&gt;/&#x27;</span>,views.book_detail,name=<span class="string">&#x27;detail&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># url反转，使用位置参数</span></span><br><span class="line">&lt;a href=&quot;&#123;% url &#x27;book:detail&#x27; 1 %&#125;&quot;&gt;图书详情页面&lt;/a&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># url反转，使用关键字参数</span></span><br><span class="line">&lt;a href=&quot;&#123;% url &#x27;book:detail&#x27; book_id=1 %&#125;&quot;&gt;图书详情页面&lt;/a&gt;</span><br></pre></td></tr></table></figure>

<p>如果想要在使用<code>url</code>标签反转的时候要传递查询字符串的参数，那么必须要手动在在后面添加</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;a href=&quot;&#123;% url &#x27;book:detail&#x27; book_id=1 %&#125;?page=1&quot;&gt;图书详情页面&lt;/a&gt;</span><br></pre></td></tr></table></figure>

<p>如果需要传递多个参数，那么通过空格的方式进行分隔</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;a href=&quot;&#123;% url &#x27;book:detail&#x27; book_id=1 page=2 %&#125;&quot;&gt;图书详情页面&lt;/a&gt;</span><br></pre></td></tr></table></figure>

<h3 id="autosecape标签"><a href="#autosecape标签" class="headerlink" title="autosecape标签"></a>autosecape标签</h3><ol>
<li>模板中默认开启自动转义。自动转义是可以将一些特殊的字符,转义成html语法能识别的字符，比如<code>&lt;</code>会被转义成<code>&amp;lt</code>，而<code>&gt;</code>会被自动转义成<code>&amp;gt</code>。</li>
<li>如果变量确实是可信任的，可以使用<code>autoescape</code>标签来关掉自动转义</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&#123;% autoescape off %&#125;</span><br><span class="line">    &#123;% info %&#125;</span><br><span class="line">&#123;%  endautoescape %&#125;</span><br></pre></td></tr></table></figure>

<h3 id="verbatim标签："><a href="#verbatim标签：" class="headerlink" title="verbatim标签："></a>verbatim标签：</h3><p>默认在DTL模板中是会去解析那些特殊字符的。比如<code>{%</code>和<code>%}</code>以及`{{`等。如果你在某个代码片段中不想使用DTL的解析引擎。那么你可以把这个代码片段放在`verbatim`标签中

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&#123;% verbatim %&#125;</span><br><span class="line">    &#123;&#123;<span class="keyword">if</span> dying&#125;&#125;Still alive.&#123;&#123;/<span class="keyword">if</span>&#125;&#125;</span><br><span class="line">&#123;% endverbatim %&#125;</span><br></pre></td></tr></table></figure>

## 模板过滤器

在模版中，有时候需要对一些数据进行处理以后才能使用。一般在Python中我们是通过函数的形式来完成的。DTL中，不支持函数的调用形式'()'，需要通过过滤器来实现的，而过滤器其实就是一个函数，可以对需要的参数进行处理，并且还可以额外接受一个参数（即最多有两个参数）。过滤器使用的是`|`来使用。

### add过滤器

将传进来的参数添加到原来的值上面。这个过滤器会尝试将值和参数转换成整形然后进行相加。如果转换成整形过程中失败了，那么会将值和参数进行拼接。如果是字符串，那么会拼接成字符串，如果是列表，那么会拼接成一个列表。

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&#123;&#123; value|add:<span class="string">&quot;2&quot;</span> &#125;&#125;</span><br></pre></td></tr></table></figure>

如果`value`是等于4，那么结果将是6。如果`value`是等于一个普通的字符串，比如`abc`，那么结果将是`abc2`。`add`过滤器的源代码如下：

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">value, arg</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;Add the arg to the value.&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">int</span>(value) + <span class="built_in">int</span>(arg)</span><br><span class="line">    <span class="keyword">except</span> (ValueError, TypeError):</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">return</span> value + arg</span><br><span class="line">        <span class="keyword">except</span> Exception:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>

### cut过滤器

移除值中所有指定的字符串。类似于`python`中的`replace(args,"")`

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&#123;&#123; value|cut:<span class="string">&quot; &quot;</span> &#125;&#125;</span><br></pre></td></tr></table></figure>

以上示例将会移除value中所有的空格字符。cut过滤器的源代码如下：

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cut</span>(<span class="params">value, arg</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;Remove all values of arg from the given string.&quot;&quot;&quot;</span></span><br><span class="line">    safe = <span class="built_in">isinstance</span>(value, SafeData)</span><br><span class="line">    value = value.replace(arg, <span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> safe <span class="keyword">and</span> arg != <span class="string">&#x27;;&#x27;</span>:</span><br><span class="line">        <span class="keyword">return</span> mark_safe(value)</span><br><span class="line">    <span class="keyword">return</span> value</span><br></pre></td></tr></table></figure>

### date过滤器

将一个日期按照指定的格式，格式化成字符串

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 数据</span></span><br><span class="line">context = &#123;</span><br><span class="line">    <span class="string">&quot;birthday&quot;</span>: datetime.now()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 模版</span></span><br><span class="line">&#123;&#123; birthday|date:<span class="string">&quot;Y/m/d&quot;</span> &#125;&#125;</span><br></pre></td></tr></table></figure>

那么将会输出2018/02/01。其中`Y`代表的是四位数字的年份，`m`代表的是两位数字的月份，`d`代表的是两位数字的日

| 格式字符 | 描述 | 示例 |
| :------: | :------: | :------: |
| Y | 四位数字的年份 | 2018 |
| m | 两位数字的月份 | 01-12 |
| n | 月份，1-9前面没有0前缀 | 1-12 |
| d | 两位数字的天 | 01-31 |
| j | 天，但是1-9前面没有0前缀 | 1-31 |
| g | 小时，12小时格式的，1-9前面没有0前缀 | 1-12 |
| h | 小时，12小时格式的，1-9前面有0前缀 | 01-12 |
| G | 小时，24小时格式的，1-9前面没有0前缀 | 1-23 |
| H | 小时，24小时格式的，1-9前面有0前缀 | 01-23 |
| i | 分钟，1-9前面有0前缀 | 00-59 |
| s | 秒，1-9前面有0前缀 | 00-59 |

### default过滤器

如果值被评估为False。比如`[]`，`""`，`None`，`{}`等这些在`if`判断中为`False`的值，都会使用`default`过滤器提供的默认值。示例代码如下：

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&#123;&#123; value|default:<span class="string">&quot;nothing&quot;</span> &#125;&#125;</span><br></pre></td></tr></table></figure>

如果`value`是等于一个空的字符串。比如`""`，那么以上代码将会输出`nothing`

### default_if_none

如果值是`None`，那么将会使用`default_if_none`提供的默认值。这个和`default`有区别，`default`是所有被评估为`False`的都会使用默认值。而`default_if_none`则只有这个值是等于`None`的时候才会使用默认值。示例代码如下：

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&#123;&#123; value|default_if_none:<span class="string">&quot;nothing&quot;</span> &#125;&#125;</span><br></pre></td></tr></table></figure>

如果`value`是等于`""`即空字符串，那么以上会输出空字符串。如果`value`是一个`None`值，以上代码才会输出`nothing`

### first

返回列表/元组/字符串中的第一个元素

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&#123;&#123; value|first &#125;&#125;</span><br></pre></td></tr></table></figure>

如果`value`是等于`['a','b','c']`，那么输出将会是`a`

### last

返回列表/元组/字符串中的最后一个元素

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&#123;&#123; value|last &#125;&#125;</span><br></pre></td></tr></table></figure>

如果`value`是等于`['a','b','c']`，那么输出将会是`c`

### floatformat

使用四舍五入的方式格式化一个浮点类型。如果这个过滤器没有传递任何参数。那么只会在小数点后保留一个小数，如果小数后面全是0，那么只会保留整数。当然也可以传递一个参数，标识具体要保留几个小数。

1. 没有传递参数

| value | 模版代码 | 输出 |
| --- | --- | --- |
| 34.23234 | {{ value\|floatformat }} | 34.2 |<br>| 34.000 | {{ value\|floatformat }} | 34 |<br>| 34.260 | {{ value\|floatformat }} | 34.3 |</p>
<ol start="2">
<li>传递参数</li>
</ol>
<table>
<thead>
<tr>
<th>value</th>
<th>模版代码</th>
<th>输出</th>
</tr>
</thead>
<tbody><tr>
<td>34.23234</td>
<td>{{value\|floatformat:3}}</td>
<td>34.232</td>
</tr>
<tr>
<td>34.0000</td>
<td>{{value\|floatformat:3}}</td>
<td>34.000</td>
</tr>
<tr>
<td>34.26000</td>
<td>{{value\|floatformat:3}}</td>
<td>34.260</td>
</tr>
</tbody></table>
<h3 id="join"><a href="#join" class="headerlink" title="join"></a>join</h3><p>类似与<code>Python</code>中的<code>join</code>，将列表/元组/字符串用指定的字符进行拼接。示例代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&#123;&#123; value|join:<span class="string">&quot;/&quot;</span> &#125;&#125;</span><br></pre></td></tr></table></figure>

<p>如果<code>value</code>是等于<code>[&#39;a&#39;,&#39;b&#39;,&#39;c&#39;]</code>，那么以上代码将输出<code>a/b/c</code>。</p>
<h3 id="length"><a href="#length" class="headerlink" title="length"></a>length</h3><p>获取一个列表/元组/字符串/字典的长度。示例代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&#123;&#123; value|length &#125;&#125;</span><br></pre></td></tr></table></figure>

<p>如果<code>value</code>是等于<code>[&#39;a&#39;,&#39;b&#39;,&#39;c&#39;]</code>，那么以上代码将输出<code>3</code>。如果<code>value</code>为<code>None</code>，那么以上将返回<code>0</code>。</p>
<h3 id="lower"><a href="#lower" class="headerlink" title="lower"></a>lower</h3><p>将值中所有的字符全部转换成小写。示例代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&#123;&#123; value|lower &#125;&#125;</span><br></pre></td></tr></table></figure>

<p>如果value是等于Hello World。那么以上代码将输出hello world。</p>
<h3 id="upper"><a href="#upper" class="headerlink" title="upper"></a>upper</h3><p>类似于<code>lower</code>，只不过是将指定的字符串全部转换成大写。</p>
<h3 id="random"><a href="#random" class="headerlink" title="random"></a>random</h3><p>在被给的列表/字符串/元组中随机的选择一个值。示例代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&#123;&#123; value|random &#125;&#125;</span><br></pre></td></tr></table></figure>

<p>如果<code>value</code>是等于<code>[&#39;a&#39;,&#39;b&#39;,&#39;c&#39;]</code>，那么以上代码会在列表中随机选择一个。</p>
<h3 id="safe"><a href="#safe" class="headerlink" title="safe"></a>safe</h3><p>标记一个字符串是安全的。也即会关掉这个字符串的自动转义。示例代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&#123;&#123;value|safe&#125;&#125;</span><br></pre></td></tr></table></figure>

<p>如果value是一个不包含任何特殊字符的字符串，比如<code>&lt;a&gt;</code>这种，那么以上代码就会把字符串正常的输入。如果<code>value</code>是一串html代码，那么以上代码将会把这个html代码渲染到浏览器中。</p>
<h3 id="slice"><a href="#slice" class="headerlink" title="slice"></a>slice</h3><p>类似于Python中的切片操作。示例代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&#123;&#123; some_list|<span class="built_in">slice</span>:<span class="string">&quot;2:&quot;</span> &#125;&#125;</span><br></pre></td></tr></table></figure>

<p>以上代码将会给<code>some_list</code>从<code>2</code>开始做切片操作。</p>
<h3 id="stringtags"><a href="#stringtags" class="headerlink" title="stringtags"></a>stringtags</h3><p>删除字符串中所有的<code>html</code>标签。示例代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&#123;&#123; value|striptags &#125;&#125;</span><br></pre></td></tr></table></figure>

<p>如果<code>value</code>是<code>&lt;strong&gt;hello world&lt;/strong&gt;</code>，那么以上代码将会输出<code>hello world</code>。</p>
<h3 id="truncatechars"><a href="#truncatechars" class="headerlink" title="truncatechars"></a>truncatechars</h3><p>如果给定的字符串长度超过了过滤器指定的长度。那么就会进行切割，并且会拼接三个点来作为省略号。示例代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&#123;&#123; value|truncatechars:<span class="number">5</span> &#125;&#125;</span><br></pre></td></tr></table></figure>

<p>如果<code>value</code>是等于<code>北京欢迎您~</code>，那么输出的结果是<code>北京...</code>。可能你会想，为什么不会<code>北京欢迎您...</code>呢。因为三个点也占了三个字符，所以<code>北京</code>+三个点的字符长度就是5。</p>
<h3 id="truncatechars-html"><a href="#truncatechars-html" class="headerlink" title="truncatechars_html"></a>truncatechars_html</h3><p>类似于<code>truncatechars</code>，只不过是不会切割<code>html</code>标签。示例代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&#123;&#123; value|truncatechars_html:<span class="number">5</span> &#125;&#125;</span><br></pre></td></tr></table></figure>

<p>如果<code>value</code>是等于<code>&lt;p&gt;北京欢迎您~&lt;/p&gt;</code>，那么输出将是<code>&lt;p&gt;北京...&lt;/p&gt;</code></p>
<h2 id="自定义过滤器"><a href="#自定义过滤器" class="headerlink" title="自定义过滤器"></a>自定义过滤器</h2><ol>
<li>首先在某个app中，创建一个python包，名为<code>templatetags</code>，必须是这个名，不然找不到。</li>
<li>在<code>templatetags</code>包下面，创建一个python文件来存储过滤器</li>
<li>自定义的过滤器（也就是函数），这个函数的第一个参数永远是被过滤的那个值，还可以再定义另一个参数，过滤器最多只有2个参数</li>
<li>写完过滤器（函数）后，要使用<code>django.template.Library.filter</code>进行注册</li>
<li>将过滤器所在的app添加到<code>settings.py</code>的<code>INSTALLED_APPS</code>列表中，不然Django也找不到这个过滤器</li>
<li>在模板中使用<code>load</code>标签加载过滤器所在的python文件，就可以用了</li>
<li><code>django.template.Library.filter</code>还可以当做装饰器来使用，如果<code>filter</code>函数没有传递参数，默认使用函数名字作为过滤器名字，也可以传递<code>name</code>参数作为过滤器名字</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 某app的templatetags文件夹下的my_fliter.py文件</span></span><br><span class="line"><span class="keyword">from</span> django <span class="keyword">import</span> template</span><br><span class="line"></span><br><span class="line">register = template.Library()</span><br><span class="line"></span><br><span class="line"><span class="meta">@register.filter(<span class="params"><span class="string">&#x27;my_greet&#x27;</span></span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">greet</span>(<span class="params">value, word</span>):</span></span><br><span class="line">    <span class="keyword">return</span> value + word</span><br><span class="line"></span><br><span class="line"><span class="comment">#register.filter(&#x27;greet&#x27;, greet)</span></span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 模板文件 --&gt;</span></span><br><span class="line">&#123;% load my_fliter %&#125;</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    &#123;&#123; value|greet:&#x27; 你好&#x27; &#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="模板结构优化"><a href="#模板结构优化" class="headerlink" title="模板结构优化"></a>模板结构优化</h2><h3 id="include标签"><a href="#include标签" class="headerlink" title="include标签"></a>include标签</h3><ol>
<li>重复使用的模板代码，可以单独抽取出来，用到的地方使用<code>include</code>调用</li>
<li><code>include</code>的模板，可以直接使用当前模板传递进来的变量。也可以使用<code>with xx=xxx</code>传递参数</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&#123;% include <span class="string">&#x27;header.html&#x27;</span> <span class="keyword">with</span> username=<span class="string">&#x27;John&#x27;</span>&#125;</span><br></pre></td></tr></table></figure>

<h3 id="模板继承"><a href="#模板继承" class="headerlink" title="模板继承"></a>模板继承</h3><p>在前端页面开发中。有些代码是需要重复使用的。这种情况可以使用include标签来实现。也可以使用另外一个比较强大的方式来实现，那就是模版继承。模版继承类似于Python中的类，在父类中可以先定义好一些变量和方法，然后在子类中实现。模版继承也可以在父模版中先定义好一些子模版需要用到的代码，然后子模版直接继承就可以了。并且因为子模版肯定有自己的不同代码，因此可以在父模版中定义一个block接口，然后子模版再去实现。以下是父模版的代码：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">&#123;% load static %&#125;</span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;&#123;% static &#x27;style.css&#x27; %&#125;&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>&#123;% block title %&#125;我的站点&#123;% endblock %&#125;<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;sidebar&quot;</span>&gt;</span></span><br><span class="line">        &#123;% block sidebar %&#125;</span><br><span class="line">        <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;/&quot;</span>&gt;</span>首页<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;/blog/&quot;</span>&gt;</span>博客<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">        &#123;% endblock %&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;content&quot;</span>&gt;</span></span><br><span class="line">        &#123;% block content %&#125;&#123;% endblock %&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>这个模版，我们取名叫做base.html，定义好一个简单的html骨架，然后定义好两个block接口，让子模版来根据具体需求来实现。子模板然后通过extends标签来实现，示例代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&#123;% extends <span class="string">&quot;base.html&quot;</span> %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% block title %&#125;博客列表&#123;% endblock %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% block content %&#125;</span><br><span class="line">    &#123;% <span class="keyword">for</span> entry <span class="keyword">in</span> blog_entries %&#125;</span><br><span class="line">        &lt;h2&gt;&#123;&#123; entry.title &#125;&#125;&lt;/h2&gt;</span><br><span class="line">        &lt;p&gt;&#123;&#123; entry.body &#125;&#125;&lt;/p&gt;</span><br><span class="line">    &#123;% endfor %&#125;</span><br><span class="line">&#123;% endblock %&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意</strong>：</p>
<ul>
<li><code>extends</code>标签必须放在模版的第一行。</li>
<li>子模板中的代码必须放在<code>block</code>中，否则将不会被渲染。</li>
</ul>
<p><code>block</code>默认会覆盖父模板的内容，如果在某个<code>block</code>中需要使用父模版的内容，那么可以使用<code>{{block.super}}</code>来继承。比如上例，<code>{%block title%}</code>，如果想要使用父模版的title，那么可以在子模版的<code>title block</code>中使用<code>{{ block.super }}</code>来实现。</p>
<p>在定义<code>block</code>的时候，除了在<code>block</code>开始的地方定义这个<code>block</code>的名字，还可以在<code>block</code>结束的时候定义名字。比如<code>{% block title %}{% endblock title %}</code>。这在大型模版中显得尤其有用，能让你快速的看到<code>block</code>包含在哪里。</p>
<h2 id="加载静态文件"><a href="#加载静态文件" class="headerlink" title="加载静态文件"></a>加载静态文件</h2><p>在一个网页中，不仅仅只有一个<code>html</code>骨架，还需要<code>css</code>样式文件，<code>js</code>执行文件以及一些图片等。因此在<code>DTL</code>中加载静态文件是一个必须要解决的问题。在DTL中，使用<code>static</code>标签来加载静态文件。要使用<code>static</code>标签，首先需要<code>{% load static %}</code>。加载静态文件的步骤如下：</p>
<ol>
<li>首先确保<code>django.contrib.staticfiles</code>已经添加到<code>settings.INSTALLED_APPS</code>中。（默认有）</li>
<li>确保在<code>settings.py</code>中设置了<code>STATIC_URL</code>。（默认有）</li>
<li>在已经安装了的<code>app</code>下创建一个文件夹叫做<code>static</code>，然后再在这个<code>static</code>文件夹下创建一个当前<code>app</code>的名字的文件夹，再把静态文件放到这个文件夹下。例如你的<code>app</code>叫做<code>book</code>，有一个静态文件叫做<code>zhiliao.jpg</code>，那么路径为<code>book/static/book/zhiliao.jpg</code>。创建<code>app</code>同名文件夹的目的是，避免多个<code>app</code>的静态文件名相同，调用时发生混淆。</li>
<li>如果有一些静态文件是不和任何<code>app</code>挂钩的。那么可以在<code>settings.py</code>中添加<code>STATICFILES_DIRS</code>，以后DTL就会在这个列表的路径中查找静态文件。比如可以设置为</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#根目录下，与templates同级</span></span><br><span class="line">STATICFILES_DIRS = [</span><br><span class="line">    os.path.join(BASE_DIR,<span class="string">&quot;static&quot;</span>)</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>在模版中使用<code>load</code>标签加载<code>static</code>标签。比如要加载在项目的<code>static</code>文件夹下的<code>style.css</code>的文件。那么示例代码如下：</li>
</ol>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">&#123;% load static %&#125;</span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;&#123;% static &#x27;style.css&#x27; %&#125;&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ol start="6">
<li><p>如果不想每次在模版中加载静态文件都使用<code>load</code>加载<code>static</code>标签，那么可以在<code>settings.py</code>中的<code>TEMPLATES/OPTIONS</code>添加<code>&#39;builtins&#39;:[&#39;django.templatetags.static&#39;]</code>，这样以后在模版中就可以直接使用<code>static</code>标签，而不用手动的<code>load</code>了。</p>
</li>
<li><p>如果没有在<code>settings.INSTALLED_APPS</code>中添加<code>django.contrib.staticfiles</code>。那么我们就需要手动的将请求静态文件的<code>url</code>与静态文件的路径进行映射了。很少用到。示例代码如下：</p>
</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.conf <span class="keyword">import</span> settings</span><br><span class="line"><span class="keyword">from</span> django.conf.urls.static <span class="keyword">import</span> static</span><br><span class="line"></span><br><span class="line">urlpatterns = [</span><br><span class="line">    <span class="comment"># 其他的url映射</span></span><br><span class="line">] + static(settings.STATIC_URL, document_root=settings.STATIC_ROOT)</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>学习笔记</category>
        <category>django</category>
      </categories>
      <tags>
        <tag>django</tag>
      </tags>
  </entry>
  <entry>
    <title>爬虫笔记 - scrapy</title>
    <url>/2019/02/17/%E7%88%AC%E8%99%AB%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="安装scrapy框架"><a href="#安装scrapy框架" class="headerlink" title="安装scrapy框架"></a>安装<code>scrapy</code>框架</h1><ol>
<li>安装<code>scrapy</code>：<code>pip install scrapy</code></li>
<li>windows下，还需要安装<code>pypiwin32</code>，防止报错。<code>pip install scrapy</code>。报<code>Visual C++ 14.0 is required</code>错误的话，安装<code>Visual C++ Build Tools</code>，<a href="https://blogs.msdn.microsoft.com/pythonengineering/2016/04/11/unable-to-find-vcvarsall-bat/">Visual C++ Build Tools 2015下载地址</a>，下载链接在网页的中间位置</li>
</ol>
<h1 id="创建项目和爬虫"><a href="#创建项目和爬虫" class="headerlink" title="创建项目和爬虫"></a>创建项目和爬虫</h1><ol>
<li>创建项目：<code>scapy startproject [项目名称]</code></li>
<li>创建爬虫：命令行下，进入项目所在的路径，执行命令<code>scapy genspider [爬虫名字] [爬取的域名]</code>。注意：爬虫的名字不能和项目名字一样。</li>
</ol>
<span id="more"></span>

<h1 id="项目目录结构"><a href="#项目目录结构" class="headerlink" title="项目目录结构"></a>项目目录结构</h1><ol>
<li><code>items.py</code>：用来存放爬虫爬取下来数据的模型。</li>
<li><code>middlewares.py</code>：用来存放各种中间件的文件。</li>
<li><code>pipelines.py</code>：用来将items的模型存储到本地磁盘中。</li>
<li><code>settings.py</code>：本爬虫的一些配置信息（比如请求头、多久发送一次请求、ip代理池等）。</li>
<li><code>scrapy.cfg</code>：项目的配置文件。</li>
<li><code>spiders包</code>：以后所有的爬虫，都是存放到这个里面。</li>
</ol>
<h1 id="修改settings-py代码"><a href="#修改settings-py代码" class="headerlink" title="修改settings.py代码"></a>修改<code>settings.py</code>代码</h1><p>在做一个爬虫之前，一定要记得修改<code>setttings.py</code>中的设置。两个地方是强烈建议设置的。</p>
<ol>
<li><code>ROBOTSTXT_OBEY</code>设置为<code>False</code>。默认是<code>True</code>。即遵守机器协议，那么在爬虫的时候，<code>scrapy</code>首先去找<code>robots.txt</code>文件，如果没有找到。则直接停止爬取。</li>
<li><code>DEFAULT_REQUEST_HEADERS</code>添加<code>User-Agent</code>。这个也是告诉服务器，我这个请求是一个正常的请求，不是一个爬虫。</li>
<li>如果要激活<code>pipeline</code>，应该在<code>settings.py</code>中，设置<code>ITEM_PIPELINES</code>。</li>
<li>设置延时时间，<code>DOWNLOAD_DELAY = 1</code></li>
</ol>
<h1 id="运行scrapy项目"><a href="#运行scrapy项目" class="headerlink" title="运行scrapy项目"></a>运行scrapy项目</h1><p>运行<code>scrapy</code>项目。需要在终端，进入项目所在的路径，然后<code>scrapy crawl [爬虫名字]</code>即可运行指定的爬虫。如果不想每次都在命令行中运行，那么可以把这个命令写在一个文件中。以后就在<code>pycharm</code>中执行运行这个文件就可以了。比如现在新创建一个文件叫做<code>start.py</code>，然后在这个文件中填入以下代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> scrapy <span class="keyword">import</span> cmdline</span><br><span class="line"></span><br><span class="line">cmdline.execute(<span class="string">&quot;scrapy crawl qsbk&quot;</span>.split())</span><br></pre></td></tr></table></figure>

<h1 id="糗事百科Scrapy爬虫笔记"><a href="#糗事百科Scrapy爬虫笔记" class="headerlink" title="糗事百科Scrapy爬虫笔记"></a>糗事百科Scrapy爬虫笔记</h1><ol>
<li><code>response</code>是一个<code>scrapy.http.response.html.HtmlResponse</code>对象。可以执行<code>xpath</code>和<code>css</code>语法提取数据。</li>
<li>提取出来的数据，是一个<code>Selector</code>或者是一个<code>SelectorList</code>对象。如果想要获取其中的字符串。使用<code>getall</code>或者<code>get</code>方法。</li>
<li><code>getall</code>方法：获取<code>Selector</code>中的所有文本。返回的是一个列表。</li>
<li><code>get</code>方法：获取的是<code>Selector</code>中的第一个文本。返回的是一个<code>str</code>类型。</li>
<li>如果数据解析回来，要传给<code>pipeline</code>处理。那么可以使用<code>yield</code>来返回。或者是收集所有的<code>item</code>。最后统一使用return返回。</li>
<li><code>item</code>：建议在<code>items.py</code>中定义好模型。以后就不要使用字典。</li>
<li><code>pipeline</code>：这个是专门用来保存数据的。其中有三个方法是会经常用的。<ul>
<li><code>open_spider(self,spider)</code>：当爬虫被打开的时候执行</li>
<li><code>process_item(self,item,spider</code>)：当爬虫有item传过来的时候会被调用</li>
<li><code>close_spider(self,spider)</code>：当爬虫关闭的时候会被调用</li>
</ul>
</li>
</ol>
<p>要激活<code>pipeline</code>，应该在<code>settings.py</code>中，设置<code>ITEM_PIPELINES</code>。示例如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">ITEM_PIPELINES = &#123;</span><br><span class="line">   <span class="string">&#x27;qsbk.pipelines.QsbkPipeline&#x27;</span>: <span class="number">300</span>, <span class="comment">#数字小，优先级高</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="JsonItemExporter和JsonLinesItemExporter："><a href="#JsonItemExporter和JsonLinesItemExporter：" class="headerlink" title="JsonItemExporter和JsonLinesItemExporter："></a>JsonItemExporter和JsonLinesItemExporter：</h2><p>保存<code>json</code>数据的时候，可以使用这两个类，让操作变得更简单。</p>
<h3 id="JsonItemExport"><a href="#JsonItemExport" class="headerlink" title="JsonItemExport"></a>JsonItemExport</h3><p>每次把数据添加到内存中。最后统一写到磁盘中。</p>
<ul>
<li>优点：存储的数据是一个满足json规则的数据</li>
<li>缺点：如果数据量比较大，比较耗内存</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> scrapy.exporters <span class="keyword">import</span> JsonItemExporter</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">QsbkPipeline</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.fp = <span class="built_in">open</span>(<span class="string">&#x27;duanzi.json&#x27;</span>, <span class="string">&#x27;wb&#x27;</span>)</span><br><span class="line">        self.exporter = JsonItemExporter(self.fp, ensure_ascii=<span class="literal">False</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">        self.exporter.start_exporting()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">open_spider</span>(<span class="params">self,spider</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;爬虫开始&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">process_item</span>(<span class="params">self, item, spider</span>):</span></span><br><span class="line">        self.exporter.export_item(item)</span><br><span class="line">        <span class="keyword">return</span> item</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">close_spider</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.exporter.finish_exporting()</span><br><span class="line">        self.fp.close()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;爬虫结束&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="JsonLinesItemExporter"><a href="#JsonLinesItemExporter" class="headerlink" title="JsonLinesItemExporter"></a>JsonLinesItemExporter</h3><p>每次调用<code>export_item</code>的时候把这个<code>item</code>存在到磁盘中</p>
<ul>
<li>优点：每次处理数据的时候，直接存储到磁盘中，不耗内存。数据也比较安全。</li>
<li>缺点：每一个字典是一行，整个文件不是一个满足<code>json</code>格式的文件。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> scrapy.exporters <span class="keyword">import</span> JsonLinesItemExporter</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">QsbkPipeline</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.fp = <span class="built_in">open</span>(<span class="string">&#x27;duanzi.json&#x27;</span>, <span class="string">&#x27;wb&#x27;</span>)</span><br><span class="line">        self.exporter = JsonLinesItemExporter(self.fp, ensure_ascii=<span class="literal">False</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">open_spider</span>(<span class="params">self,spider</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;爬虫开始&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">process_item</span>(<span class="params">self, item, spider</span>):</span></span><br><span class="line">        self.exporter.export_item(item)</span><br><span class="line">        <span class="keyword">return</span> item</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">close_spider</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.fp.close()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;爬虫结束&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h1 id="CrawlSpider"><a href="#CrawlSpider" class="headerlink" title="CrawlSpider"></a>CrawlSpider</h1><p>可以实现，只要满足某个条件的<code>url</code>，都进行爬取。<code>CrawlSpider</code>继承自<code>Spider</code>，只不过是在之前的基础之上增加了新的功能，可以定义爬取的<code>url</code>的规则，以后<code>scrapy</code>碰到满足条件的<code>url</code>都进行爬取，而不用手动的<code>yield Request</code>。</p>
<h2 id="创建CrawlSpider爬虫"><a href="#创建CrawlSpider爬虫" class="headerlink" title="创建CrawlSpider爬虫"></a>创建<code>CrawlSpider</code>爬虫</h2><p>之前创建爬虫的方式是通过<code>scrapy genspider [爬虫名字] [域名]</code>的方式创建的。如果想要创建<code>CrawlSpider</code>爬虫，那么应该通过以下命令创建：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">scrapy genspider -t crawl [爬虫名字] [域名]</span><br></pre></td></tr></table></figure>

<h2 id="LinkExtractors链接提取器"><a href="#LinkExtractors链接提取器" class="headerlink" title="LinkExtractors链接提取器"></a>LinkExtractors链接提取器</h2><p>使用<code>LinkExtractors</code>可以不用程序员自己提取想要的<code>url</code>，然后发送请求。这些工作都可以交给<code>LinkExtractors</code>，他会在所有爬的页面中找到满足规则的<code>url</code>，实现自动的爬取。以下对<code>LinkExtractors</code>类做一个简单的介绍：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">scrapy</span>.<span class="title">linkextractors</span>.<span class="title">LinkExtractor</span>(<span class="params"></span></span></span><br><span class="line"><span class="class"><span class="params">    allow = (<span class="params"></span>),</span></span></span><br><span class="line"><span class="class"><span class="params">    deny = (<span class="params"></span>),</span></span></span><br><span class="line"><span class="class"><span class="params">    allow_domains = (<span class="params"></span>),</span></span></span><br><span class="line"><span class="class"><span class="params">    deny_domains = (<span class="params"></span>),</span></span></span><br><span class="line"><span class="class"><span class="params">    deny_extensions = <span class="literal">None</span>,</span></span></span><br><span class="line"><span class="class"><span class="params">    restrict_xpaths = (<span class="params"></span>),</span></span></span><br><span class="line"><span class="class"><span class="params">    tags = (<span class="params"><span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;area&#x27;</span></span>),</span></span></span><br><span class="line"><span class="class"><span class="params">    attrs = (<span class="params"><span class="string">&#x27;href&#x27;</span></span>),</span></span></span><br><span class="line"><span class="class"><span class="params">    canonicalize = <span class="literal">True</span>,</span></span></span><br><span class="line"><span class="class"><span class="params">    unique = <span class="literal">True</span>,</span></span></span><br><span class="line"><span class="class"><span class="params">    process_value = <span class="literal">None</span></span></span></span><br><span class="line"><span class="class"><span class="params"></span>)</span></span><br></pre></td></tr></table></figure>

<p>主要参数讲解：</p>
<ul>
<li><code>allow</code>：允许的url。所有满足这个正则表达式的url都会被提取。</li>
<li><code>deny</code>：禁止的url。所有满足这个正则表达式的url都不会被提取。</li>
<li><code>allow_domains</code>：允许的域名。只有在这个里面指定的域名的url才会被提取。</li>
<li><code>deny_domains</code>：禁止的域名。所有在这个里面指定的域名的url都不会被提取。</li>
<li><code>restrict_xpaths</code>：严格的xpath。和allow共同过滤链接。</li>
</ul>
<h2 id="Rule规则类"><a href="#Rule规则类" class="headerlink" title="Rule规则类"></a>Rule规则类</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">scrapy</span>.<span class="title">spiders</span>.<span class="title">Rule</span>(<span class="params"></span></span></span><br><span class="line"><span class="class"><span class="params">    link_extractor, </span></span></span><br><span class="line"><span class="class"><span class="params">    callback = <span class="literal">None</span>, </span></span></span><br><span class="line"><span class="class"><span class="params">    cb_kwargs = <span class="literal">None</span>, </span></span></span><br><span class="line"><span class="class"><span class="params">    follow = <span class="literal">None</span>, </span></span></span><br><span class="line"><span class="class"><span class="params">    process_links = <span class="literal">None</span>, </span></span></span><br><span class="line"><span class="class"><span class="params">    process_request = <span class="literal">None</span></span></span></span><br><span class="line"><span class="class"><span class="params"></span>)</span></span><br></pre></td></tr></table></figure>

<p>主要参数讲解：</p>
<ul>
<li><code>link_extractor</code>：一个<code>LinkExtractor</code>对象，用于定义爬取规则。</li>
<li><code>callback</code>：满足这个规则的url，应该要执行哪个回调函数。因为<code>CrawlSpider</code>使用了<code>parse</code>作为回调函数，因此不要覆盖<code>parse</code>作为回调函数自己的回调函数。</li>
<li><code>follow</code>：指定根据该规则从response中提取的链接是否需要跟进。</li>
<li><code>process_links</code>：从<code>link_extractor</code>中获取到链接后会传递给这个函数，用来过滤不需要爬取的链接。</li>
</ul>
<h2 id="使用说明"><a href="#使用说明" class="headerlink" title="使用说明"></a>使用说明</h2><p><code>LinkExtractor</code>和<code>Rule</code>决定爬虫的具体走向。</p>
<ol>
<li><code>allow</code>设置规则的方法：能够限制在我们想要的url上，不与其它的url相同的正则表达式即可。</li>
<li><code>follow</code>使用场景：如果在爬取页面的时候，需要将满足当前条件的url再进行跟进，那么就设置为<code>True</code>。否则设置为<code>False</code>。</li>
<li><code>callback</code>使用场景：如果这个url对应的页面，只是为了获取更多的url，并不需要里面的数据，可以不指定callback。如果想获取url对应页面中的数据，那么久需要制定一个callback。</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> scrapy.linkextractors <span class="keyword">import</span> LinkExtractor</span><br><span class="line"><span class="keyword">from</span> scrapy.spiders <span class="keyword">import</span> CrawlSpider, Rule</span><br><span class="line"><span class="keyword">from</span> wxapp.items <span class="keyword">import</span> WxappItem</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WxappSpiderSpider</span>(<span class="params">CrawlSpider</span>):</span></span><br><span class="line">    name = <span class="string">&#x27;wxapp_spider&#x27;</span></span><br><span class="line">    allowed_domains = [<span class="string">&#x27;wxapp-union.com&#x27;</span>]</span><br><span class="line">    start_urls = [<span class="string">&#x27;http://www.wxapp-union.com/portal.php?mod=list&amp;catid=2&amp;page=1&#x27;</span>]</span><br><span class="line"></span><br><span class="line">    rules = (</span><br><span class="line">        Rule(LinkExtractor(allow=<span class="string">r&#x27;.+mod=list&amp;catid=2&amp;page=/d&#x27;</span>), follow=<span class="literal">True</span>),</span><br><span class="line">        Rule(LinkExtractor(allow=<span class="string">r&#x27;.+article-.+\.html&#x27;</span>), callback=<span class="string">&#x27;parse_detail&#x27;</span>, follow=<span class="literal">False</span>),</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">parse_detail</span>(<span class="params">self, response</span>):</span></span><br><span class="line">        title = response.xpath(<span class="string">&quot;//h1[@class=&#x27;ph&#x27;]/text()&quot;</span>).get()</span><br><span class="line">        author_p = response.xpath(<span class="string">&quot;//p[@class=&#x27;authors&#x27;]&quot;</span>)</span><br><span class="line">        author = author_p.xpath(<span class="string">&quot;./a/text()&quot;</span>).get()</span><br><span class="line">        pub_time = author_p.xpath(<span class="string">&quot;./span/text()&quot;</span>).get()</span><br><span class="line">        article_content = response.xpath(<span class="string">&quot;//td[@id=&#x27;article_content&#x27;]//text()&quot;</span>).getall()</span><br><span class="line">        content = <span class="string">&#x27;&#x27;</span>.join(article_content).strip()</span><br><span class="line">        item = WxappItem(author=author, title=title, pub_time=pub_time,content=content)</span><br><span class="line">        <span class="keyword">yield</span> item</span><br></pre></td></tr></table></figure>

<h1 id="Scrapy-Shell"><a href="#Scrapy-Shell" class="headerlink" title="Scrapy Shell"></a>Scrapy Shell</h1><p>我们想要在爬虫中使用<code>xpath</code>、<code>beautifulsoup</code>、<code>正则表达式</code>、<code>css选择器</code>等来提取想要的数据。但是因为<code>scrapy</code>是一个比较重的框架。每次运行起来都要等待一段时间。因此要去验证我们写的提取规则是否正确，是一个比较麻烦的事情。因此<code>scrapy</code>提供了一个<code>shell</code>，用来方便的测试规则。当然也不仅仅局限于这一个功能。</p>
<h2 id="打开Scrapy-Shell"><a href="#打开Scrapy-Shell" class="headerlink" title="打开Scrapy Shell"></a>打开Scrapy Shell</h2><ol>
<li>打开<code>cmd</code>终端，进入到<code>scrapy</code>框架所在的虚拟环境中，输入命令<code>scrapy shell [链接]</code>。就会进入到<code>scrapy</code>的<code>shell</code>环境中。在这个环境中，你可以跟在爬虫的<code>parse</code>方法中一样使用了</li>
<li>如果想读取某个项目的配置信息，应先进入到这个项目目录，再执行<code>scrapy shell</code>命令</li>
</ol>
<h1 id="Request和Response对象"><a href="#Request和Response对象" class="headerlink" title="Request和Response对象"></a>Request和Response对象</h1><h2 id="Request对象"><a href="#Request对象" class="headerlink" title="Request对象"></a>Request对象</h2><p><code>Request</code>对象在我们写爬虫，爬取一页的数据需要重新发送一个请求的时候调用。这个类需要传递一些参数，其中比较常用的参数有：</p>
<ol>
<li><code>url</code>：这个<code>request</code>对象发送请求的<code>url</code>。</li>
<li><code>callback</code>：在下载器下载完成相应的数据后执行的回调函数</li>
<li><code>method</code>：请求的方法。默认为<code>GET</code>方法，可以设置为其它方法。</li>
<li><code>headers</code>：请求头，对于一些固定的设置，放在<code>settings.py</code>中指定就可以了。对于那些非固定的，可以在发送请求的时候指定。</li>
<li><code>meta</code>：比较常用。用于在不同的请求之间传递数据用的</li>
<li><code>encoding</code>：编码。默认为<code>utf-8</code>，使用默认的即可。</li>
<li><code>dot_filter</code>：表示不由调度器过滤。在执行多次重复的请求时用得比较多。</li>
<li><code>errback</code>：在发生错误时执行的函数。</li>
</ol>
<h2 id="Response"><a href="#Response" class="headerlink" title="Response"></a>Response</h2><p><code>Response</code>对象一般是由<code>Scrapy</code>自动构建的。因此开发者不需要关心如何创建<code>Response</code>对象，而是要了解如何使用。<code>Response</code>对象有很多属性，可以用来提取数据：</p>
<ol>
<li><code>meta</code>：从其它请求传过来的<code>meta</code>属性，可以用来保持多个请求之间的数据连接。</li>
<li><code>encoding</code>：返回当前字符串编码和解码的格式</li>
<li><code>text</code>：将返回来的数据作为<code>Unicode</code>字符串返回</li>
<li><code>body</code>：将返回的数据作为<code>bytes</code>字符串返回</li>
<li><code>xpath</code>：<code>xpath</code>选择器</li>
<li><code>css</code>：<code>css</code>选择器</li>
</ol>
<h1 id="发送POST请求"><a href="#发送POST请求" class="headerlink" title="发送POST请求"></a>发送POST请求</h1><p>有时候想要在请求数据的时候发送<code>post</code>请求，那么这时候需要使用<code>Request</code>的子类<code>FormRequest</code>来实现。如果想要在爬虫一开始的时候就发送<code>POST</code>请求，需要在爬虫类中重写<code>start_request(self)</code>方法，并且不再调用<code>start_urls</code>里的<code>url</code>。</p>
<h1 id="下载文件和图片"><a href="#下载文件和图片" class="headerlink" title="下载文件和图片"></a>下载文件和图片</h1><p><code>Scrapy</code>为下载<code>item</code>中包含的文件（比如图片）提供了一个可重用的<code>item pipelines</code>。这些<code>pipeline</code>有些共同的方法和结构（我们称之为<code>media pipeline</code>）。一般来说会使用<code>Files Pipeline</code>或<code>Images Pipeline</code>。</p>
<h2 id="scrapy内置下载文件方法的优点"><a href="#scrapy内置下载文件方法的优点" class="headerlink" title="scrapy内置下载文件方法的优点"></a>scrapy内置下载文件方法的优点</h2><ol>
<li>避免重新下载最近已经下载过的数据</li>
<li>可以方便的指定文件存储的路径</li>
<li>可以将下载的图片转换成通用的格式。比如<code>png</code>或<code>jpg</code>。</li>
<li>可以方便的生成缩略图</li>
<li>可以方便的检测图片的宽和高，确保他们满足最小限制</li>
<li>异步下载，效率非常高</li>
</ol>
<h2 id="下载文件的Files-Pipline"><a href="#下载文件的Files-Pipline" class="headerlink" title="下载文件的Files Pipline"></a>下载文件的Files Pipline</h2><p>当使用<code>Files Pipline</code>下载文件的时候，按照以下步骤来完成：</p>
<ol>
<li>定义好一个<code>Item</code>，然后在这个<code>Item</code>中定义两个属性，分别为<code>file_urls</code>以及<code>files</code>。<code>file_urls</code>是用来存储需要下载的图片的<code>url</code>链接，需要给一个列表</li>
<li>当文件下载完成后，会把文件下载的相关信息存储到<code>item</code>的<code>files</code>属性中。比如下载路径、下载的url和文件的校验码等</li>
<li>在配置文件<code>settings.py</code>中配置<code>FILES_STORE</code>，这个配置是用来设置文件下载下来的路径</li>
<li>启动<code>pipeline</code>：在<code>ITEM_PIPELINES</code>中设置<code>scrapy.pipeline.files.FilesPipeline: 1</code></li>
</ol>
<h2 id="下载图片的Images-Pipeline"><a href="#下载图片的Images-Pipeline" class="headerlink" title="下载图片的Images Pipeline"></a>下载图片的Images Pipeline</h2><p>当使用<code>Images Pipeline</code>下载文件的时候，按照以下步骤来完成：</p>
<ol>
<li>定义好一个<code>Item</code>，然后再这个<code>item</code>中定义两个属性，分别为<code>image_urls</code>以及<code>images</code>。<code>image_urls</code>是用来存储需要下载的图片的<code>url</code>链接，需要给一个列表</li>
<li>当文件下载完成后，会把文件下载的相关细信息存储到<code>item</code>的<code>images</code>属性中。比如下载路径、下载的<code>url</code>和图片的校验码等。</li>
<li>在配置文件<code>settings.py</code>中配置<code>IMAGES_STORE</code>，这个配置是用来设置图片下载下来的路径。</li>
<li>启动<code>pipeline</code>：在<code>ITEM_PIPELINES</code>中设置<code>scrapy.pipelines.images.ImagesPipeline: 1</code></li>
</ol>
<h1 id="Downloader-Middlewares（下载器中间件）"><a href="#Downloader-Middlewares（下载器中间件）" class="headerlink" title="Downloader Middlewares（下载器中间件）"></a>Downloader Middlewares（下载器中间件）</h1><p>下载器中间件是引擎和下载器之间通信的中间件。在这个中间件中可以设置代理、更换请求头等来达到反反爬虫的目的。要写下载器中间件，可以在下载器中实现两个方法。一个是<code>process_request(self, request, spider)</code>，这个方法是在请求发送之前会执行，还有一个是<code>process_response(self, request, response, spider)</code>，这个方法是数据下载到引擎之前执行。</p>
<h2 id="process-request-self-request-spider-："><a href="#process-request-self-request-spider-：" class="headerlink" title="process_request(self, request, spider)："></a>process_request(self, request, spider)：</h2><p>这个方法是下载器在发送请求之前会执行的。一般可以在这个里面设置随机代理ip等。</p>
<ol>
<li>参数：</li>
</ol>
<ul>
<li><code>request</code>：发送请求的request对象</li>
<li><code>spider</code>：发送请求的spider对象</li>
</ul>
<ol start="2">
<li>返回值：</li>
</ol>
<ul>
<li>返回<code>None</code>：如果返回<code>None</code>，<code>Scrapy</code>将继续处理该<code>request</code>，执行其它中间件中的相应方法，知道合适的下载器处理函数被调用，</li>
<li>返回<code>Response</code>对象：<code>Scrapy</code>将不会调用任何其它的<code>process_request</code>方法，将直接返回这个<code>response</code>对象。已经激活的中间件的<code>process_response()</code>方法则会在每个<code>response</code>返回时调用。(有疑问)</li>
<li>返回<code>Request</code>对象：不在使用之前的<code>request</code>对象去下载数据，而是根据现在返回的<code>request</code>对象返回数据。</li>
<li>如果这个方法中抛出了异常，则会调用<code>process_exception</code>方法</li>
</ul>
<h2 id="process-response-self-request-response-spider"><a href="#process-response-self-request-response-spider" class="headerlink" title="process_response(self, request, response, spider)"></a>process_response(self, request, response, spider)</h2><p>这个是下载器下载的数据到引擎中间会执行的方法</p>
<ol>
<li>参数：</li>
</ol>
<ul>
<li>request：request对象</li>
<li>response：被处理的response对象</li>
<li>spider：spider对象</li>
</ul>
<ol start="2">
<li>返回值：</li>
</ol>
<ul>
<li>返回<code>Response</code>对象：会将这个新的<code>response</code>对象传给其它中间件，最终传给爬虫</li>
<li>返回<code>Request</code>对象：下载器链被切断，返回的<code>request</code>会重新被下载器调度下载</li>
<li>如果抛出一个异常，那么调用<code>request</code>的<code>errback</code>方法，如果没有指定这个方法，那么会抛出一个异常。</li>
</ul>
<h2 id="随机请求头中间件"><a href="#随机请求头中间件" class="headerlink" title="随机请求头中间件"></a>随机请求头中间件</h2><p>爬虫在频繁访问一个页面的时候，这个请求头如果一直保持一直。那么很容易被服务器发现，从而禁止这个请求头的访问。因此我们要在访问这个页面之前随机的更改请求头，这样才可以避免爬虫被抓。随机更改请求头，可以在下载器中间件中实现。在请求发送给服务器之前，随机的选择一个请求头。示例代码如下：</p>
<p><img data-src="https://developers.whatismybrowser.com/" alt="User_Agent网站"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserAgentDownloadMiddleware</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    USER_AGENT = [</span><br><span class="line">        <span class="string">&#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/60.0.3112.113 Safari/537.36&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/60.0.3112.90 Safari/537.36&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.102 Safari/537.36&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;Mozilla/5.0 (Windows NT 6.1; WOW64; rv:54.0) Gecko/20100101 Firefox/54.0&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:61.0) Gecko/20100101 Firefox/61.0&#x27;</span>,</span><br><span class="line">    ]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">process_request</span>(<span class="params">self, request, spider</span>):</span></span><br><span class="line">        user_agent = random.choice(self.USER_AGENT)</span><br><span class="line">        request.headers[<span class="string">&#x27;user-agent&#x27;</span>] = user_agent</span><br></pre></td></tr></table></figure>

<h2 id="ip代理池中间件"><a href="#ip代理池中间件" class="headerlink" title="ip代理池中间件"></a>ip代理池中间件</h2><h3 id="购买代理"><a href="#购买代理" class="headerlink" title="购买代理"></a>购买代理</h3><p>芝麻地理，太阳代理等</p>
<h3 id="使用ip代理池"><a href="#使用ip代理池" class="headerlink" title="使用ip代理池"></a>使用ip代理池</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 中间件</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IPProxyDownloadMiddleware</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    PROXIES = [</span><br><span class="line">        <span class="string">&#x27;111.177.188.158:9999&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;117.191.11.102:8080&#x27;</span></span><br><span class="line">    ]</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">process_request</span>(<span class="params">self, request,spider</span>):</span></span><br><span class="line">        proxy = random.choice(self.PROXIES)</span><br><span class="line">        request.meta[<span class="string">&#x27;proxy&#x27;</span>] = <span class="string">&#x27;http://&#x27;</span> + proxy</span><br></pre></td></tr></table></figure>

<p>使用独享代理的话：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 中间件</span></span><br><span class="line"><span class="comment"># 快代理，独享代理</span></span><br><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IPProxyDownloadMiddleware</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">process_request</span>(<span class="params">self, request,spider</span>):</span></span><br><span class="line">        proxy = <span class="string">&#x27;121.199.6.124:16816&#x27;</span></span><br><span class="line">        user_password = <span class="string">&#x27;970138076: reessc13&#x27;</span></span><br><span class="line">        request.meta[<span class="string">&#x27;proxy&#x27;</span>] = <span class="string">&#x27;http://&#x27;</span> + proxy  <span class="comment">#教程里没加&#x27;http://&#x27;</span></span><br><span class="line">        b64_user_password = base64.b64encode(user_password.encode(utf-<span class="number">8</span>))</span><br><span class="line">        request.headers[<span class="string">&#x27;Proxy-Authorization&#x27;</span>] = <span class="string">&#x27;Basic&#x27;</span> + b64_user_password.decode(<span class="string">&#x27;utf-8&#x27;</span>) <span class="comment">#不明白为什么要先编码再解码</span></span><br></pre></td></tr></table></figure>

<h1 id="redis"><a href="#redis" class="headerlink" title="redis"></a>redis</h1><p><code>redis</code>是一种支持分布式的<code>nosql</code>数据库,他的数据是保存在内存中，同时<code>redis</code>可以定时把内存数据同步到磁盘，即可以将数据持久化，并且他比<code>memcached</code>支持更多的数据结构(<code>string</code>,<code>list列表[队列和栈]</code>,<code>set[集合]</code>,<code>sorted set[有序集合]</code>,<code>hash(hash表)</code>)。相关参考文档：<a href="http://redisdoc.com/index.html">Redis 命令参考</a></p>
<h2 id="redis使用场景："><a href="#redis使用场景：" class="headerlink" title="redis使用场景："></a>redis使用场景：</h2><ol>
<li>登录会话存储：存储在<code>redis</code>中，与<code>memcached</code>相比，数据不会丢失。</li>
<li>排行版/计数器：比如一些秀场类的项目，经常会有一些前多少名的主播排名。还有一些文章阅读量的技术，或者新浪微博的点赞数等。</li>
<li>作为消息队列：比如<code>celery</code>就是使用<code>redis</code>作为中间人。</li>
<li>当前在线人数：还是之前的秀场例子，会显示当前系统有多少在线人数。</li>
<li>一些常用的数据缓存：比如我们的BBS论坛，板块不会经常变化的，但是每次访问首页都要从<code>mysql</code>中获取，可以在<code>redis</code>中缓存起来，不用每次请求数据库。</li>
<li>把前200篇文章缓存或者评论缓存：一般用户浏览网站，只会浏览前面一部分文章或者评论，那么可以把前面200篇文章和对应的评论缓存起来。用户访问超过的，就访问数据库，并且以后文章超过200篇，则把之前的文章删除。</li>
<li>好友关系：微博的好友关系使用redis实现。</li>
<li>发布和订阅功能：可以用来做聊天软件。</li>
</ol>
<h2 id="redis和memcached的比较"><a href="#redis和memcached的比较" class="headerlink" title="redis和memcached的比较"></a>redis和memcached的比较</h2><table>
<thead>
<tr>
<th></th>
<th>memecached</th>
<th>redis</th>
</tr>
</thead>
<tbody><tr>
<td>类型</td>
<td>纯内存数据库</td>
<td>内存磁盘同步数据库</td>
</tr>
<tr>
<td>数据类型</td>
<td>在定义value时就要固定数据类型</td>
<td>不需要</td>
</tr>
<tr>
<td>虚拟内存</td>
<td>不支持</td>
<td>支持</td>
</tr>
<tr>
<td>过期策略</td>
<td>支持</td>
<td>支持</td>
</tr>
<tr>
<td>存储数据安全</td>
<td>不支持</td>
<td>可以将数据同步到dump.db中</td>
</tr>
<tr>
<td>灾难恢复</td>
<td>不支持</td>
<td>可以将磁盘中的数据恢复到内存中</td>
</tr>
<tr>
<td>分布式</td>
<td>支持</td>
<td>主从同步</td>
</tr>
<tr>
<td>订阅与发布</td>
<td>不支持</td>
<td>支持</td>
</tr>
</tbody></table>
<h2 id="其它机器访问本机redis服务器"><a href="#其它机器访问本机redis服务器" class="headerlink" title="其它机器访问本机redis服务器"></a>其它机器访问本机redis服务器</h2><p>想要让其他机器访问本机的<code>redis</code>服务器。那么要修改<code>redis.conf</code>的配置文件，将<code>bind</code>改成<code>bind [自己的ip地址或者0.0.0.0]</code>，其他机器才能访问。<br><strong>注意</strong>：<code>bind</code>绑定的是本机网卡的ip地址，而不是想让其他机器连接的ip地址。如果有多块网卡，那么可以绑定多个网卡的ip地址。如果绑定到额是<code>0.0.0.0</code>，那么意味着其他机器可以通过本机所有的ip地址进行访问。</p>
<h2 id="对redis的操作"><a href="#对redis的操作" class="headerlink" title="对redis的操作"></a>对redis的操作</h2><p>对<code>redis</code>的操作可以用两种方式，第一种方式采用<code>redis-cli</code>，第二种方式采用编程语言，比如<code>Python</code>、<code>PHP</code>和<code>JAVA</code>等。下面使用<code>redis-cli</code>对<code>redis</code>进行操作。</p>
<h3 id="字符串操作："><a href="#字符串操作：" class="headerlink" title="字符串操作："></a>字符串操作：</h3><p>启动redis：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo service redis-server start</span><br></pre></td></tr></table></figure>

<p>连接上redis-server：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">redis-cli -h [ip] -p [端口]</span><br></pre></td></tr></table></figure>

<p>添加：<code>set key value</code>。将字符串值<code>value</code>关联到<code>key</code>。如果<code>key</code>已经持有其他值，<code>set</code>命令就覆写旧值，无视其类型。并且默认的过期时间是永久，即永远不会过期。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">set username xiaotuo</span><br></pre></td></tr></table></figure>

<p>删除：<code>del key</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">del username</span><br></pre></td></tr></table></figure>

<p>设置过期时间：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">expire key timeout(单位为秒)</span><br></pre></td></tr></table></figure>

<p>也可以在设置值的时候，一同指定过期时间：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">set key value EX timeout</span><br><span class="line"><span class="meta">#</span><span class="bash"> 或下面的写法</span></span><br><span class="line">setex key timeout value</span><br></pre></td></tr></table></figure>

<p>查看过期时间：<code>ttl key</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ttl username</span><br></pre></td></tr></table></figure>

<p>查看当前<code>redis</code>中的所有<code>key</code>：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">keys *</span><br></pre></td></tr></table></figure>

<h3 id="列表操作"><a href="#列表操作" class="headerlink" title="列表操作"></a>列表操作</h3><p>在列表左边添加元素：将值<code>value</code>插入到列表<code>key</code>的表头。如果<code>key</code>不存在，一个空列表会被创建并执行<code>lpush</code>操作。当<code>key</code>存在但不是列表类型时，将返回一个错误。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">lpush key <span class="keyword">value</span></span><br></pre></td></tr></table></figure>

<p>在列表右边添加元素：将值<code>value</code>插入到列表<code>key</code>的表尾。如果<code>key</code>不存在，一个空列表会被创建并执行<code>rpush</code>操作。当<code>key</code>存在但不是列表类型时，返回一个错误。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">rpush key <span class="keyword">value</span></span><br></pre></td></tr></table></figure>

<p>查看列表中的元素：返回列表<code>key</code>中指定区间内的元素，区间以偏移量<code>start</code>和<code>stop</code>指定,如果要左边的第一个到最后的一个<code>lrange key 0 -1</code>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">lrange key start stop</span><br></pre></td></tr></table></figure>

<p>移除列表中的元素：</p>
<p>移除并返回列表key的头元素：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">lpop key</span><br></pre></td></tr></table></figure>

<p>移除并返回列表的尾元素：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rpop key</span><br></pre></td></tr></table></figure>

<p>移除并返回列表<code>key</code>的中间元素：将删除key这个列表中，值为value的元素，count为指定个数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">lrem key count value</span><br></pre></td></tr></table></figure>

<p>指定返回第几个元素：将返回<code>key</code>这个列表中，索引为<code>index</code>的这个元素。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">lindex key index</span><br></pre></td></tr></table></figure>

<p>获取列表中的元素个数：<code>llen key</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">llen languages</span><br></pre></td></tr></table></figure>

<p>删除指定的元素：<code>lrem key count value</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">lrem languages 0 php</span><br></pre></td></tr></table></figure>

<p>根据参数<code>count</code>的值，移除列表中与参数<code>value</code>相等的元素。<code>count</code>的值可以是以下几种：</p>
<ul>
<li>count &gt; 0：从表头开始向表尾搜索，移除与<code>value</code>相等的元素，数量为<code>count</code>。</li>
<li>count &lt; 0：从表尾开始向表头搜索，移除与<code>value</code>相等的元素，数量为<code>count</code>的绝对值。</li>
<li>count = 0：移除表中所有与<code>value</code>相等的值。</li>
</ul>
<h3 id="set集合的操作"><a href="#set集合的操作" class="headerlink" title="set集合的操作"></a>set集合的操作</h3><p>添加元素：<code>sadd set value1 value2....</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sadd team xiaotuo datuo</span><br></pre></td></tr></table></figure>

<p>查看元素：<code>smembers set</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">smembers team</span><br></pre></td></tr></table></figure>

<p>移除元素：<code>srem set member...</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">srem team xiaotuo datuo</span><br></pre></td></tr></table></figure>

<p>查看集合中的元素个数：<code>scard set</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">scard team1</span><br></pre></td></tr></table></figure>

<p>获取多个集合的交集：<code>sinter set1 set2</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sinter team1 team2</span><br></pre></td></tr></table></figure>

<p>获取多个集合的并集：<code>sunion set1 set2</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sunion team1 team2</span><br></pre></td></tr></table></figure>

<p>获取多个集合的差集：<code>sdiff set1 set2</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sdiff team1 team2</span><br></pre></td></tr></table></figure>

<h3 id="hash哈希操作"><a href="#hash哈希操作" class="headerlink" title="hash哈希操作"></a>hash哈希操作</h3><p>添加一个新值：<code>hset key field value</code>。将哈希表<code>key</code>中的域<code>field</code>的值设为<code>value</code>。如果<code>key</code>不存在，一个新的哈希表被创建并进行<code>hset</code>操作。如果域<code>field</code>已经存在于哈希表中，旧值将被覆盖。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hset website baidu baidu.com</span><br></pre></td></tr></table></figure>

<p>获取哈希中的<code>field</code>对应的值：<code>hget key field</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hget website baidu</span><br></pre></td></tr></table></figure>

<p>删除<code>field</code>中的某个<code>field</code>：<code>hdel key field</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hdel website baidu</span><br></pre></td></tr></table></figure>

<p>获取某个哈希中所有的<code>field</code>和<code>value</code>：<code>hgetall key</code></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">hgetall website</span><br></pre></td></tr></table></figure>

<p>获取某个哈希中所有的<code>field</code>：<code>hkeys key</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hkeys website</span><br></pre></td></tr></table></figure>

<p>获取某个哈希中所有的值：<code>hvals key</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hvals website</span><br></pre></td></tr></table></figure>

<p>判断哈希中是否存在某个<code>field</code>：<code>hexists key field</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexists website baidu</span><br></pre></td></tr></table></figure>

<p>获取哈希中键值对的数量：<code>hlen field</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hlen website</span><br></pre></td></tr></table></figure>

<p>其它知识点用到再补充</p>
<h1 id="Scrapy-Redis分布式爬虫组件"><a href="#Scrapy-Redis分布式爬虫组件" class="headerlink" title="Scrapy-Redis分布式爬虫组件"></a>Scrapy-Redis分布式爬虫组件</h1><p><code>Scrapy</code>是一个框架，他本身是不支持分布式的。如果我们想要做分布式的爬虫，就需要借助一个组件叫做<code>Scrapy-Redis</code>，这个组件正是利用了<code>Redis</code>可以分布式的功能，集成到<code>Scrapy</code>框架中，使得爬虫可以进行分布式。可以充分的利用资源（多个ip、更多带宽、同步爬取）来提高爬虫的爬行效率。</p>
<h1 id="分布式爬虫的优点"><a href="#分布式爬虫的优点" class="headerlink" title="分布式爬虫的优点"></a>分布式爬虫的优点</h1><ol>
<li>可以充分利用多台机器的带宽。</li>
<li>可以充分利用多台机器的ip地址。</li>
<li>多台机器做，爬取效率更高。</li>
</ol>
<h1 id="分布式爬虫必须要解决的问题"><a href="#分布式爬虫必须要解决的问题" class="headerlink" title="分布式爬虫必须要解决的问题"></a>分布式爬虫必须要解决的问题</h1><ol>
<li>分布式爬虫是好几台机器在同时运行，如何保证不同的机器爬取页面的时候不会出现重复爬取的问题。</li>
<li>同样，分布式爬虫在不同的机器上运行，在把数据爬完后如何保证保存在同一个地方。</li>
</ol>
<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>通过<code>pip install scrapy-redis</code>即可安装。</p>
<h1 id="Scrapy-Redis架构"><a href="#Scrapy-Redis架构" class="headerlink" title="Scrapy-Redis架构"></a>Scrapy-Redis架构</h1><p>这块少图，有空了找个高清的。</p>
<p><code>Item Pipeline</code>在接收到数据后发送给了<code>Redis</code>、<code>Scheduler</code>调度器调度数据也是从<code>Redis</code>中来的、并且其实数据去重也是在<code>Redis</code>中做的。</p>
<h1 id="编写Scrapy-Redis分布式爬虫"><a href="#编写Scrapy-Redis分布式爬虫" class="headerlink" title="编写Scrapy-Redis分布式爬虫"></a>编写Scrapy-Redis分布式爬虫</h1><p>要将一个<code>Scrapy</code>项目变成一个<code>Scrapy-redis</code>项目只需修改以下三点就可以了：</p>
<ol>
<li>将爬虫的类从<code>scrapy.Spider</code>变成<code>scrapy_redis.spiders.RedisSpider</code>；或者是从<code>scrapy.CrawlSpider</code>变成<code>scrapy_redis.spiders.RedisCrawlSpider</code>。</li>
<li>将爬虫中的<code>start_urls</code>删掉。增加一个<code>redis_key=&quot;xxx&quot;</code>。这个<code>redis_key</code>是为了以后在<code>redis</code>中控制爬虫启动的。爬虫的第一个<code>url</code>，就是在<code>redis</code>中通过这个发送出去的。</li>
<li>在配置文件中增加如下配置：</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Scrapy-Redis相关配置</span></span><br><span class="line"><span class="comment"># 确保request存储到redis中</span></span><br><span class="line">SCHEDULER = <span class="string">&quot;scrapy_redis.scheduler.Scheduler&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 确保所有爬虫共享相同的去重指纹</span></span><br><span class="line">DUPEFILTER_CLASS = <span class="string">&quot;scrapy_redis.dupefilter.RFPDupeFilter&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置redis为item pipeline，之前的pipeline注释掉</span></span><br><span class="line">ITEM_PIPELINES = &#123;</span><br><span class="line">    <span class="string">&#x27;scrapy_redis.pipelines.RedisPipeline&#x27;</span>: <span class="number">300</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在redis中保持scrapy-redis用到的队列，不会清理redis中的队列，从而可以实现暂停和恢复的功能。</span></span><br><span class="line">SCHEDULER_PERSIST = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置连接redis信息</span></span><br><span class="line">REDIS_HOST = <span class="string">&#x27;127.0.0.1&#x27;</span></span><br><span class="line">REDIS_PORT = <span class="number">6379</span></span><br></pre></td></tr></table></figure>

<h1 id="运行爬虫"><a href="#运行爬虫" class="headerlink" title="运行爬虫"></a>运行爬虫</h1><ol>
<li>在爬虫服务器上。进入爬虫文件所在的路径，然后输入命令：<code>scrapy runspider [爬虫名字]</code>。</li>
<li>在<code>Redis</code>服务器上，推入一个开始的<code>url</code>链接<code>：redis-cli&gt; lpush [redis_key] start_url</code>开始爬取。</li>
</ol>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>爬虫</category>
      </categories>
      <tags>
        <tag>scrapy</tag>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL李玉婷2019版基础</title>
    <url>/2021/05/09/MySQL%E6%9D%8E%E7%8E%89%E5%A9%B72019%E7%89%88%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h1 id="七天玩转MySQL"><a href="#七天玩转MySQL" class="headerlink" title="七天玩转MySQL"></a>七天玩转MySQL</h1><h2 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> ... <span class="keyword">from</span> ....</span><br><span class="line"><span class="keyword">where</span> ...</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> ...</span><br><span class="line"><span class="keyword">having</span> ...</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> ...</span><br><span class="line">limit ...;</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<p>执行顺序：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> <span class="keyword">from</span></span><br><span class="line"><span class="number">2</span> <span class="keyword">where</span></span><br><span class="line"><span class="number">3</span> <span class="keyword">group</span> <span class="keyword">by</span></span><br><span class="line"><span class="number">4</span> <span class="keyword">having</span></span><br><span class="line"><span class="number">5</span> <span class="keyword">select</span></span><br><span class="line"><span class="number">6</span> <span class="keyword">order</span> <span class="keyword">by</span></span><br><span class="line"><span class="number">7</span> limit</span><br></pre></td></tr></table></figure>

<h2 id="group-by"><a href="#group-by" class="headerlink" title="group by"></a>group by</h2><p>MySql从5.7版本开始默认开启<code>only_full_group_by</code>规则，规则核心原则如下，没有遵循原则的sql会被认为是不合法的sql</p>
<ol>
<li><code>order by</code>后面的列必须是在<code>select</code>后面存在的</li>
<li><code>select</code>、<code>having</code>或<code>order by</code>后面存在的非聚合列必须全部在<code>group by</code>中存在</li>
</ol>
<h2 id="count-、count-1-、count-主键-、count-字段-的区别"><a href="#count-、count-1-、count-主键-、count-字段-的区别" class="headerlink" title="count(*)、count(1)、count(主键)、count(字段)的区别"></a>count(*)、count(1)、count(主键)、count(字段)的区别</h2><p>以下，基于 InnoDB</p>
<h3 id="含义区别"><a href="#含义区别" class="headerlink" title="含义区别"></a>含义区别</h3><p>count()是一个聚合函数，对于返回的结果集，会逐行判断，若返回的不是 NULL，就会加 1，否则不加。<br>因此，count(*)、count(主键 id)和count(1)都表示返回满足条件的结果集的总行数；而count(字段），则表示返回满足条件的数据行里面，参数“字段”不为 NULL 的总个数。</p>
<h3 id="性能区别"><a href="#性能区别" class="headerlink" title="性能区别"></a>性能区别</h3><p>分析性能，考虑以下几个原则：</p>
<ol>
<li>server 层要什么就会返回什么；</li>
<li>InnoDB 只返回必要的值；</li>
<li>优化器只优化了count(*)</li>
</ol>
<ul>
<li>对于count(主键id)，InnoDB 会遍历全表，取每行的主键 id，返回给 server 层，server 层拿到数据后，进行判断累加。</li>
<li>对于count(1)，InnoDB 仍遍历全表，但是不取值，server 层对返回的每一行数据新增一个 1，然后进行判断累加；<br>因此，count(1)要更快些，因为无需取值。从引擎返回 id 会涉及到解析数据行，以及拷贝字段值的操作。</li>
<li>对于count(字段)：</li>
</ul>
<ol>
<li>如果这个“字段”是定义为 not null 的话，一行行地从记录里面读出这个字段，判断不能为 null，按行累加；</li>
<li>如果这个“字段”定义允许为 null，那么执行的时候，判断到有可能是null，还要把值取出来再判断一下，不是 null 才累加。</li>
</ol>
<ul>
<li>但是<code>count(*)</code>是例外，并不会把全部字段取出来，而是专门做了优化，不取值。<code>count(*)</code>肯定不是<code>null</code>，按行累加。</li>
</ul>
<h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>按照效率排序的话</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">count(字段) &lt; count(主键 id) &lt; count(1) ≈ count(*)</span><br></pre></td></tr></table></figure>

<p>所以我建议你，尽量使用<code>count(*)</code></p>
<h1 id="MySQL服务的连接和退出"><a href="#MySQL服务的连接和退出" class="headerlink" title="MySQL服务的连接和退出"></a>MySQL服务的连接和退出</h1><p>登录：<br>mysql 【-h主机名 -P端口号 】-u用户名 -p密码<br>//-p密码，不能加空格，其他随意。主机名，端口号可以省略</p>
<p>退出：<br>exit或ctrl+C</p>
<h1 id="常见sql命令演示"><a href="#常见sql命令演示" class="headerlink" title="常见sql命令演示"></a>常见sql命令演示</h1><p>命令不区分大小写，库名、表名、字段名建议大写，其它小写。</p>
<ul>
<li>单行注释：<code>#</code>或<code>--空格</code></li>
<li>多行注释：<code>/*注释内容*/</code></li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> databases; <span class="operator">/</span><span class="operator">/</span> 展示数据库</span><br><span class="line">use 数据库名;   <span class="operator">/</span><span class="operator">/</span>使用</span><br><span class="line"><span class="keyword">show</span> tables;    <span class="operator">/</span><span class="operator">/</span>展示表</span><br><span class="line"><span class="keyword">show</span> tables <span class="keyword">from</span> 数据库名;  <span class="operator">/</span><span class="operator">/</span>查看其他数据库的表</span><br><span class="line"><span class="keyword">select</span> database();      <span class="operator">/</span><span class="operator">/</span>查看当前所在数据库</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>建表</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> stuinfo(</span><br><span class="line">    sutid   <span class="type">int</span>,</span><br><span class="line">    stuname <span class="type">varchar</span>(<span class="number">20</span>),</span><br><span class="line">    gender  <span class="type">char</span>,</span><br><span class="line">    borndate    datetime</span><br><span class="line">);</span><br><span class="line"><span class="keyword">desc</span> sutinfo;   <span class="operator">/</span><span class="operator">/</span>查看表结构</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> stuinfo <span class="keyword">values</span>(<span class="number">1</span>,<span class="string">&#x27;张无忌&#x27;</span>,<span class="string">&#x27;男&#x27;</span>,<span class="string">&#x27;1998-3-3&#x27;</span>);     <span class="operator">/</span><span class="operator">/</span>插入数据</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> stuinfo <span class="keyword">values</span>(<span class="number">2</span>,<span class="string">&#x27;张翠山&#x27;</span>,<span class="string">&#x27;男&#x27;</span>,<span class="string">&#x27;1998-3-3&#x27;</span>);     <span class="operator">/</span><span class="operator">/</span>插入数据</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> stuinfo;      <span class="operator">/</span><span class="operator">/</span>查看数据</span><br><span class="line">update stuinfo <span class="keyword">set</span> borndate<span class="operator">=</span><span class="string">&#x27;1980-1-1&#x27;</span> <span class="keyword">where</span> stuid<span class="operator">=</span><span class="number">2</span>;   <span class="operator">/</span><span class="operator">/</span>修改</span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> stuinfo <span class="keyword">where</span> stuid<span class="operator">=</span><span class="number">1</span>;      <span class="operator">/</span><span class="operator">/</span>删除</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> stuinfo <span class="keyword">add</span> <span class="keyword">column</span> email <span class="type">varchar</span>(<span class="number">20</span>);       <span class="operator">/</span><span class="operator">/</span>增加表字段</span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> stuinfo;     <span class="operator">/</span><span class="operator">/</span>删表</span><br></pre></td></tr></table></figure>

<h1 id="SQL语言介绍"><a href="#SQL语言介绍" class="headerlink" title="SQL语言介绍"></a>SQL语言介绍</h1><ul>
<li>DDL（Data Definition Language）：数据定义语言，用来定义数据库对象：库、表、列等；</li>
<li>DML（Data Manipulation Language）：数据操作语言，用来定义数据库记录（数据）；</li>
<li>DCL（Data Control Language）：数据控制语言，用来定义访问权限和安全级别；</li>
<li>DQL（Data Query Language）：数据查询语言，用来查询记录（数据）。</li>
</ul>
<h1 id="基础查询"><a href="#基础查询" class="headerlink" title="基础查询"></a>基础查询</h1><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><p><code>select 查询列表 from 表名；</code><br>查询列表的结果集是一个虚拟表，select后面的查询列表可以有多个部分组成（字段、表达式、常量、函数等），逗号隔开，如：<br><code>select 字段1，字段2，表达式 from 表名；</code></p>
<h2 id="执行顺序"><a href="#执行顺序" class="headerlink" title="执行顺序"></a>执行顺序</h2><ol>
<li>from子句</li>
<li>select子句</li>
</ol>
<h2 id="起别名"><a href="#起别名" class="headerlink" title="起别名"></a>起别名</h2><ul>
<li>使用<code>as</code>关键字</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">USER</span>() <span class="keyword">AS</span> 用户名</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">USER</span>() <span class="keyword">AS</span> &quot;用户名&quot;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">USER</span>() <span class="keyword">AS</span> <span class="string">&#x27;用户名&#x27;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>使用空格</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">USER</span>()  用户名</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">USER</span>()  &quot;用户名&quot;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">USER</span>()  <span class="string">&#x27;用户名&#x27;</span></span><br></pre></td></tr></table></figure>

<h2 id="mysql中-作用"><a href="#mysql中-作用" class="headerlink" title="mysql中+作用"></a>mysql中<code>+</code>作用</h2><ol>
<li>两个操作数都是数值型，做加法</li>
<li>其中一个操作数为字符型，将字符型数据强制转换成数值型，如无法转换则当做<code>0</code>处理</li>
<li>其中一个操作数为<code>null</code>，结果为<code>null</code></li>
</ol>
<p><code>+</code>不能拼接2个字段，需使用<code>concat</code>拼接函数</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> CONCAT(first_name,last_name) <span class="keyword">AS</span> &quot;姓 名&quot;</span><br><span class="line"><span class="keyword">FROM</span> employees;</span><br></pre></td></tr></table></figure>

<h2 id="distinct"><a href="#distinct" class="headerlink" title="distinct"></a>distinct</h2><p>查询员工涉及到的部门编号有哪些？（重复出现的显示1个）</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> department_id <span class="keyword">FROM</span> employees;</span><br></pre></td></tr></table></figure>

<h2 id="查看表结构"><a href="#查看表结构" class="headerlink" title="查看表结构"></a>查看表结构</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DESC</span> employess;</span><br><span class="line"><span class="keyword">SHOW</span> COLUMNS <span class="keyword">FROM</span> employees;</span><br></pre></td></tr></table></figure>

<h2 id="ifnull-表达式1-表达式2"><a href="#ifnull-表达式1-表达式2" class="headerlink" title="ifnull(表达式1,表达式2)"></a>ifnull(表达式1,表达式2)</h2><p>表达式1：可能为null的字段或表达式<br>表达式2：如果表达式1为null，则最终结果显示的值</p>
<p>功能：如果表达式1为null，则显示表达式2，否则显示</p>
<h1 id="条件查询"><a href="#条件查询" class="headerlink" title="条件查询"></a>条件查询</h1><p>语法：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> 查询列表</span><br><span class="line"><span class="keyword">from</span>  表名</span><br><span class="line"><span class="keyword">where</span> 筛选条件;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> last_name,first_name </span><br><span class="line"><span class="keyword">from</span> employees </span><br><span class="line"><span class="keyword">where</span> salary<span class="operator">&gt;</span><span class="number">20000</span>;</span><br></pre></td></tr></table></figure>

<p>执行顺序：</p>
<ol>
<li>from子句</li>
<li>where子句</li>
<li>select子句</li>
</ol>
<p>特点：</p>
<ol>
<li>按关系表达式筛选<br>关系运算符：&gt;、&lt;、&gt;=、&lt;=、=、&lt;&gt;(补充：也可以使用!=,但不建议)     </li>
<li>按逻辑表达式筛选<br>逻辑运算符：and、or、not (补充：也可以使用&amp;&amp;  ||   !  ，但不建议)     </li>
<li>模糊查询<br>like、in、between and、is null</li>
</ol>
<h2 id="按关系表达式筛选"><a href="#按关系表达式筛选" class="headerlink" title="按关系表达式筛选"></a>按关系表达式筛选</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 案例1：查询部门编号不是100的员工信息</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> department_id <span class="operator">&lt;&gt;</span> <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 案例2：查询工资&lt;15000的姓名、工资</span></span><br><span class="line"><span class="keyword">SELECT</span> last_name,salary</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> salary<span class="operator">&lt;</span><span class="number">15000</span>;</span><br></pre></td></tr></table></figure>

<h2 id="按逻辑表达式筛选"><a href="#按逻辑表达式筛选" class="headerlink" title="按逻辑表达式筛选"></a>按逻辑表达式筛选</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 案例1：查询部门编号不是 50-100之间员工姓名、部门编号、邮箱</span></span><br><span class="line"><span class="comment">-- 方式1：</span></span><br><span class="line"><span class="keyword">SELECT</span> last_name,department_id,email</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> department_id <span class="operator">&lt;</span><span class="number">50</span> <span class="keyword">OR</span> department_id<span class="operator">&gt;</span><span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 方式2：</span></span><br><span class="line"><span class="keyword">SELECT</span> last_name,department_id,email</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">NOT</span>(department_id<span class="operator">&gt;=</span><span class="number">50</span> <span class="keyword">AND</span> department_id<span class="operator">&lt;=</span><span class="number">100</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 案例2：查询奖金率&gt;0.03 或者 员工编号在60-110之间的员工信息</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> commission_pct<span class="operator">&gt;</span><span class="number">0.03</span> <span class="keyword">OR</span> (employee_id <span class="operator">&gt;=</span><span class="number">60</span> <span class="keyword">AND</span> employee_id<span class="operator">&lt;=</span><span class="number">110</span>);</span><br></pre></td></tr></table></figure>

<h2 id="模糊查询"><a href="#模糊查询" class="headerlink" title="模糊查询"></a>模糊查询</h2><p>功能：一般和通配符搭配使用，对字符型数据进行部分匹配查询。<code>like/not like</code><br>常见的通配符：</p>
<ul>
<li><code>_</code> 任意单个字符</li>
<li><code>%</code> 任意多个字符,支持0-多个</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 案例1：查询姓名中包含字符a的员工信息</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> last_name <span class="keyword">LIKE</span> <span class="string">&#x27;%a%&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 案例2：查询姓名中包含最后一个字符为e的员工信息</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> last_name <span class="keyword">LIKE</span> <span class="string">&#x27;%e&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 案例3：查询姓名中包含第一个字符为e的员工信息</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> last_name <span class="keyword">LIKE</span> <span class="string">&#x27;e%&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 案例4：查询姓名中包含第三个字符为x的员工信息</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> last_name <span class="keyword">LIKE</span> <span class="string">&#x27;__x%&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 案例5：查询姓名中包含第二个字符为_的员工信息</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> last_name <span class="keyword">LIKE</span> <span class="string">&#x27;_\_%&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> last_name <span class="keyword">LIKE</span> <span class="string">&#x27;_$_%&#x27;</span> <span class="keyword">ESCAPE</span> <span class="string">&#x27;$&#x27;</span>; <span class="comment">-- 自定义转义字符为$</span></span><br></pre></td></tr></table></figure>

<h2 id="in查询"><a href="#in查询" class="headerlink" title="in查询"></a>in查询</h2><p>功能：查询某字段的值是否属于指定的列表之内<br><code>a  in(常量值1,常量值2,常量值3,...)</code><br><code>a not in(常量值1,常量值2,常量值3,...)</code></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 案例1：查询部门编号是30/50/90的员工名、部门编号</span></span><br><span class="line"><span class="comment">-- 方式1：</span></span><br><span class="line"><span class="keyword">SELECT</span> last_name,department_id</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> department_id <span class="keyword">IN</span>(<span class="number">30</span>,<span class="number">50</span>,<span class="number">90</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 方式2：</span></span><br><span class="line"><span class="keyword">SELECT</span> last_name,department_id</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> department_id <span class="operator">=</span> <span class="number">30</span></span><br><span class="line"><span class="keyword">OR</span> department_id <span class="operator">=</span> <span class="number">50</span></span><br><span class="line"><span class="keyword">OR</span> department_id <span class="operator">=</span> <span class="number">90</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 案例2：查询工种编号不是SH_CLERK或IT_PROG的员工信息</span></span><br><span class="line"><span class="comment">-- 方式1：</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> job_id <span class="keyword">NOT</span> <span class="keyword">IN</span>(<span class="string">&#x27;SH_CLERK&#x27;</span>,<span class="string">&#x27;IT_PROG&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 方式2：</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">NOT</span>(job_id <span class="operator">=</span><span class="string">&#x27;SH_CLERK&#x27;</span></span><br><span class="line"><span class="keyword">OR</span> job_id <span class="operator">=</span> <span class="string">&#x27;IT_PROG&#x27;</span>);</span><br></pre></td></tr></table></figure>

<h2 id="between-and"><a href="#between-and" class="headerlink" title="between and"></a>between and</h2><p>功能：判断某个字段的值是否介于xx之间<br><code>between and/not between and</code></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 案例1：查询部门编号是30-90之间的部门编号、员工姓名</span></span><br><span class="line"><span class="comment">-- 方式1：</span></span><br><span class="line"><span class="keyword">SELECT</span> department_id,last_name</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> department_id <span class="keyword">BETWEEN</span> <span class="number">30</span> <span class="keyword">AND</span> <span class="number">90</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 方式2：</span></span><br><span class="line"><span class="keyword">SELECT</span> department_id,last_name</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> department_id<span class="operator">&gt;=</span><span class="number">30</span> <span class="keyword">AND</span> department_id<span class="operator">&lt;=</span><span class="number">90</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 案例2：查询年薪不是100000-200000之间的员工姓名、工资、年薪</span></span><br><span class="line"><span class="comment">-- 方式1：</span></span><br><span class="line"><span class="keyword">SELECT</span> last_name,salary,salary<span class="operator">*</span><span class="number">12</span><span class="operator">*</span>(<span class="number">1</span><span class="operator">+</span>IFNULL(commission_pct,<span class="number">0</span>)) 年薪</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> salary<span class="operator">*</span><span class="number">12</span><span class="operator">*</span>(<span class="number">1</span><span class="operator">+</span>IFNULL(commission_pct,<span class="number">0</span>))<span class="operator">&lt;</span><span class="number">100000</span> <span class="keyword">OR</span> salary<span class="operator">*</span><span class="number">12</span><span class="operator">*</span>(<span class="number">1</span><span class="operator">+</span>IFNULL(commission_pct,<span class="number">0</span>))<span class="operator">&gt;</span><span class="number">200000</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 方式2：</span></span><br><span class="line"><span class="keyword">SELECT</span> last_name,salary,salary<span class="operator">*</span><span class="number">12</span><span class="operator">*</span>(<span class="number">1</span><span class="operator">+</span>IFNULL(commission_pct,<span class="number">0</span>)) 年薪</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> salary<span class="operator">*</span><span class="number">12</span><span class="operator">*</span>(<span class="number">1</span><span class="operator">+</span>IFNULL(commission_pct,<span class="number">0</span>)) <span class="keyword">NOT</span> <span class="keyword">BETWEEN</span> <span class="number">100000</span> <span class="keyword">AND</span> <span class="number">200000</span>;</span><br></pre></td></tr></table></figure>

<h2 id="is-null-is-not-null"><a href="#is-null-is-not-null" class="headerlink" title="is null/is not null"></a>is null/is not null</h2><ul>
<li><code>=</code>只能判断普通的内容</li>
<li><code>IS</code>只能判断NULL值</li>
<li><code>&lt;=&gt;</code>安全等于，既能判断普通内容，又能判断NULL值</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 案例1：查询没有奖金的员工信息</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> commission_pct <span class="keyword">IS</span> <span class="keyword">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 案例2：查询有奖金的员工信息</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> commission_pct <span class="keyword">IS</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 错误写法，报错</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> salary <span class="keyword">IS</span> <span class="number">10000</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 安全等于</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> salary <span class="operator">&lt;=&gt;</span> <span class="number">10000</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 安全等于</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> commission_pct <span class="operator">&lt;=&gt;</span> <span class="keyword">NULL</span>;</span><br></pre></td></tr></table></figure>

<h2 id="条件查询案例"><a href="#条件查询案例" class="headerlink" title="条件查询案例"></a>条件查询案例</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 1. 查询工资大于 12000 的员工姓名和工资</span></span><br><span class="line"><span class="keyword">SELECT</span> last_name,salary</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> salary<span class="operator">&gt;</span><span class="number">12000</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 2. 查询员工号为 176 的员工的姓名和部门号和年薪</span></span><br><span class="line"><span class="keyword">SELECT</span> last_name,department_id,salary<span class="operator">*</span><span class="number">12</span><span class="operator">*</span>(<span class="number">1</span><span class="operator">+</span>IFNULL(commission_pct,<span class="number">0</span>)) 年薪</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> employee_id  <span class="operator">=</span> <span class="number">176</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 3. 选择工资不在 5000 到 12000 的员工的姓名和工资</span></span><br><span class="line"><span class="keyword">SELECT</span> last_name,salary</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> salary <span class="keyword">NOT</span> <span class="keyword">BETWEEN</span> <span class="number">5000</span> <span class="keyword">AND</span> <span class="number">12000</span>;</span><br><span class="line"><span class="comment">-- 方式2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 4. 选择在 20 或 50 号部门工作的员工姓名和部门号</span></span><br><span class="line"><span class="keyword">SELECT</span> last_name,department_id</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> department_id <span class="keyword">IN</span> (<span class="number">20</span>,<span class="number">50</span>);</span><br><span class="line"><span class="comment">-- 方式2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 5. 选择公司中没有管理者的员工姓名及 job_id</span></span><br><span class="line"><span class="keyword">SELECT</span> last_name,job_id</span><br><span class="line"><span class="keyword">FROM</span> employees </span><br><span class="line"><span class="keyword">WHERE</span> manager_id <span class="keyword">IS</span> <span class="keyword">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 6. 选择公司中有奖金的员工姓名，工资和奖金率</span></span><br><span class="line"><span class="keyword">SELECT</span> last_name,salary,commission_pct</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> commission_pct <span class="keyword">IS</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 7. 选择员工姓名的第三个字母是 a 的员工姓名</span></span><br><span class="line"><span class="keyword">SELECT</span> last_name</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> last_name <span class="keyword">LIKE</span> <span class="string">&#x27;__a%&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 8. 选择姓名中有字母 a 和 e 的员工姓名</span></span><br><span class="line"><span class="keyword">SELECT</span> last_name</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> last_name <span class="keyword">LIKE</span> <span class="string">&#x27;%a%&#x27;</span>  <span class="keyword">AND</span>  last_name <span class="keyword">LIKE</span> <span class="string">&#x27;%e%&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 9. 显示出表 employees 表中 first_name 以 &#x27;e&#x27;结尾的员工信息</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> first_name <span class="keyword">LIKE</span> <span class="string">&#x27;%e&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 10. 显示出表 employees 部门编号在 80-100 之间 的姓名、职位</span></span><br><span class="line"><span class="keyword">SELECT</span> last_name,job_id</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> department_id <span class="keyword">BETWEEN</span> <span class="number">80</span> <span class="keyword">AND</span> <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 11. 显示出表 employees 的 manager_id 是 100,101,110 的员工姓名、职位</span></span><br><span class="line"><span class="keyword">SELECT</span> last_name,job_id</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> manager_id <span class="keyword">IN</span> (<span class="number">100</span>,<span class="number">101</span>,<span class="number">110</span>);</span><br></pre></td></tr></table></figure>

<h1 id="排序查询"><a href="#排序查询" class="headerlink" title="排序查询"></a>排序查询</h1><h2 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> 查询列表</span><br><span class="line"><span class="keyword">from</span> 表名</span><br><span class="line">【<span class="keyword">where</span> 筛选条件】</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> 排序列表</span><br></pre></td></tr></table></figure>

<h2 id="执行顺序："><a href="#执行顺序：" class="headerlink" title="执行顺序："></a>执行顺序：</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">① <span class="keyword">from</span> 子句</span><br><span class="line">② <span class="keyword">where</span> 子句</span><br><span class="line">③ <span class="keyword">select</span> 子句</span><br><span class="line">④ <span class="keyword">order</span> <span class="keyword">by</span> 子句</span><br></pre></td></tr></table></figure>

<h2 id="举例："><a href="#举例：" class="headerlink" title="举例："></a>举例：</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> last_name,salary</span><br><span class="line"><span class="keyword">from</span> employees</span><br><span class="line"><span class="keyword">where</span> salary<span class="operator">&gt;</span><span class="number">20000</span></span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> salary ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> employees;</span><br></pre></td></tr></table></figure>

<h2 id="特点："><a href="#特点：" class="headerlink" title="特点："></a>特点：</h2><ol>
<li>排序列表可以是单个字段、多个字段、表达式、函数、列数、以及以上的组合</li>
<li>升序 ，通过 asc   ，默认行为<br>降序 ，通过 desc</li>
</ol>
<h2 id="案例说明"><a href="#案例说明" class="headerlink" title="案例说明"></a>案例说明</h2><h3 id="按单个字段排序"><a href="#按单个字段排序" class="headerlink" title="按单个字段排序"></a>按单个字段排序</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 案例1：将员工编号&gt;120的员工信息进行工资的升序</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> </span><br><span class="line"><span class="keyword">FROM</span> employees </span><br><span class="line"><span class="keyword">WHERE</span> employee_id<span class="operator">&gt;</span><span class="number">120</span> </span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> salary ;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 案例1：将员工编号&gt;120的员工信息进行工资的降序</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> </span><br><span class="line"><span class="keyword">FROM</span> employees </span><br><span class="line"><span class="keyword">WHERE</span> employee_id<span class="operator">&gt;</span><span class="number">120</span> </span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> salary <span class="keyword">DESC</span>;</span><br></pre></td></tr></table></figure>

<h3 id="按表达式排序"><a href="#按表达式排序" class="headerlink" title="按表达式排序"></a>按表达式排序</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 案例1：对有奖金的员工，按年薪降序</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span>,salary<span class="operator">*</span><span class="number">12</span><span class="operator">*</span>(<span class="number">1</span><span class="operator">+</span>IFNULL(commission_pct,<span class="number">0</span>))  年薪</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> commission_pct <span class="keyword">IS</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> salary<span class="operator">*</span><span class="number">12</span><span class="operator">*</span>(<span class="number">1</span><span class="operator">+</span>IFNULL(commission_pct,<span class="number">0</span>)) <span class="keyword">DESC</span>;</span><br></pre></td></tr></table></figure>

<h3 id="按别名排序"><a href="#按别名排序" class="headerlink" title="按别名排序"></a>按别名排序</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 案例1：对有奖金的员工，按年薪降序</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span>,salary<span class="operator">*</span><span class="number">12</span><span class="operator">*</span>(<span class="number">1</span><span class="operator">+</span>IFNULL(commission_pct,<span class="number">0</span>))  年薪</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> commission_pct <span class="keyword">IS</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> 年薪 <span class="keyword">DESC</span>;</span><br></pre></td></tr></table></figure>

<h3 id="按函数的结果排序"><a href="#按函数的结果排序" class="headerlink" title="按函数的结果排序"></a>按函数的结果排序</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 案例1：按姓名的字数长度进行升序</span></span><br><span class="line"><span class="keyword">SELECT</span> last_name</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> LENGTH(last_name);</span><br></pre></td></tr></table></figure>

<h3 id="按多个字段排序"><a href="#按多个字段排序" class="headerlink" title="按多个字段排序"></a>按多个字段排序</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 案例1：查询员工的姓名、工资、部门编号，先按工资升序，再按部门编号降序</span></span><br><span class="line"><span class="keyword">SELECT</span> last_name,salary,department_id</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> salary <span class="keyword">ASC</span>,department_id <span class="keyword">DESC</span>;</span><br></pre></td></tr></table></figure>

<h3 id="补充选学：按列数排序"><a href="#补充选学：按列数排序" class="headerlink" title="补充选学：按列数排序"></a>补充选学：按列数排序</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> employees </span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="number">2</span> <span class="keyword">DESC</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> employees </span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> first_name;</span><br></pre></td></tr></table></figure>

<h1 id="常见函数"><a href="#常见函数" class="headerlink" title="常见函数"></a>常见函数</h1><ul>
<li>字符函数</li>
<li>数学函数</li>
<li>日期函数</li>
<li>流程控制函数</li>
</ul>
<p>函数：类似于java中学过的“方法”，为了解决某个问题，将编写的一系列的命令集合封装在一起，对外仅仅暴露方法名，供外部调用</p>
<ol>
<li>自定义方法(函数)</li>
<li>调用方法(函数)<ul>
<li>叫什么  ：函数名</li>
<li>干什么  ：函数功能</li>
</ul>
</li>
</ol>
<h2 id="字符函数"><a href="#字符函数" class="headerlink" title="字符函数"></a>字符函数</h2><ol>
<li>CONCAT 拼接字符</li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> CONCAT(<span class="string">&#x27;hello,&#x27;</span>,first_name,last_name)  备注 <span class="keyword">FROM</span> employees;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>LENGTH 获取字节长度</li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> LENGTH(<span class="string">&#x27;hello,郭襄&#x27;</span>);</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>CHAR_LENGTH 获取字符个数</li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">CHAR_LENGTH</span>(<span class="string">&#x27;hello,郭襄&#x27;</span>);</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>SUBSTRING 截取子串</li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">注意：起始索引从1开始！！！</span></span><br><span class="line"><span class="comment">substr(str,起始索引，截取的字符长度)</span></span><br><span class="line"><span class="comment">substr(str,起始索引)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">SELECT</span> SUBSTR(<span class="string">&#x27;张三丰爱上了郭襄&#x27;</span>,<span class="number">1</span>,<span class="number">3</span>);</span><br><span class="line"><span class="keyword">SELECT</span> SUBSTR(<span class="string">&#x27;张三丰爱上了郭襄&#x27;</span>,<span class="number">7</span>);</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>INSTR获取字符第一次出现的索引</li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> INSTR(<span class="string">&#x27;三打白骨精aaa白骨精bb白骨精&#x27;</span>,<span class="string">&#x27;白骨精&#x27;</span>);</span><br></pre></td></tr></table></figure>

<ol start="6">
<li>TRIM去前后指定的字符，默认是去空格</li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">TRIM</span>(<span class="string">&#x27; 虚  竹    &#x27;</span>)  <span class="keyword">AS</span> a;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">TRIM</span>(<span class="string">&#x27;x&#x27;</span> <span class="keyword">FROM</span> <span class="string">&#x27;xxxxxx虚xxx竹xxxxxxxxxxxxxxxxxx&#x27;</span>)  <span class="keyword">AS</span> a;</span><br></pre></td></tr></table></figure>

<ol start="7">
<li>LPAD/RPAD  左填充/右填充</li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> LPAD(<span class="string">&#x27;木婉清&#x27;</span>,<span class="number">10</span>,<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line"><span class="keyword">SELECT</span> RPAD(<span class="string">&#x27;木婉清&#x27;</span>,<span class="number">10</span>,<span class="string">&#x27;a&#x27;</span>);</span><br></pre></td></tr></table></figure>

<ol start="8">
<li>UPPER/LOWER  变大写/变小写</li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 案例：查询员工表的姓名，要求格式：姓首字符大写，其他字符小写，名所有字符大写，且姓和名之间用_分割，最后起别名“OUTPUT”</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">UPPER</span>(SUBSTR(first_name,<span class="number">1</span>,<span class="number">1</span>)),first_name <span class="keyword">FROM</span> employees;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">LOWER</span>(SUBSTR(first_name,<span class="number">2</span>)),first_name <span class="keyword">FROM</span> employees;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">UPPER</span>(last_name) <span class="keyword">FROM</span> employees;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> CONCAT(<span class="built_in">UPPER</span>(SUBSTR(first_name,<span class="number">1</span>,<span class="number">1</span>)),<span class="built_in">LOWER</span>(SUBSTR(first_name,<span class="number">2</span>)),<span class="string">&#x27;_&#x27;</span>,<span class="built_in">UPPER</span>(last_name)) &quot;OUTPUT&quot;</span><br><span class="line"><span class="keyword">FROM</span> employees;</span><br></pre></td></tr></table></figure>

<ol start="9">
<li>STRCMP 比较两个字符大小</li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> STRCMP(<span class="string">&#x27;aec&#x27;</span>,<span class="string">&#x27;aec&#x27;</span>);</span><br></pre></td></tr></table></figure>

<ol start="10">
<li>LEFT/RIGHT  截取子串</li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">LEFT</span>(<span class="string">&#x27;鸠摩智&#x27;</span>,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">RIGHT</span>(<span class="string">&#x27;鸠摩智&#x27;</span>,<span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<h2 id="数学函数"><a href="#数学函数" class="headerlink" title="数学函数"></a>数学函数</h2><ol>
<li>ABS 绝对值</li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">ABS</span>(<span class="number">-2.4</span>);</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>CEIL 向上取整  返回&gt;=该参数的最小整数</li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">CEIL</span>(<span class="number">-1.09</span>);</span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">CEIL</span>(<span class="number">0.09</span>);</span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">CEIL</span>(<span class="number">1.00</span>);</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>FLOOR 向下取整，返回&lt;=该参数的最大整数</li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">FLOOR</span>(<span class="number">-1.09</span>);</span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">FLOOR</span>(<span class="number">0.09</span>);</span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">FLOOR</span>(<span class="number">1.00</span>);</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>ROUND 四舍五入</li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> ROUND(<span class="number">1.8712345</span>);</span><br><span class="line"><span class="keyword">SELECT</span> ROUND(<span class="number">1.8712345</span>,<span class="number">2</span>);</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>TRUNCATE 截断</li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">TRUNCATE</span>(<span class="number">1.8712345</span>,<span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<ol start="6">
<li>MOD 取余</li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">MOD</span>(<span class="number">-10</span>,<span class="number">3</span>);</span><br><span class="line">a<span class="operator">%</span>b <span class="operator">=</span> a<span class="operator">-</span>(<span class="type">INT</span>)a<span class="operator">/</span>b<span class="operator">*</span>b</span><br><span class="line"><span class="number">-10</span><span class="operator">%</span><span class="number">3</span> <span class="operator">=</span> <span class="number">-10</span> <span class="operator">-</span> (<span class="number">-10</span>)<span class="operator">/</span><span class="number">3</span><span class="operator">*</span><span class="number">3</span>   <span class="operator">=</span> <span class="number">-1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="number">-10</span><span class="operator">%</span><span class="number">3</span>;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="number">10</span><span class="operator">%</span><span class="number">3</span>;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="number">-10</span><span class="operator">%</span><span class="number">-3</span>;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="number">10</span><span class="operator">%</span><span class="number">-3</span>;</span><br></pre></td></tr></table></figure>

<h2 id="日期函数"><a href="#日期函数" class="headerlink" title="日期函数"></a>日期函数</h2><ol>
<li>NOW</li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> NOW();</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>CURDATE</li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> CURDATE();</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>CURTIME</li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> CURTIME();</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>DATEDIFF</li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> DATEDIFF(<span class="string">&#x27;1998-7-16&#x27;</span>,<span class="string">&#x27;2019-7-13&#x27;</span>);</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>DATE_FORMAT</li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> DATE_FORMAT(<span class="string">&#x27;1998-7-16&#x27;</span>,<span class="string">&#x27;%Y年%M月%d日 %H小时%i分钟%s秒&#x27;</span>) 出生日期;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> DATE_FORMAT(hiredate,<span class="string">&#x27;%Y年%M月%d日 %H小时%i分钟%s秒&#x27;</span>)入职日期 </span><br><span class="line"><span class="keyword">FROM</span> employees;</span><br></pre></td></tr></table></figure>


<ol start="6">
<li>STR_TO_DATE 按指定格式解析字符串为日期类型</li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> hiredate<span class="operator">&lt;</span>STR_TO_DATE(<span class="string">&#x27;3/15 1998&#x27;</span>,<span class="string">&#x27;%m/%d %Y&#x27;</span>);</span><br></pre></td></tr></table></figure>

<h2 id="流程控制函数"><a href="#流程控制函数" class="headerlink" title="流程控制函数"></a>流程控制函数</h2><ol>
<li>IF函数</li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> IF(<span class="number">100</span><span class="operator">&gt;</span><span class="number">9</span>,<span class="string">&#x27;好&#x27;</span>,<span class="string">&#x27;坏&#x27;</span>);  <span class="comment">-- 类似三目运算符</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 需求：如果有奖金，则显示最终奖金，如果没有，则显示0</span></span><br><span class="line"><span class="keyword">SELECT</span> IF(commission_pct <span class="keyword">IS</span> <span class="keyword">NULL</span>,<span class="number">0</span>,salary<span class="operator">*</span><span class="number">12</span><span class="operator">*</span>commission_pct)  奖金,commission_pct</span><br><span class="line"><span class="keyword">FROM</span> employees;</span><br></pre></td></tr></table></figure>


<ol start="2">
<li>CASE函数</li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 情况1 ：类似于switch语句，可以实现等值判断</span></span><br><span class="line"><span class="keyword">CASE</span> 表达式</span><br><span class="line"><span class="keyword">WHEN</span> 值<span class="number">1</span> <span class="keyword">THEN</span> 结果<span class="number">1</span></span><br><span class="line"><span class="keyword">WHEN</span> 值<span class="number">2</span> <span class="keyword">THEN</span> 结果<span class="number">2</span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">ELSE</span> 结果n</span><br><span class="line"><span class="keyword">END</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">案例：</span></span><br><span class="line"><span class="comment">部门编号是30，工资显示为2倍</span></span><br><span class="line"><span class="comment">部门编号是50，工资显示为3倍</span></span><br><span class="line"><span class="comment">部门编号是60，工资显示为4倍</span></span><br><span class="line"><span class="comment">否则不变</span></span><br><span class="line"><span class="comment">显示 部门编号，新工资，旧工资</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> department_id,salary,</span><br><span class="line"><span class="keyword">CASE</span> department_id</span><br><span class="line"><span class="keyword">WHEN</span> <span class="number">30</span> <span class="keyword">THEN</span> salary<span class="operator">*</span><span class="number">2</span></span><br><span class="line"><span class="keyword">WHEN</span> <span class="number">50</span> <span class="keyword">THEN</span> salary<span class="operator">*</span><span class="number">3</span></span><br><span class="line"><span class="keyword">WHEN</span> <span class="number">60</span> <span class="keyword">THEN</span> salary<span class="operator">*</span><span class="number">4</span></span><br><span class="line"><span class="keyword">ELSE</span> salary</span><br><span class="line"><span class="keyword">END</span>  newSalary</span><br><span class="line"><span class="keyword">FROM</span> employees;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 情况2：类似于多重IF语句，实现区间判断</span></span><br><span class="line"><span class="keyword">CASE</span> </span><br><span class="line"><span class="keyword">WHEN</span> 条件<span class="number">1</span> <span class="keyword">THEN</span> 结果<span class="number">1</span></span><br><span class="line"><span class="keyword">WHEN</span> 条件<span class="number">2</span> <span class="keyword">THEN</span> 结果<span class="number">2</span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">ELSE</span> 结果n</span><br><span class="line"><span class="keyword">END</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">案例：如果工资&gt;20000,显示级别A</span></span><br><span class="line"><span class="comment">      工资&gt;15000,显示级别B</span></span><br><span class="line"><span class="comment">      工资&gt;10000,显示级别C</span></span><br><span class="line"><span class="comment">      否则，显示D</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> salary,</span><br><span class="line"><span class="keyword">CASE</span> </span><br><span class="line"><span class="keyword">WHEN</span> salary<span class="operator">&gt;</span><span class="number">20000</span> <span class="keyword">THEN</span> <span class="string">&#x27;A&#x27;</span></span><br><span class="line"><span class="keyword">WHEN</span> salary<span class="operator">&gt;</span><span class="number">15000</span> <span class="keyword">THEN</span> <span class="string">&#x27;B&#x27;</span></span><br><span class="line"><span class="keyword">WHEN</span> salary<span class="operator">&gt;</span><span class="number">10000</span> <span class="keyword">THEN</span> <span class="string">&#x27;C&#x27;</span></span><br><span class="line"><span class="keyword">ELSE</span> <span class="string">&#x27;D&#x27;</span></span><br><span class="line"><span class="keyword">END</span></span><br><span class="line"><span class="keyword">AS</span>  a</span><br><span class="line"><span class="keyword">FROM</span> employees;   </span><br></pre></td></tr></table></figure>

<h2 id="案例讲解"><a href="#案例讲解" class="headerlink" title="案例讲解"></a>案例讲解</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">-- 1. 显示系统时间(注：日期+时间)</span></span><br><span class="line"><span class="keyword">SELECT</span> NOW();</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 2. 查询员工号，姓名，工资，以及工资提高百分之 20%后的结果（new salary）</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> employee_id,last_name,salary,salary<span class="operator">*</span><span class="number">1.2</span> &quot;new salary&quot;</span><br><span class="line"><span class="keyword">FROM</span> employees;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 3. 将员工的姓名按首字母排序，并写出姓名的长度（length）</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> LENGTH(last_name) 长度</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> SUBSTR(last_name,<span class="number">1</span>,<span class="number">1</span>) <span class="keyword">ASC</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 4. 做一个查询，产生下面的结果</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">&lt;last_name&gt; earns &lt;salary&gt; monthly but wants &lt;salary*3&gt;</span></span><br><span class="line"><span class="comment">          Dream Salary</span></span><br><span class="line"><span class="comment">King earns 24000 monthly but wants 72000</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> CONCAT(last_name,<span class="string">&#x27; earns &#x27;</span>,salary,<span class="string">&#x27; monthly but wants &#x27;</span>,salary<span class="operator">*</span><span class="number">3</span>)  &quot;Dream Salary&quot;</span><br><span class="line"><span class="keyword">FROM</span> employees;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 5. 使用 case-when，按照下面的条件：</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">job     grade</span></span><br><span class="line"><span class="comment">AD_PRES  A</span></span><br><span class="line"><span class="comment">ST_MAN   B</span></span><br><span class="line"><span class="comment">IT_PROG  C</span></span><br><span class="line"><span class="comment">SA_REP   D</span></span><br><span class="line"><span class="comment">ST_CLERK E</span></span><br><span class="line"><span class="comment">产生下面的结果</span></span><br><span class="line"><span class="comment">Last_name Job_id    Grade</span></span><br><span class="line"><span class="comment">king      AD_PRES   A</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> last_name,job_id,</span><br><span class="line"><span class="keyword">CASE</span> job_id</span><br><span class="line"><span class="keyword">WHEN</span> <span class="string">&#x27;AD_PRES&#x27;</span>  <span class="keyword">THEN</span> <span class="string">&#x27;A&#x27;</span></span><br><span class="line"><span class="keyword">WHEN</span> <span class="string">&#x27;ST_MAN&#x27;</span>  <span class="keyword">THEN</span> <span class="string">&#x27;B&#x27;</span></span><br><span class="line"><span class="keyword">WHEN</span> <span class="string">&#x27;IT_PROG&#x27;</span>  <span class="keyword">THEN</span> <span class="string">&#x27;C&#x27;</span></span><br><span class="line"><span class="keyword">WHEN</span> <span class="string">&#x27;SA_REP&#x27;</span>  <span class="keyword">THEN</span> <span class="string">&#x27;D&#x27;</span></span><br><span class="line"><span class="keyword">WHEN</span> <span class="string">&#x27;ST_CLERK&#x27;</span>  <span class="keyword">THEN</span> <span class="string">&#x27;E&#x27;</span></span><br><span class="line"><span class="keyword">END</span> Grade</span><br><span class="line"><span class="keyword">FROM</span> employees;</span><br></pre></td></tr></table></figure>

<h2 id="聚合函数"><a href="#聚合函数" class="headerlink" title="聚合函数"></a>聚合函数</h2><p>说明：分组函数往往用于实现将一组数据进行统计计算，最终得到一个值，又称为聚合函数或统计函数</p>
<p>分组函数清单：</p>
<ul>
<li>sum(字段名)：求和，参数只能是数值型</li>
<li>avg(字段名)：求平均数，参数只能是数值型</li>
<li>max(字段名)：求最大值</li>
<li>min(字段名)：求最小值</li>
<li>count(字段名)：计算非空字段值的个数</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 案例1 ：查询员工信息表中，所有员工的工资和、工资平均值、最低工资、最高工资、有工资的个数</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">SUM</span>(salary),<span class="built_in">AVG</span>(salary),<span class="built_in">MIN</span>(salary),<span class="built_in">MAX</span>(salary),<span class="built_in">COUNT</span>(salary) <span class="keyword">FROM</span> employees;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 案例2：添加筛选条件</span></span><br><span class="line"><span class="comment">-- 查询emp表中记录数：</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(employee_id) <span class="keyword">FROM</span> employees;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询emp表中有佣金的人数：</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(salary) <span class="keyword">FROM</span> employees;</span><br><span class="line">	</span><br><span class="line"><span class="comment">-- 查询emp表中月薪大于2500的人数：</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(salary) <span class="keyword">FROM</span> employees <span class="keyword">WHERE</span> salary<span class="operator">&gt;</span><span class="number">2500</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询有领导的人数：</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(manager_id) <span class="keyword">FROM</span> employees;</span><br><span class="line">	</span><br><span class="line"><span class="comment">-- count的补充介绍★</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 1、统计结果集的行数，推荐使用count(*)</span></span><br><span class="line">	</span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">FROM</span> employees;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">FROM</span> employees <span class="keyword">WHERE</span> department_id <span class="operator">=</span> <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="number">1</span>) <span class="keyword">FROM</span> employees;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="number">1</span>) <span class="keyword">FROM</span> employees <span class="keyword">WHERE</span> department_id <span class="operator">=</span> <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 2、搭配distinct实现去重的统计</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 需求：查询有员工的部门个数</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="keyword">DISTINCT</span> department_id) <span class="keyword">FROM</span> employees;</span><br><span class="line"><span class="comment">-- 思考：每个部门的总工资、平均工资？</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">SUM</span>(salary)  <span class="keyword">FROM</span> employees <span class="keyword">WHERE</span> department_id <span class="operator">=</span> <span class="number">30</span>;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">SUM</span>(salary)  <span class="keyword">FROM</span> employees <span class="keyword">WHERE</span> department_id <span class="operator">=</span> <span class="number">50</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">SUM</span>(salary) ,department_id</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> department_id;</span><br></pre></td></tr></table></figure>

<h1 id="分组查询"><a href="#分组查询" class="headerlink" title="分组查询"></a>分组查询</h1><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><p>查询列表往往是分组（聚合）函数和被分组的字段 ★<br>分组查询中的筛选分为两类</p>
<table>
<thead>
<tr>
<th></th>
<th>筛选的基表</th>
<th>使用的关键词</th>
<th>位置</th>
</tr>
</thead>
<tbody><tr>
<td>分组前筛选</td>
<td>原始表</td>
<td>where</td>
<td>group by 前面</td>
</tr>
<tr>
<td>分组后筛选</td>
<td>分组后的结果集</td>
<td>having</td>
<td>group by 后面</td>
</tr>
</tbody></table>
<p>顺序：where —— group by —— having<br>分组函数做条件只可能放在having后面！！！</p>
<h2 id="简单的分组"><a href="#简单的分组" class="headerlink" title="简单的分组"></a>简单的分组</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 案例1：查询每个工种的员工平均工资</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">AVG</span>(salary),job_id</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> job_id;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 案例2：查询每个领导的手下人数</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>),manager_id</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> manager_id <span class="keyword">IS</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> manager_id;</span><br></pre></td></tr></table></figure>

<h2 id="可以实现分组前的筛选"><a href="#可以实现分组前的筛选" class="headerlink" title="可以实现分组前的筛选"></a>可以实现分组前的筛选</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 案例1：查询邮箱中包含a字符的 每个部门的最高工资</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">MAX</span>(salary) 最高工资,department_id</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> email <span class="keyword">LIKE</span> <span class="string">&#x27;%a%&#x27;</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> department_id;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 案例2：查询每个领导手下有奖金的员工的平均工资</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">AVG</span>(salary) 平均工资,manager_id</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> commission_pct <span class="keyword">IS</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> manager_id;</span><br></pre></td></tr></table></figure>

<h2 id="可以实现分组后的筛选"><a href="#可以实现分组后的筛选" class="headerlink" title="可以实现分组后的筛选"></a>可以实现分组后的筛选</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 案例1：查询哪个部门的员工个数&gt;5</span></span><br><span class="line"><span class="comment">-- 分析1：查询每个部门的员工个数</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) 员工个数,department_id</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> department_id</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 分析2：在刚才的结果基础上，筛选哪个部门的员工个数&gt;5</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) 员工个数,department_id</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> department_id</span><br><span class="line"><span class="keyword">HAVING</span>  <span class="built_in">COUNT</span>(<span class="operator">*</span>)<span class="operator">&gt;</span><span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 案例2：每个工种有奖金的员工的最高工资&gt;12000的工种编号和最高工资</span></span><br><span class="line"><span class="keyword">SELECT</span> job_id,<span class="built_in">MAX</span>(salary)</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> commission_pct  <span class="keyword">IS</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> job_id</span><br><span class="line"><span class="keyword">HAVING</span> <span class="built_in">MAX</span>(salary)<span class="operator">&gt;</span><span class="number">12000</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 案例3：领导编号&gt;102的    每个领导手下的最低工资大于5000的最低工资</span></span><br><span class="line"><span class="comment">-- 分析1：查询每个领导手下员工的最低工资</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">MIN</span>(salary) 最低工资,manager_id</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> manager_id;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 分析2：筛选刚才1的结果</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">MIN</span>(salary) 最低工资,manager_id</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> manager_id<span class="operator">&gt;</span><span class="number">102</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> manager_id</span><br><span class="line"><span class="keyword">HAVING</span> <span class="built_in">MIN</span>(salary)<span class="operator">&gt;</span><span class="number">5000</span> ;</span><br></pre></td></tr></table></figure>

<h2 id="可以实现排序"><a href="#可以实现排序" class="headerlink" title="可以实现排序"></a>可以实现排序</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 案例：查询没有奖金的员工的最高工资&gt;6000的工种编号和最高工资,按最高工资升序</span></span><br><span class="line"><span class="comment">-- 分析1：按工种分组，查询每个工种有奖金的员工的最高工资</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">MAX</span>(salary) 最高工资,job_id</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> commission_pct <span class="keyword">IS</span>  <span class="keyword">NULL</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> job_id</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 分析2：筛选刚才的结果，看哪个最高工资&gt;6000</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">MAX</span>(salary) 最高工资,job_id</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> commission_pct <span class="keyword">IS</span>  <span class="keyword">NULL</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> job_id</span><br><span class="line"><span class="keyword">HAVING</span> <span class="built_in">MAX</span>(salary)<span class="operator">&gt;</span><span class="number">6000</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 分析3：按最高工资升序</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">MAX</span>(salary) 最高工资,job_id</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> commission_pct <span class="keyword">IS</span>  <span class="keyword">NULL</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> job_id</span><br><span class="line"><span class="keyword">HAVING</span> <span class="built_in">MAX</span>(salary)<span class="operator">&gt;</span><span class="number">6000</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="built_in">MAX</span>(salary) <span class="keyword">ASC</span>;</span><br></pre></td></tr></table></figure>

<h2 id="按多个字段分组"><a href="#按多个字段分组" class="headerlink" title="按多个字段分组"></a>按多个字段分组</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 案例：查询每个工种每个部门的最低工资,并按最低工资降序</span></span><br><span class="line"><span class="comment">-- 提示：工种和部门都一样，才是一组</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">MIN</span>(salary) 最低工资,job_id,department_id</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> job_id,department_id;</span><br></pre></td></tr></table></figure>

<h1 id="连接查询"><a href="#连接查询" class="headerlink" title="连接查询"></a>连接查询</h1><p>说明：又称多表查询，当查询语句涉及到的字段来自于多个表时，就会用到连接查询</p>
<p><strong>笛卡尔乘积现象</strong>：表1 有m行，表2有n行，结果=m*n行<br>发生原因：没有有效的连接条件<br>如何避免：添加有效的连接条件</p>
<h2 id="分类："><a href="#分类：" class="headerlink" title="分类："></a>分类：</h2><h3 id="按年代分类："><a href="#按年代分类：" class="headerlink" title="按年代分类："></a>按年代分类：</h3><ol>
<li>sql92标准：仅仅支持内连接（等值连接、非等值连接、自连接）</li>
<li>sql99标准【推荐】：支持内连接 + 外连接（左外和右外）+ 交叉连接</li>
</ol>
<h3 id="按功能分类："><a href="#按功能分类：" class="headerlink" title="按功能分类："></a>按功能分类：</h3><ol>
<li>内连接：等值连接、非等值连接、自连接</li>
<li>外连接：左外连接、右外连接、全外连接</li>
<li>交叉连接</li>
</ol>
<h2 id="sql-92标准"><a href="#sql-92标准" class="headerlink" title="sql-92标准"></a>sql-92标准</h2><h3 id="内连接"><a href="#内连接" class="headerlink" title="内连接"></a>内连接</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">语法:</span><br><span class="line"><span class="keyword">select</span> 查询列表</span><br><span class="line"><span class="keyword">from</span> 表<span class="number">1</span> 别名,表<span class="number">2</span> 别名</span><br><span class="line"><span class="keyword">where</span> 连接条件</span><br><span class="line"><span class="keyword">and</span> 筛选条件</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> 分组列表</span><br><span class="line"><span class="keyword">having</span> 分组后筛选</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> 排序列表</span><br><span class="line"></span><br><span class="line">执行顺序：</span><br><span class="line"></span><br><span class="line"><span class="number">1</span>、<span class="keyword">from</span>子句</span><br><span class="line"><span class="number">2</span>、<span class="keyword">where</span>子句</span><br><span class="line"><span class="number">3</span>、<span class="keyword">and</span>子句</span><br><span class="line"><span class="number">4</span>、<span class="keyword">group</span> <span class="keyword">by</span>子句</span><br><span class="line"><span class="number">5</span>、<span class="keyword">having</span>子句</span><br><span class="line"><span class="number">6</span>、<span class="keyword">select</span>子句</span><br><span class="line"><span class="number">7</span>、<span class="keyword">order</span> <span class="keyword">by</span>子句</span><br></pre></td></tr></table></figure>

<h4 id="等值连接"><a href="#等值连接" class="headerlink" title="等值连接"></a>等值连接</h4><ol>
<li>多表等值连接的结果为多表的交集部分</li>
<li>n表连接，至少需要n-1个连接条件</li>
<li>多表的顺序没有要求</li>
<li>一般需要为表起别名</li>
<li>可以搭配前面介绍的所有子句使用，比如排序、分组、筛选</li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 案例1：查询女神名和对应的男神名</span></span><br><span class="line"><span class="keyword">SELECT</span> NAME,boyName </span><br><span class="line"><span class="keyword">FROM</span> boys,beauty</span><br><span class="line"><span class="keyword">WHERE</span> beauty.boyfriend_id<span class="operator">=</span> boys.id;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 案例2：查询员工名和对应的部门名</span></span><br><span class="line"><span class="keyword">SELECT</span> last_name,department_name</span><br><span class="line"><span class="keyword">FROM</span> employees,departments</span><br><span class="line"><span class="keyword">WHERE</span> employees.`department_id`<span class="operator">=</span>departments.`department_id`;</span><br></pre></td></tr></table></figure>

<p>为表起别名:<br>注意：如果为表起了别名，则查询的字段就不能使用原来的表名去限定</p>
<ol>
<li>提高语句的简洁度</li>
<li>区分多个重名的字段</li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 查询员工名、工种号、工种名</span></span><br><span class="line"><span class="keyword">SELECT</span> e.last_name,e.job_id,j.job_title</span><br><span class="line"><span class="keyword">FROM</span> employees  e,jobs j</span><br><span class="line"><span class="keyword">WHERE</span> e.`job_id`<span class="operator">=</span>j.`job_id`;</span><br></pre></td></tr></table></figure>

<p>两个表的顺序可以调换</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 查询员工名、工种号、工种名</span></span><br><span class="line"><span class="keyword">SELECT</span> e.last_name,e.job_id,j.job_title</span><br><span class="line"><span class="keyword">FROM</span> jobs j,employees e</span><br><span class="line"><span class="keyword">WHERE</span> e.`job_id`<span class="operator">=</span>j.`job_id`;</span><br></pre></td></tr></table></figure>

<p>可以加筛选</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 案例：查询有奖金的员工名、部门名</span></span><br><span class="line"><span class="keyword">SELECT</span> last_name,department_name,commission_pct</span><br><span class="line"><span class="keyword">FROM</span> employees e,departments d</span><br><span class="line"><span class="keyword">WHERE</span> e.`department_id`<span class="operator">=</span>d.`department_id`</span><br><span class="line"><span class="keyword">AND</span> e.`commission_pct` <span class="keyword">IS</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 案例2：查询城市名中第二个字符为o的部门名和城市名</span></span><br><span class="line"><span class="keyword">SELECT</span> department_name,city</span><br><span class="line"><span class="keyword">FROM</span> departments d,locations l</span><br><span class="line"><span class="keyword">WHERE</span> d.`location_id` <span class="operator">=</span> l.`location_id`</span><br><span class="line"><span class="keyword">AND</span> city <span class="keyword">LIKE</span> <span class="string">&#x27;_o%&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>可以加分组</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 案例1：查询每个城市的部门个数</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) 个数,city</span><br><span class="line"><span class="keyword">FROM</span> departments d,locations l</span><br><span class="line"><span class="keyword">WHERE</span> d.`location_id`<span class="operator">=</span>l.`location_id`</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> city;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 案例2：查询有奖金的每个部门的部门名和部门的领导编号和该部门的最低工资</span></span><br><span class="line"><span class="keyword">SELECT</span> department_name,d.`manager_id`,<span class="built_in">MIN</span>(salary)</span><br><span class="line"><span class="keyword">FROM</span> departments d,employees e</span><br><span class="line"><span class="keyword">WHERE</span> d.`department_id`<span class="operator">=</span>e.`department_id`</span><br><span class="line"><span class="keyword">AND</span> commission_pct <span class="keyword">IS</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> department_name,d.`manager_id`;</span><br></pre></td></tr></table></figure>

<p>可以加排序</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 案例：查询每个工种的工种名和员工的个数，并且按员工个数降序</span></span><br><span class="line"><span class="keyword">SELECT</span> job_title,<span class="built_in">COUNT</span>(<span class="operator">*</span>)</span><br><span class="line"><span class="keyword">FROM</span> employees e,jobs j</span><br><span class="line"><span class="keyword">WHERE</span> e.`job_id`<span class="operator">=</span>j.`job_id`</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> job_title</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">DESC</span>;</span><br></pre></td></tr></table></figure>

<p>可以实现三表连接</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 案例：查询员工名、部门名和所在的城市</span></span><br><span class="line"><span class="keyword">SELECT</span> last_name,department_name,city</span><br><span class="line"><span class="keyword">FROM</span> employees e,departments d,locations l</span><br><span class="line"><span class="keyword">WHERE</span> e.`department_id`<span class="operator">=</span>d.`department_id`</span><br><span class="line"><span class="keyword">AND</span> d.`location_id`<span class="operator">=</span>l.`location_id`</span><br><span class="line"><span class="keyword">AND</span> city <span class="keyword">LIKE</span> <span class="string">&#x27;s%&#x27;</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> department_name <span class="keyword">DESC</span>;</span><br></pre></td></tr></table></figure>

<h4 id="非等值连接"><a href="#非等值连接" class="headerlink" title="非等值连接"></a>非等值连接</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 案例1：查询员工的工资和工资级别</span></span><br><span class="line"><span class="keyword">SELECT</span> salary,grade_level</span><br><span class="line"><span class="keyword">FROM</span> employees e,job_grades g</span><br><span class="line"><span class="keyword">WHERE</span> salary <span class="keyword">BETWEEN</span> g.`lowest_sal` <span class="keyword">AND</span> g.`highest_sal`</span><br><span class="line"><span class="keyword">AND</span> g.`grade_level`<span class="operator">=</span><span class="string">&#x27;A&#x27;</span>;</span><br></pre></td></tr></table></figure>

<h4 id="自连接"><a href="#自连接" class="headerlink" title="自连接"></a>自连接</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 案例：查询 员工名和上级的名称</span></span><br><span class="line"><span class="keyword">SELECT</span> e.employee_id,e.last_name,m.employee_id,m.last_name</span><br><span class="line"><span class="keyword">FROM</span> employees e,employees m</span><br><span class="line"><span class="keyword">WHERE</span> e.`manager_id`<span class="operator">=</span>m.`employee_id`;</span><br></pre></td></tr></table></figure>

<h2 id="sql-99标准"><a href="#sql-99标准" class="headerlink" title="sql-99标准"></a>sql-99标准</h2><h3 id="内连接-1"><a href="#内连接-1" class="headerlink" title="内连接"></a>内连接</h3><p>SQL92和SQL99的区别：SQL99，使用<code>JOIN</code>关键字代替了之前的逗号，并且将连接条件和筛选条件进行了分离，提高阅读性！！！</p>
<p>语法：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> 查询列表</span><br><span class="line"><span class="keyword">FROM</span> 表名<span class="number">1</span> 别名</span><br><span class="line">【<span class="keyword">INNER</span>】 <span class="keyword">JOIN</span>  表名<span class="number">2</span> 别名</span><br><span class="line"><span class="keyword">ON</span> 连接条件</span><br><span class="line"><span class="keyword">WHERE</span> 筛选条件</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> 分组列表</span><br><span class="line"><span class="keyword">HAVING</span> 分组后筛选</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> 排序列表;</span><br></pre></td></tr></table></figure>

<h4 id="等值连接-1"><a href="#等值连接-1" class="headerlink" title="等值连接"></a>等值连接</h4><p>简单连接</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 案例：查询员工名和部门名</span></span><br><span class="line"><span class="keyword">SELECT</span> last_name,department_name</span><br><span class="line"><span class="keyword">FROM</span> departments d </span><br><span class="line"><span class="keyword">JOIN</span>  employees e </span><br><span class="line"><span class="keyword">ON</span> e.department_id <span class="operator">=</span>d.department_id;</span><br></pre></td></tr></table></figure>

<p>添加筛选条件</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 案例1：查询部门编号&gt;100的部门名和所在的城市名</span></span><br><span class="line"><span class="keyword">SELECT</span> department_name,city</span><br><span class="line"><span class="keyword">FROM</span> departments d</span><br><span class="line"><span class="keyword">JOIN</span> locations l</span><br><span class="line"><span class="keyword">ON</span> d.`location_id` <span class="operator">=</span> l.`location_id`</span><br><span class="line"><span class="keyword">WHERE</span> d.`department_id`<span class="operator">&gt;</span><span class="number">100</span>;</span><br></pre></td></tr></table></figure>

<p>添加分组+筛选</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 案例1：查询每个城市的部门个数</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) 部门个数,l.`city`</span><br><span class="line"><span class="keyword">FROM</span> departments d</span><br><span class="line"><span class="keyword">JOIN</span> locations l</span><br><span class="line"><span class="keyword">ON</span> d.`location_id`<span class="operator">=</span>l.`location_id`</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> l.`city`;</span><br></pre></td></tr></table></figure>

<p>添加分组+筛选+排序</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 案例1：查询部门中员工个数&gt;10的部门名，并按员工个数降序</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) 员工个数,d.department_name</span><br><span class="line"><span class="keyword">FROM</span> employees e</span><br><span class="line"><span class="keyword">JOIN</span> departments d</span><br><span class="line"><span class="keyword">ON</span> e.`department_id`<span class="operator">=</span>d.`department_id`</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> d.`department_id`</span><br><span class="line"><span class="keyword">HAVING</span> 员工个数<span class="operator">&gt;</span><span class="number">10</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> 员工个数 <span class="keyword">DESC</span>;</span><br></pre></td></tr></table></figure>

<h4 id="非等值连接-1"><a href="#非等值连接-1" class="headerlink" title="非等值连接"></a>非等值连接</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 案例：查询部门编号在10-90之间的员工的工资级别，并按级别进行分组</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) 个数,grade</span><br><span class="line"><span class="keyword">FROM</span> employees e</span><br><span class="line"><span class="keyword">JOIN</span> sal_grade g</span><br><span class="line"><span class="keyword">ON</span> e.`salary` <span class="keyword">BETWEEN</span> g.`min_salary` <span class="keyword">AND</span> g.`max_salary`</span><br><span class="line"><span class="keyword">WHERE</span> e.`department_id` <span class="keyword">BETWEEN</span> <span class="number">10</span> <span class="keyword">AND</span> <span class="number">90</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> g.grade;</span><br></pre></td></tr></table></figure>

<h4 id="自连接-1"><a href="#自连接-1" class="headerlink" title="自连接"></a>自连接</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 案例：查询员工名和对应的领导名</span></span><br><span class="line"><span class="keyword">SELECT</span> e.`last_name`,m.`last_name`</span><br><span class="line"><span class="keyword">FROM</span> employees e</span><br><span class="line"><span class="keyword">JOIN</span> employees m</span><br><span class="line"><span class="keyword">ON</span> e.`manager_id`<span class="operator">=</span>m.`employee_id`;</span><br></pre></td></tr></table></figure>

<h4 id="外连接"><a href="#外连接" class="headerlink" title="外连接"></a>外连接</h4><p>说明：查询结果为主表中所有的记录，如果从表有匹配项，则显示匹配项；如果从表没有匹配项，则显示null<br>应用场景：一般用于查询主表中有但从表没有的记录</p>
<p>特点：</p>
<ol>
<li>外连接分主从表，两表的顺序不能任意调换</li>
<li>左连接的话，left join左边为主表<br>右连接的话，right join右边为主表</li>
</ol>
<p>语法：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> 查询列表</span><br><span class="line"><span class="keyword">from</span> 表<span class="number">1</span> 别名</span><br><span class="line"><span class="keyword">left</span><span class="operator">|</span><span class="keyword">right</span><span class="operator">|</span><span class="keyword">full</span> 【<span class="keyword">outer</span>】 <span class="keyword">join</span> 表<span class="number">2</span> 别名</span><br><span class="line"><span class="keyword">on</span> 连接条件</span><br><span class="line"><span class="keyword">where</span> 筛选条件;</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 案例1：查询所有女神记录，以及对应的男神名，如果没有对应的男神，则显示为null</span></span><br><span class="line"><span class="comment">-- 左连接</span></span><br><span class="line"><span class="keyword">SELECT</span> b.<span class="operator">*</span>,bo.<span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> beauty b</span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> boys bo <span class="keyword">ON</span> b.`boyfriend_id` <span class="operator">=</span> bo.`id`;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 右连接</span></span><br><span class="line"><span class="keyword">SELECT</span> b.<span class="operator">*</span>,bo.<span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> boys bo</span><br><span class="line"><span class="keyword">RIGHT</span> <span class="keyword">JOIN</span>  beauty b <span class="keyword">ON</span> b.`boyfriend_id` <span class="operator">=</span> bo.`id`;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 案例2：查哪个女神没有男朋友</span></span><br><span class="line"><span class="comment">-- 左连接</span></span><br><span class="line"><span class="keyword">SELECT</span> b.`name`</span><br><span class="line"><span class="keyword">FROM</span> beauty b</span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> boys bo <span class="keyword">ON</span> b.`boyfriend_id` <span class="operator">=</span> bo.`id`</span><br><span class="line"><span class="keyword">WHERE</span> bo.`id`  <span class="keyword">IS</span> <span class="keyword">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 右连接</span></span><br><span class="line"><span class="keyword">SELECT</span> b.<span class="operator">*</span>,bo.<span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> boys bo</span><br><span class="line"><span class="keyword">RIGHT</span> <span class="keyword">JOIN</span>  beauty b <span class="keyword">ON</span> b.`boyfriend_id` <span class="operator">=</span> bo.`id`</span><br><span class="line"><span class="keyword">WHERE</span> bo.`id`  <span class="keyword">IS</span> <span class="keyword">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 案例3：查询哪个部门没有员工，并显示其部门编号和部门名</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) 部门个数</span><br><span class="line"><span class="keyword">FROM</span> departments d</span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> employees e <span class="keyword">ON</span> d.`department_id` <span class="operator">=</span> e.`department_id`</span><br><span class="line"><span class="keyword">WHERE</span> e.`employee_id` <span class="keyword">IS</span> <span class="keyword">NULL</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 案例</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">一、查询编号&gt;3 的女神的男朋友信息，如果有则列出详细，如果没有，用 null 填充</span></span><br><span class="line"><span class="comment">4   小红     大飞</span></span><br><span class="line"><span class="comment">5   小白     大黄</span></span><br><span class="line"><span class="comment">6   小绿     NULL</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">SELECT</span> b.id,b.name,bo.<span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> beauty b</span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> boys bo <span class="keyword">ON</span> b.boyfriend_id <span class="operator">=</span> bo.id</span><br><span class="line"><span class="keyword">WHERE</span> b.id<span class="operator">&gt;</span><span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 二、查询哪个城市没有部门</span></span><br><span class="line"><span class="keyword">SELECT</span> l.city</span><br><span class="line"><span class="keyword">FROM</span> departments d</span><br><span class="line"><span class="keyword">RIGHT</span> <span class="keyword">JOIN</span> locations l <span class="keyword">ON</span> l.location_id <span class="operator">=</span> d.location_id</span><br><span class="line"><span class="keyword">WHERE</span> d.`department_id` <span class="keyword">IS</span> <span class="keyword">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 三、查询部门名为 SAL 或 IT 的员工信息</span></span><br><span class="line"><span class="keyword">SELECT</span> d.<span class="operator">*</span>,e.<span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> departments d</span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> employees e <span class="keyword">ON</span> d.`department_id` <span class="operator">=</span> e.`department_id`</span><br><span class="line"><span class="keyword">WHERE</span> d.`department_name` <span class="operator">=</span> <span class="string">&#x27;SAL&#x27;</span> <span class="keyword">OR</span> d.`department_name`<span class="operator">=</span><span class="string">&#x27;IT&#x27;</span>;</span><br></pre></td></tr></table></figure>

<h1 id="测试题3"><a href="#测试题3" class="headerlink" title="测试题3"></a>测试题3</h1><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 一、查询员工姓名、入职日期并按入职日期升序</span></span><br><span class="line"><span class="keyword">select</span> last_name,hiredate</span><br><span class="line"><span class="keyword">from</span> employees</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> hiredate <span class="keyword">asc</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 还可以用日期函数</span></span><br><span class="line">date_formate(hiredate,<span class="string">&#x27;%Y&#x27;</span>)</span><br><span class="line"><span class="keyword">year</span>(hiredate)</span><br><span class="line"><span class="keyword">month</span>(hiredate)</span><br><span class="line"><span class="keyword">day</span>(hiredate)</span><br><span class="line"><span class="keyword">hour</span>(hiredate)</span><br><span class="line"><span class="keyword">minute</span>(hiredate)</span><br><span class="line"><span class="keyword">second</span>(hiredate)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 二、将当前日期显示成 xxxx年xx月xx日</span></span><br><span class="line"><span class="keyword">select</span> date_format(now(),<span class="string">&#x27;%Y年%m月%d日&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*三、</span></span><br><span class="line"><span class="comment">已知学员信息表stuinfo</span></span><br><span class="line"><span class="comment">	stuId</span></span><br><span class="line"><span class="comment">	stuName </span></span><br><span class="line"><span class="comment">	gender </span></span><br><span class="line"><span class="comment">	majorId</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">已知专业表major</span></span><br><span class="line"><span class="comment">	id	</span></span><br><span class="line"><span class="comment">	majorName</span></span><br><span class="line"><span class="comment">已知成绩表result</span></span><br><span class="line"><span class="comment">	id成绩编号</span></span><br><span class="line"><span class="comment">	majorid</span></span><br><span class="line"><span class="comment">	stuid</span></span><br><span class="line"><span class="comment">	score</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">-- 1、查询所有男生的姓名、专业名和成绩，使用SQL92和SQL99两种语法方式实现</span></span><br><span class="line"><span class="comment">-- SQL92</span></span><br><span class="line"><span class="keyword">select</span> stuname,majorname,score</span><br><span class="line"><span class="keyword">from</span> stuinfo s,major m,<span class="keyword">result</span> r</span><br><span class="line"><span class="keyword">where</span> s.majorid <span class="operator">=</span> m.id <span class="keyword">and</span> r.stuid <span class="operator">=</span> s.stuid</span><br><span class="line"><span class="keyword">and</span> s.gender <span class="operator">=</span> <span class="string">&#x27;男&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- SQL99</span></span><br><span class="line"><span class="keyword">select</span> stuname,majorname,score</span><br><span class="line"><span class="keyword">from</span> stuinfo s</span><br><span class="line"><span class="keyword">join</span> major m <span class="keyword">on</span> s.majorid <span class="operator">=</span> m.id </span><br><span class="line"><span class="keyword">join</span> <span class="keyword">result</span> r <span class="keyword">on</span> r.stuid <span class="operator">=</span> s.stuid</span><br><span class="line"><span class="keyword">where</span> s.gender <span class="operator">=</span> <span class="string">&#x27;男&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 2、查询每个性别的每个专业的平均成绩，并按平均成绩降序</span></span><br><span class="line"><span class="keyword">select</span> <span class="built_in">avg</span>(score) 平均成绩,gendeer,s.majorid</span><br><span class="line"><span class="keyword">from</span> stuinfo s</span><br><span class="line"><span class="keyword">join</span> <span class="keyword">result</span> r <span class="keyword">on</span> s.stuid <span class="operator">=</span> r.stuid</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> gender,s.majorid</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> 平均成绩 <span class="keyword">desc</span>;</span><br></pre></td></tr></table></figure>

<h1 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h1><p>说明：当一个查询语句中又嵌套了另一个完整的select语句，则被嵌套的select语句称为子查询或内查询<br>外面的select语句称为主查询或外查询。</p>
<p>按子查询出现的位置进行分类：</p>
<ol>
<li>select后面<br> 要求：子查询的结果为单行单列（标量子查询）</li>
<li>from后面<br> 要求：子查询的结果可以为多行多列</li>
<li>where或having后面 ★<br> 要求：子查询的结果必须为单列<pre><code> 单行子查询
 多行子查询
</code></pre>
</li>
<li>exists后面<br> 要求：子查询结果必须为单列（相关子查询）</li>
</ol>
<p>特点：</p>
<ol>
<li>子查询放在条件中，要求必须放在条件的右侧</li>
<li>子查询一般放在小括号中</li>
<li>子查询的执行优先于主查询</li>
<li>单行子查询对应了 单行操作符：&gt; &lt; &gt;= &lt;= = &lt;&gt;<br>多行子查询对应了 多行操作符：any/some  all in   </li>
</ol>
<h2 id="单行子查询-放在where或having后面"><a href="#单行子查询-放在where或having后面" class="headerlink" title="单行子查询(放在where或having后面)"></a>单行子查询(放在where或having后面)</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 案例1：谁的工资比 Abel 高?</span></span><br><span class="line"><span class="comment">-- （1）查询Abel的工资</span></span><br><span class="line"><span class="keyword">SELECT</span> salary</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> last_name  <span class="operator">=</span> <span class="string">&#x27;Abel&#x27;</span></span><br><span class="line"><span class="comment">-- （2）查询salary&gt;（1）的员工信息</span></span><br><span class="line"><span class="keyword">SELECT</span> last_name,salary</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> salary<span class="operator">&gt;</span>(</span><br><span class="line">	<span class="keyword">SELECT</span> salary</span><br><span class="line">	<span class="keyword">FROM</span> employees</span><br><span class="line">	<span class="keyword">WHERE</span> last_name  <span class="operator">&lt;&gt;</span> <span class="string">&#x27;Abel&#x27;</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 案例2：返回job_id与141号员工相同，salary比143号员工多的员工姓名，job_id 和工资</span></span><br><span class="line"><span class="comment">-- （1）查询141号员工的job_id</span></span><br><span class="line"><span class="keyword">SELECT</span> job_id</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> employee_id <span class="operator">=</span> <span class="number">141</span></span><br><span class="line"><span class="comment">-- （2）查询143号员工的salary</span></span><br><span class="line"><span class="keyword">SELECT</span> salary</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> employee_id <span class="operator">=</span> <span class="number">143</span></span><br><span class="line"><span class="comment">-- （3）查询job_id=（1） and salary&gt;（2）的信息</span></span><br><span class="line"><span class="keyword">SELECT</span> last_name,job_id,salary</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> job_id <span class="operator">=</span> (</span><br><span class="line">	<span class="keyword">SELECT</span> job_id</span><br><span class="line">	<span class="keyword">FROM</span> employees</span><br><span class="line">	<span class="keyword">WHERE</span> employee_id <span class="operator">=</span> <span class="number">141</span></span><br><span class="line">) <span class="keyword">AND</span> salary<span class="operator">&gt;</span>(</span><br><span class="line">	<span class="keyword">SELECT</span> salary</span><br><span class="line">	<span class="keyword">FROM</span> employees</span><br><span class="line">	<span class="keyword">WHERE</span> employee_id <span class="operator">=</span> <span class="number">143</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 1. 查询和 Zlotkey 相同部门的员工姓名和工资</span></span><br><span class="line"><span class="comment">-- (1)查询Zlotkey的部门编号</span></span><br><span class="line"><span class="keyword">SELECT</span> department_id</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> last_name <span class="operator">=</span> <span class="string">&#x27;Zlotkey&#x27;</span></span><br><span class="line"><span class="comment">-- (2)查询department_id = (1)的员工姓名和工资</span></span><br><span class="line"><span class="keyword">SELECT</span> last_name,salary</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> department_id <span class="operator">=</span> (</span><br><span class="line">	<span class="keyword">SELECT</span> department_id</span><br><span class="line">	<span class="keyword">FROM</span> employees</span><br><span class="line">	<span class="keyword">WHERE</span> last_name <span class="operator">=</span> <span class="string">&#x27;Zlotkey&#x27;</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 2. 查询工资比公司平均工资高的员工的员工号，姓名和工资。</span></span><br><span class="line"><span class="comment">-- (1)查询平均工资</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">AVG</span>(salary)</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="comment">-- (2)查询salary&gt;(1)的信息</span></span><br><span class="line"><span class="keyword">SELECT</span> employee_id,last_name,salary</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> salary<span class="operator">&gt;</span>(</span><br><span class="line">	<span class="keyword">SELECT</span> <span class="built_in">AVG</span>(salary)</span><br><span class="line">	<span class="keyword">FROM</span> employees</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<h2 id="多行子查询"><a href="#多行子查询" class="headerlink" title="多行子查询"></a>多行子查询</h2><ol>
<li>in：判断某字段是否在指定列表内  </li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">x <span class="keyword">in</span>(<span class="number">10</span>,<span class="number">30</span>,<span class="number">50</span>)</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>any/some：判断某字段的值是否满足其中任意一个</li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">x<span class="operator">&gt;</span><span class="keyword">any</span>(<span class="number">10</span>,<span class="number">30</span>,<span class="number">50</span>)</span><br><span class="line">x<span class="operator">&gt;</span><span class="built_in">min</span>()</span><br><span class="line"></span><br><span class="line">x<span class="operator">=</span><span class="keyword">any</span>(<span class="number">10</span>,<span class="number">30</span>,<span class="number">50</span>)</span><br><span class="line">x <span class="keyword">in</span>(<span class="number">10</span>,<span class="number">30</span>,<span class="number">50</span>)</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>all：判断某字段的值是否满足里面所有的</li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">x <span class="operator">&gt;</span><span class="keyword">all</span>(<span class="number">10</span>,<span class="number">30</span>,<span class="number">50</span>)</span><br><span class="line">x <span class="operator">&gt;</span><span class="built_in">max</span>()</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 案例1：返回location_id是1400或1700的部门中的所有员工姓名</span></span><br><span class="line"><span class="comment">-- （1）查询location_id是1400或1700的部门</span></span><br><span class="line"><span class="keyword">SELECT</span> department_id</span><br><span class="line"><span class="keyword">FROM</span> departments</span><br><span class="line"><span class="keyword">WHERE</span> location_id <span class="keyword">IN</span>(<span class="number">1400</span>,<span class="number">1700</span>)</span><br><span class="line"><span class="comment">-- （2）查询department_id = （1）的姓名</span></span><br><span class="line"><span class="keyword">SELECT</span> last_name</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> department_id <span class="keyword">IN</span>(</span><br><span class="line">	<span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> department_id</span><br><span class="line">	<span class="keyword">FROM</span> departments</span><br><span class="line">	<span class="keyword">WHERE</span> location_id <span class="keyword">IN</span>(<span class="number">1400</span>,<span class="number">1700</span>)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 题目：返回其它部门中比job_id为‘IT_PROG’部门任一工资低的员工的员工号、姓名、job_id 以及salary</span></span><br><span class="line"><span class="comment">-- （—1）查询job_id为‘IT_PROG’部门的工资</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> salary</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> job_id <span class="operator">=</span> <span class="string">&#x27;IT_PROG&#x27;</span></span><br><span class="line"><span class="comment">-- （2）查询其他部门的工资&lt;任意一个（1）的结果</span></span><br><span class="line"><span class="keyword">SELECT</span> employee_id,last_name,job_id,salary</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> salary<span class="operator">&lt;</span><span class="keyword">ANY</span>(</span><br><span class="line">	<span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> salary</span><br><span class="line">	<span class="keyword">FROM</span> employees</span><br><span class="line">	<span class="keyword">WHERE</span> job_id <span class="operator">=</span> <span class="string">&#x27;IT_PROG&#x27;</span></span><br><span class="line">);</span><br><span class="line"><span class="comment">-- 等价于</span></span><br><span class="line"><span class="keyword">SELECT</span> employee_id,last_name,job_id,salary</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> salary<span class="operator">&lt;</span>(</span><br><span class="line">	<span class="keyword">SELECT</span> <span class="built_in">MAX</span>(salary)</span><br><span class="line">	<span class="keyword">FROM</span> employees</span><br><span class="line">	<span class="keyword">WHERE</span> job_id <span class="operator">=</span> <span class="string">&#x27;IT_PROG&#x27;</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 案例3：返回其它部门中比job_id为‘IT_PROG’部门所有工资都低的员工 的员工号、姓名、job_id 以及salary</span></span><br><span class="line"><span class="comment">-- （1）查询job_id为‘IT_PROG’部门的工资</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> salary</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> job_id <span class="operator">=</span> <span class="string">&#x27;IT_PROG&#x27;</span></span><br><span class="line"><span class="comment">-- （2）查询其他部门的工资&lt;所有①的结果</span></span><br><span class="line"><span class="keyword">SELECT</span> employee_id,last_name,job_id,salary</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> salary<span class="operator">&lt;</span><span class="keyword">ALL</span>(</span><br><span class="line">	<span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> salary</span><br><span class="line">	<span class="keyword">FROM</span> employees</span><br><span class="line">	<span class="keyword">WHERE</span> job_id <span class="operator">=</span> <span class="string">&#x27;IT_PROG&#x27;</span></span><br><span class="line">);</span><br><span class="line"><span class="comment">-- 等价于</span></span><br><span class="line"><span class="keyword">SELECT</span> employee_id,last_name,job_id,salary</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> salary<span class="operator">&lt;</span>(</span><br><span class="line">	<span class="keyword">SELECT</span> <span class="built_in">MIN</span>(salary)</span><br><span class="line">	<span class="keyword">FROM</span> employees</span><br><span class="line">	<span class="keyword">WHERE</span> job_id <span class="operator">=</span> <span class="string">&#x27;IT_PROG&#x27;</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<h2 id="放在select后面"><a href="#放在select后面" class="headerlink" title="放在select后面"></a>放在select后面</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 不知道什么场景用</span></span><br><span class="line"><span class="comment">-- 案例；查询部门编号是50的员工个数</span></span><br><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">(</span><br><span class="line">	<span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>)</span><br><span class="line">	<span class="keyword">FROM</span> employees</span><br><span class="line">	<span class="keyword">WHERE</span> department_id <span class="operator">=</span> <span class="number">50</span></span><br><span class="line">)  个数;</span><br></pre></td></tr></table></figure>

<h2 id="放在from后面"><a href="#放在from后面" class="headerlink" title="放在from后面"></a>放在from后面</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 案例：查询每个部门的平均工资的工资级别</span></span><br><span class="line"><span class="comment">-- (1)查询每个部门的平均工资</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">AVG</span>(salary),department_id</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> department_id</span><br><span class="line"><span class="comment">-- (2)将(1)和sal_grade两表连接查询</span></span><br><span class="line"><span class="keyword">SELECT</span> dep_ag.department_id,dep_ag.ag,g.grade</span><br><span class="line"><span class="keyword">FROM</span> sal_grade g</span><br><span class="line"><span class="keyword">JOIN</span> (</span><br><span class="line">	<span class="keyword">SELECT</span> <span class="built_in">AVG</span>(salary) ag,department_id</span><br><span class="line">	<span class="keyword">FROM</span> employees</span><br><span class="line">	<span class="keyword">GROUP</span> <span class="keyword">BY</span> department_id</span><br><span class="line">) dep_ag <span class="keyword">ON</span> dep_ag.ag <span class="keyword">BETWEEN</span> g.min_salary <span class="keyword">AND</span> g.max_salary;</span><br></pre></td></tr></table></figure>

<h2 id="放在exists后面"><a href="#放在exists后面" class="headerlink" title="放在exists后面"></a>放在exists后面</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 案例1 ：查询有无名字叫“张三丰”的员工信息</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">EXISTS</span>(</span><br><span class="line">	<span class="keyword">SELECT</span> <span class="operator">*</span> </span><br><span class="line">	<span class="keyword">FROM</span> employees</span><br><span class="line">	<span class="keyword">WHERE</span> last_name <span class="operator">=</span> <span class="string">&#x27;Abel&#x27;</span></span><br><span class="line"></span><br><span class="line">) 有无Abel;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 案例2：查询没有女朋友的男神信息</span></span><br><span class="line"><span class="keyword">SELECT</span> bo.<span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> boys bo</span><br><span class="line"><span class="keyword">WHERE</span> bo.`id` <span class="keyword">NOT</span> <span class="keyword">IN</span>(</span><br><span class="line">	<span class="keyword">SELECT</span> boyfriend_id</span><br><span class="line">	<span class="keyword">FROM</span> beauty b</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> bo.<span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> boys bo</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span>(</span><br><span class="line">	<span class="keyword">SELECT</span> boyfriend_id</span><br><span class="line">	<span class="keyword">FROM</span> beauty b</span><br><span class="line">	<span class="keyword">WHERE</span> bo.id <span class="operator">=</span> b.boyfriend_id</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<h1 id="联合查询"><a href="#联合查询" class="headerlink" title="联合查询"></a>联合查询</h1><p>说明：当查询结果来自于多张表，但多张表之间没有关联，这个时候往往使用联合查询，也称为union查询</p>
<p>语法：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> 查询列表 <span class="keyword">from</span> 表<span class="number">1</span>  <span class="keyword">where</span> 筛选条件  </span><br><span class="line">	<span class="keyword">union</span></span><br><span class="line"><span class="keyword">select</span> 查询列表 <span class="keyword">from</span> 表<span class="number">2</span>  <span class="keyword">where</span> 筛选条件  </span><br></pre></td></tr></table></figure>

<p>特点：</p>
<ol>
<li>多条待联合的查询语句的查询列数必须一致，查询类型、字段意义最好一致</li>
<li>union 实现去重查询<br>union all 实现全部查询，包含重复项</li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 案例：查询所有国家的年龄&gt;20岁的用户信息</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> usa <span class="keyword">WHERE</span> uage <span class="operator">&gt;</span><span class="number">20</span> </span><br><span class="line"><span class="keyword">UNION</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> chinese <span class="keyword">WHERE</span> age <span class="operator">&gt;</span><span class="number">20</span> ;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 案例2：查询所有国家的用户姓名和年龄</span></span><br><span class="line"><span class="keyword">SELECT</span> uname,uage <span class="keyword">FROM</span> usa</span><br><span class="line"><span class="keyword">UNION</span></span><br><span class="line"><span class="keyword">SELECT</span> age,`name` <span class="keyword">FROM</span> chinese;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 案例3：union自动去重/union all 可以支持重复项</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="number">1</span>,<span class="string">&#x27;范冰冰&#x27;</span> </span><br><span class="line"><span class="keyword">UNION</span> <span class="keyword">ALL</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="number">1</span>,<span class="string">&#x27;范冰冰&#x27;</span> </span><br><span class="line"><span class="keyword">UNION</span>  <span class="keyword">ALL</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="number">1</span>,<span class="string">&#x27;范冰冰&#x27;</span> </span><br><span class="line"><span class="keyword">UNION</span>  <span class="keyword">ALL</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="number">1</span>,<span class="string">&#x27;范冰冰&#x27;</span> ;</span><br></pre></td></tr></table></figure>



<h1 id="分页查询"><a href="#分页查询" class="headerlink" title="分页查询"></a>分页查询</h1><p>应用场景：当页面上的数据，一页显示不全，则需要分页显示<br>分页查询的sql命令请求数据库服务器——&gt;服务器响应查询到的多条数据——&gt;前台页面</p>
<p>语法：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> 查询列表</span><br><span class="line"><span class="keyword">from</span> 表<span class="number">1</span> 别名</span><br><span class="line"><span class="keyword">join</span> 表<span class="number">2</span> 别名</span><br><span class="line"><span class="keyword">on</span> 连接条件</span><br><span class="line"><span class="keyword">where</span> 筛选条件</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> 分组</span><br><span class="line"><span class="keyword">having</span> 分组后筛选</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> 排序列表</span><br><span class="line">limit 起始条目索引,显示的条目数</span><br></pre></td></tr></table></figure>

<p>执行顺序：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>》<span class="keyword">from</span>子句</span><br><span class="line"><span class="number">2</span>》<span class="keyword">join</span>子句</span><br><span class="line"><span class="number">3</span>》<span class="keyword">on</span>子句</span><br><span class="line"><span class="number">4</span>》<span class="keyword">where</span>子句</span><br><span class="line"><span class="number">5</span>》<span class="keyword">group</span> <span class="keyword">by</span>子句</span><br><span class="line"><span class="number">6</span>》<span class="keyword">having</span>子句</span><br><span class="line"><span class="number">7</span>》<span class="keyword">select</span>子句</span><br><span class="line"><span class="number">8</span>》<span class="keyword">order</span> <span class="keyword">by</span>子句</span><br><span class="line"><span class="number">9</span>》limit子句</span><br></pre></td></tr></table></figure>

<p>特点：</p>
<ol>
<li>起始条目索引如果不写，默认是0</li>
<li>limit后面支持两个参数<br>参数1：显示的起始条目索引<br>参数2：条目数</li>
</ol>
<p>公式：<br>假如要显示的页数是page，每页显示的条目数为size</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">from</span> employees</span><br><span class="line">limit (page<span class="number">-1</span>)<span class="operator">*</span>size,size;</span><br><span class="line"></span><br><span class="line">page	    size<span class="operator">=</span><span class="number">10</span></span><br><span class="line"><span class="number">1</span>           limit <span class="number">0</span>,<span class="number">10</span></span><br><span class="line"><span class="number">2</span>			limit <span class="number">10</span>,<span class="number">10</span></span><br><span class="line"><span class="number">3</span>			limit <span class="number">20</span>,<span class="number">10</span></span><br><span class="line"><span class="number">4</span>			limit <span class="number">30</span>,<span class="number">10</span></span><br></pre></td></tr></table></figure>

<h1 id="子查询案例"><a href="#子查询案例" class="headerlink" title="子查询案例"></a>子查询案例</h1><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 3. 查询各部门中工资比本部门平均工资高的员工的员工号, 姓名和工资</span></span><br><span class="line"><span class="comment">-- （1）查询各部门的平均工资</span></span><br><span class="line"><span class="keyword">SELECT</span> department_id,<span class="built_in">AVG</span>(salary) ag</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> department_id</span><br><span class="line"><span class="comment">-- （2）将（1）结果和employees表连接查询</span></span><br><span class="line"><span class="keyword">SELECT</span> employee_id,last_name,salary</span><br><span class="line"><span class="keyword">FROM</span> employees e</span><br><span class="line"><span class="keyword">JOIN</span>  (</span><br><span class="line">	<span class="keyword">SELECT</span> department_id,<span class="built_in">AVG</span>(salary) ag</span><br><span class="line">	<span class="keyword">FROM</span> employees</span><br><span class="line">	<span class="keyword">GROUP</span> <span class="keyword">BY</span> department_id</span><br><span class="line">) dep_ag <span class="keyword">ON</span> e.department_id <span class="operator">=</span> dep_ag.department_id</span><br><span class="line"><span class="keyword">WHERE</span> e.salary<span class="operator">&gt;</span>dep_ag.ag;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 4. 查询和姓名中包含字母 u 的员工在相同部门的员工的员工号和姓名</span></span><br><span class="line"><span class="comment">-- （1）查询姓名中包含字母 u 的员工的部门编号</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> department_id</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> last_name <span class="keyword">LIKE</span> <span class="string">&#x27;%u%&#x27;</span></span><br><span class="line"><span class="comment">-- （2）查询部门号是①的员工号和姓名</span></span><br><span class="line"><span class="keyword">SELECT</span> employee_id,last_name</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> department_id <span class="keyword">IN</span>(</span><br><span class="line">	<span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> department_id</span><br><span class="line">	<span class="keyword">FROM</span> employees</span><br><span class="line">	<span class="keyword">WHERE</span> last_name <span class="keyword">LIKE</span> <span class="string">&#x27;%u%&#x27;</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 6. 查询管理者是 King 的员工姓名和工资</span></span><br><span class="line"><span class="comment">-- （1）查询管理者是king的编号</span></span><br><span class="line"><span class="keyword">SELECT</span> employee_id</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> last_name  <span class="operator">=</span> <span class="string">&#x27;k_ing&#x27;</span></span><br><span class="line"><span class="comment">-- （2）查询哪个员工的领导编号是（1）</span></span><br><span class="line"><span class="keyword">SELECT</span> last_name,salary</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> manager_id  <span class="keyword">IN</span>(</span><br><span class="line">	<span class="keyword">SELECT</span> employee_id</span><br><span class="line">	<span class="keyword">FROM</span> employees</span><br><span class="line">	<span class="keyword">WHERE</span> last_name  <span class="operator">=</span> <span class="string">&#x27;k_ing&#x27;</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 3. 查询平均工资最低的部门信息和该部门的平均工资</span></span><br><span class="line"><span class="comment">-- （1）查询各部门的平均工资</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">AVG</span>(salary) ag,department_id</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> department_id</span><br><span class="line"><span class="comment">-- （2）查询哪个部门的平均工资最低</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">AVG</span>(salary) ag,department_id</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> department_id</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> ag </span><br><span class="line">LIMIT <span class="number">1</span></span><br><span class="line"><span class="comment">-- （3）连接（2）和departments表</span></span><br><span class="line"><span class="keyword">SELECT</span> d.<span class="operator">*</span>,dep_ag.ag</span><br><span class="line"><span class="keyword">FROM</span> departments d</span><br><span class="line"><span class="keyword">JOIN</span> (</span><br><span class="line">	<span class="keyword">SELECT</span> <span class="built_in">AVG</span>(salary) ag,department_id</span><br><span class="line">	<span class="keyword">FROM</span> employees</span><br><span class="line">	<span class="keyword">GROUP</span> <span class="keyword">BY</span> department_id</span><br><span class="line">	<span class="keyword">ORDER</span> <span class="keyword">BY</span> ag </span><br><span class="line">	LIMIT <span class="number">1</span></span><br><span class="line">) dep_ag <span class="keyword">ON</span> d.department_id <span class="operator">=</span> dep_ag.department_id</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 7. 各个部门中 最高工资中最低的那个部门的 最低工资是多少</span></span><br><span class="line"><span class="comment">-- （1）查询各部门的最高工资</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">MAX</span>(salary) mx,department_id</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> department_id</span><br><span class="line"><span class="comment">-- （2）查询各部门的最高工资最低的那个部门</span></span><br><span class="line"><span class="keyword">SELECT</span> department_id</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> department_id</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="built_in">MAX</span>(salary) </span><br><span class="line">LIMIT <span class="number">1</span></span><br><span class="line"><span class="comment">-- （3）查询部门编号是②的部门的最低工资</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">MIN</span>(salary),department_id</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> department_id <span class="operator">=</span> (</span><br><span class="line">	<span class="keyword">SELECT</span> department_id</span><br><span class="line">	<span class="keyword">FROM</span> employees</span><br><span class="line">	<span class="keyword">GROUP</span> <span class="keyword">BY</span> department_id</span><br><span class="line">	<span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="built_in">MAX</span>(salary) </span><br><span class="line">	LIMIT <span class="number">1</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<h1 id="DDL语言"><a href="#DDL语言" class="headerlink" title="DDL语言"></a>DDL语言</h1><p>说明：Data Define Language数据定义语言,用于对数据库和表的管理和操作</p>
<h2 id="库的管理"><a href="#库的管理" class="headerlink" title="库的管理"></a>库的管理</h2><h3 id="创建数据库"><a href="#创建数据库" class="headerlink" title="创建数据库"></a>创建数据库</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> DATABASE stuDB;</span><br><span class="line"><span class="keyword">CREATE</span> DATABASE IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> stuDB;</span><br></pre></td></tr></table></figure>

<h3 id="删除数据库"><a href="#删除数据库" class="headerlink" title="删除数据库"></a>删除数据库</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DROP</span> DATABASE stuDB;</span><br><span class="line"><span class="keyword">DROP</span> DATABASE IF <span class="keyword">EXISTS</span> stuDB;</span><br></pre></td></tr></table></figure>

<h2 id="表的管理"><a href="#表的管理" class="headerlink" title="表的管理"></a>表的管理</h2><h3 id="创建表"><a href="#创建表" class="headerlink" title="创建表"></a>创建表</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 语法：</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> [IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span>] 表名(</span><br><span class="line">	字段名  字段类型  【字段约束】,</span><br><span class="line">	字段名  字段类型  【字段约束】,</span><br><span class="line">	字段名  字段类型  【字段约束】,</span><br><span class="line">	字段名  字段类型  【字段约束】,</span><br><span class="line">	字段名  字段类型  【字段约束】</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 案例：没有添加约束</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> stuinfo(</span><br><span class="line">	stuid <span class="type">INT</span> ,</span><br><span class="line">	stuname <span class="type">VARCHAR</span>(<span class="number">20</span>),</span><br><span class="line">	stugender <span class="type">CHAR</span>(<span class="number">1</span>),</span><br><span class="line">	email <span class="type">VARCHAR</span>(<span class="number">20</span>),</span><br><span class="line">	borndate DATETIME</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 案例：添加约束</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> IF <span class="keyword">EXISTS</span> stuinfo;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> stuinfo(</span><br><span class="line">	stuid <span class="type">INT</span> <span class="keyword">PRIMARY</span> KEY, 			     <span class="comment">-- 添加了主键约束</span></span><br><span class="line">	stuname <span class="type">VARCHAR</span>(<span class="number">20</span>) <span class="keyword">UNIQUE</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>, <span class="comment">-- 添加了唯一约束+非空</span></span><br><span class="line">	stugender <span class="type">CHAR</span>(<span class="number">1</span>) <span class="keyword">DEFAULT</span> <span class="string">&#x27;男&#x27;</span>,      <span class="comment">-- 添加了默认约束</span></span><br><span class="line">	email <span class="type">VARCHAR</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">	age <span class="type">INT</span> <span class="keyword">CHECK</span>( age <span class="keyword">BETWEEN</span> <span class="number">0</span> <span class="keyword">AND</span> <span class="number">100</span>), <span class="comment">-- 添加了检查约束，mysql不支持</span></span><br><span class="line">	majorid <span class="type">INT</span>,</span><br><span class="line">	<span class="keyword">CONSTRAINT</span> fk_stuinfo_major <span class="keyword">FOREIGN</span> KEY (majorid) <span class="keyword">REFERENCES</span> major(id) <span class="comment">-- 添加了外键约束</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 支持表级约束：UNIQUE、PRIMARY KEY、FOREIGN KEY </span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> IF <span class="keyword">EXISTS</span> stuinfo;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> stuinfo(</span><br><span class="line">	stuid <span class="type">INT</span> , 			     </span><br><span class="line">	stuname <span class="type">VARCHAR</span>(<span class="number">20</span>) , </span><br><span class="line">	stugender <span class="type">CHAR</span>(<span class="number">1</span>) <span class="keyword">DEFAULT</span> <span class="string">&#x27;男&#x27;</span>,      <span class="comment">-- 添加了默认约束</span></span><br><span class="line">	email <span class="type">VARCHAR</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">	age <span class="type">INT</span> <span class="keyword">CHECK</span>( age <span class="keyword">BETWEEN</span> <span class="number">0</span> <span class="keyword">AND</span> <span class="number">100</span>), <span class="comment">-- 添加了检查约束，mysql不支持</span></span><br><span class="line">	majorid <span class="type">INT</span>,</span><br><span class="line">	<span class="keyword">PRIMARY</span> KEY(id), 				<span class="comment">-- 添加了主键约束</span></span><br><span class="line">	<span class="keyword">CONSTRAINT</span> uq <span class="keyword">unique</span>(name),		<span class="comment">-- 添加了唯一约束+非空</span></span><br><span class="line">	<span class="keyword">CONSTRAINT</span> fk_stuinfo_major <span class="keyword">FOREIGN</span> KEY (majorid) <span class="keyword">REFERENCES</span> major(id), <span class="comment">-- 添加了外键约束</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><table>
<thead>
<tr>
<th>数据类型</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>整型</td>
<td>TINYINT、SMALLINT、 INT、 BIGINT</td>
</tr>
<tr>
<td>浮点型</td>
<td>FLOAT(m,n)、DOUBLE(m,n) 、DECIMAL(m,n)，m和n可选，m：总位数，n：小数位数</td>
</tr>
<tr>
<td>字符型</td>
<td>CHAR(n)：n可选<br/>VARCHAR(n)：n必选<br/>TEXT<br/>n表示最多字符个数</td>
</tr>
<tr>
<td>日期型</td>
<td>DATE、TIME 、DATETIME、TIMESTAMP</td>
</tr>
<tr>
<td>二进制型</td>
<td>BLOB 存储图片数据</td>
</tr>
</tbody></table>
<h3 id="常见约束"><a href="#常见约束" class="headerlink" title="常见约束"></a>常见约束</h3><p>说明：用于限制表中字段的数据的，从而进一步保证数据表的数据是一致的、准确的、可靠的！</p>
<ul>
<li><code>NOT NULL</code> 非空：用于限制该字段为必填项</li>
<li><code>DEFAULT</code> 默认：用于限制该字段没有显式插入值，则直接显式默认值</li>
<li><code>PRIMARY KEY</code> 主键：用于限制该字段值不能重复，设置为主键列的字段默认不能为空。一个表只能有一个主键，当然可以是组合主键</li>
<li><code>UNIQUE</code> 唯一：用于限制该字段值不能重复</li>
<li><code>CHECK</code>检查：用于限制该字段值必须满足指定条件。<code>CHECK(age BETWEEN 1 AND 100)</code></li>
<li><code>FOREIGN KEY</code> 外键：用于限制两个表的关系,要求外键列的值必须来自于主表的关联列。<br>要求：<ol>
<li>主表的关联列和从表的关联列的类型必须一致，意思一样，名称无要求</li>
<li>主表的关联列要求必须是主键</li>
</ol>
</li>
</ul>
<h3 id="修改表-了解"><a href="#修改表-了解" class="headerlink" title="修改表[了解]"></a>修改表[了解]</h3><p>语法：ALTER TABLE 表名 ADD|MODIFY|CHANGE|DROP COLUMN 字段名 字段类型 【字段约束】;</p>
<ol>
<li><p>修改表名</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> stuinfo RENAME <span class="keyword">TO</span> students;</span><br></pre></td></tr></table></figure></li>
<li><p>添加字段</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> students <span class="keyword">ADD</span> <span class="keyword">COLUMN</span> borndate <span class="type">TIMESTAMP</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>;</span><br><span class="line"><span class="keyword">DESC</span> students;</span><br></pre></td></tr></table></figure></li>
<li><p>修改字段名</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> students CHANGE <span class="keyword">COLUMN</span> borndate birthday DATETIME <span class="keyword">NULL</span>;</span><br></pre></td></tr></table></figure></li>
<li><p>修改字段类型</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> students MODIFY <span class="keyword">COLUMN</span> birthday <span class="type">TIMESTAMP</span> ;</span><br></pre></td></tr></table></figure></li>
<li><p>删除字段</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> students <span class="keyword">DROP</span> <span class="keyword">COLUMN</span> birthday;</span><br><span class="line"><span class="keyword">DESC</span> students;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="删除表"><a href="#删除表" class="headerlink" title="删除表"></a>删除表</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> IF <span class="keyword">EXISTS</span> students;</span><br></pre></td></tr></table></figure>

<h3 id="复制表"><a href="#复制表" class="headerlink" title="复制表"></a>复制表</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 仅仅复制表的结构</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> newTable2 <span class="keyword">LIKE</span> major;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 复制表的结构+数据</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> newTable3 <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> girls.`beauty`;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 案例：复制employees表中的last_name,department_id,salary字段到新表 emp表，但不复制数据</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> emp </span><br><span class="line"><span class="keyword">SELECT</span> last_name,department_id,salary </span><br><span class="line"><span class="keyword">FROM</span> myemployees.`employees`</span><br><span class="line"><span class="keyword">WHERE</span> <span class="number">1</span><span class="operator">=</span><span class="number">2</span>;</span><br></pre></td></tr></table></figure>

<h1 id="测试题4"><a href="#测试题4" class="headerlink" title="测试题4"></a>测试题4</h1><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 1.使用分页查询实现，查询员工信息表中部门为50号的工资最低的5名员工信息</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">from</span> employees</span><br><span class="line"><span class="keyword">where</span> deparrment_id <span class="operator">=</span> <span class="number">50</span></span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> salary <span class="keyword">asc</span></span><br><span class="line">limit <span class="number">0</span>,<span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 2.使用子查询实现城市为Toroto的，且工资&gt;10000的员工姓名</span></span><br><span class="line"><span class="comment">-- (1)查询城市为Toroto的部门编号</span></span><br><span class="line"><span class="keyword">select</span> department_id</span><br><span class="line"><span class="keyword">from</span> departments d</span><br><span class="line"><span class="keyword">join</span> locations l <span class="keyword">on</span> d.location_id <span class="operator">=</span> l.location_id</span><br><span class="line"><span class="keyword">where</span> city <span class="operator">=</span> <span class="string">&#x27;Toroto&#x27;</span></span><br><span class="line"><span class="comment">-- (2)查询部门号在(1)里面的员工姓名</span></span><br><span class="line"><span class="keyword">select</span> last_name</span><br><span class="line"><span class="keyword">from</span> employees</span><br><span class="line"><span class="keyword">where</span> salary<span class="operator">&gt;</span><span class="number">10000</span> <span class="keyword">and</span> department_id <span class="keyword">in</span>(</span><br><span class="line">	<span class="keyword">select</span> department_id</span><br><span class="line">	<span class="keyword">from</span> departments d</span><br><span class="line">	<span class="keyword">join</span> locations l <span class="keyword">on</span> d.location_id <span class="operator">=</span> l.location_id</span><br><span class="line">	<span class="keyword">where</span> city <span class="operator">=</span> <span class="string">&#x27;Toroto&#x27;</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 3.创建表qqinfo，里面包含qqid，添加主键约束、昵称nickname，添加唯一约束、邮箱email（添加非空约束）、性别gender</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> if <span class="keyword">not</span> <span class="keyword">exists</span> qqinfo(</span><br><span class="line">	qqid <span class="type">int</span> <span class="keyword">primary</span> key,</span><br><span class="line">	nickname <span class="type">varchar</span>(<span class="number">20</span>) <span class="keyword">unique</span>,</span><br><span class="line">	email <span class="type">varchar</span>(<span class="number">20</span>) <span class="keyword">not</span> <span class="keyword">null</span>,</span><br><span class="line">	gender <span class="type">char</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 4.删除表qqinfo</span></span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> if <span class="keyword">exists</span> qqinfo;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 5.试写出sql查询语句的定义顺序和执行顺序</span></span><br><span class="line"><span class="number">1</span>》定义顺序（书写顺序）</span><br><span class="line"><span class="keyword">select</span> <span class="keyword">distinct</span>  查询列表</span><br><span class="line"><span class="keyword">from</span> 表名 别名</span><br><span class="line"><span class="keyword">join</span> 表名 别名 </span><br><span class="line"><span class="keyword">on</span> 连接条件</span><br><span class="line"><span class="keyword">where</span> 筛选条件</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> 分组列表</span><br><span class="line"><span class="keyword">having</span> 分组后筛选</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> 排序列表</span><br><span class="line">limit 条目数;</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>》执行顺序</span><br><span class="line"><span class="keyword">from</span>子句</span><br><span class="line"><span class="keyword">join</span>子句</span><br><span class="line"><span class="keyword">on</span>子句</span><br><span class="line"><span class="keyword">where</span>子句</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span>子句</span><br><span class="line"><span class="keyword">having</span>子句</span><br><span class="line"><span class="keyword">select</span> 子句</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span>子句</span><br><span class="line">limit子句</span><br></pre></td></tr></table></figure>

<h1 id="DML-Data-Manipulation-Language-数据操纵语言"><a href="#DML-Data-Manipulation-Language-数据操纵语言" class="headerlink" title="DML(Data Manipulation Language)数据操纵语言"></a>DML(Data Manipulation Language)数据操纵语言</h1><p><code>insert update delete</code>,对表中的数据的增删改</p>
<h2 id="插入数据"><a href="#插入数据" class="headerlink" title="插入数据"></a>插入数据</h2><p>语法</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 插入单行：</span></span><br><span class="line">	<span class="keyword">insert</span> <span class="keyword">into</span> 表名(字段名<span class="number">1</span>,字段名<span class="number">2</span> ,...) <span class="keyword">values</span> (值<span class="number">1</span>，值<span class="number">2</span>,...);</span><br><span class="line"><span class="comment">-- 插入多行：</span></span><br><span class="line">	<span class="keyword">insert</span> <span class="keyword">into</span> 表名(字段名<span class="number">1</span>,字段名<span class="number">2</span> ,...) <span class="keyword">values</span></span><br><span class="line">	 (值<span class="number">1</span>，值<span class="number">2</span>,...),(值<span class="number">1</span>，值<span class="number">2</span>,...),(值<span class="number">1</span>，值<span class="number">2</span>,...);</span><br><span class="line">```	 </span><br><span class="line"></span><br><span class="line">特点</span><br><span class="line"></span><br><span class="line"><span class="number">1.</span> 字段和值列表一一对应。包含类型、约束等必须匹配</span><br><span class="line"><span class="number">2.</span> 数值型的值，不用单引号。非数值型的值，必须使用单引号</span><br><span class="line"><span class="number">3.</span> 字段顺序无要求</span><br><span class="line"></span><br><span class="line">```<span class="keyword">sql</span></span><br><span class="line"><span class="comment">-- 案例1：要求字段和值列表一一对应，且遵循类型和约束的限制</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> stuinfo(stuid,stuname,stugender,email,age,majorid)</span><br><span class="line"><span class="keyword">VALUES</span>(<span class="number">1</span>,<span class="string">&#x27;吴倩&#x27;</span>,<span class="string">&#x27;男&#x27;</span>,<span class="string">&#x27;wuqian@qq.com&#x27;</span>,<span class="number">12</span>,<span class="number">1</span>); </span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> stuinfo(stuid,stuname,stugender,email,age,majorid)</span><br><span class="line"><span class="keyword">VALUES</span>(<span class="number">6</span>,<span class="string">&#x27;李宗盛2&#x27;</span>,<span class="string">&#x27;女&#x27;</span>,<span class="string">&#x27;wuqian@qq.com&#x27;</span>,<span class="number">45</span>,<span class="number">2</span>); </span><br><span class="line"></span><br><span class="line"><span class="comment">-- 案例2：可以为空字段如何插入</span></span><br><span class="line"><span class="comment">-- 方案1：字段名和值都不写</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> stuinfo(stuid,stuname,email,majorid)</span><br><span class="line"><span class="keyword">VALUES</span>(<span class="number">5</span>,<span class="string">&#x27;齐鱼&#x27;</span>,<span class="string">&#x27;qiqin@qq.com&#x27;</span>,<span class="number">2</span>); </span><br><span class="line"><span class="comment">-- 方案2：字段名写上，值使用null</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> stuinfo(stuid,stuname,email,age,majorid)</span><br><span class="line"><span class="keyword">VALUES</span>(<span class="number">5</span>,<span class="string">&#x27;齐鱼&#x27;</span>,<span class="string">&#x27;qiqin@qq.com&#x27;</span>,<span class="keyword">NULL</span>,<span class="number">2</span>); </span><br><span class="line"></span><br><span class="line"><span class="comment">-- 案例3：默认字段如何插入</span></span><br><span class="line"><span class="comment">-- 方案1：字段名写上，值使用default</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> stuinfo(stuid,stuname,email,stugender,majorid)</span><br><span class="line"><span class="keyword">VALUES</span>(<span class="number">7</span>,<span class="string">&#x27;齐小鱼&#x27;</span>,<span class="string">&#x27;qiqin@qq.com&#x27;</span>,<span class="keyword">DEFAULT</span>,<span class="number">2</span>); </span><br><span class="line"><span class="comment">-- 方案2：字段名和值都不写</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> stuinfo(stuid,stuname,email,majorid)</span><br><span class="line"><span class="keyword">VALUES</span>(<span class="number">7</span>,<span class="string">&#x27;齐小鱼&#x27;</span>,<span class="string">&#x27;qiqin@qq.com&#x27;</span>,<span class="number">2</span>); </span><br><span class="line"></span><br><span class="line"><span class="comment">-- 案例4：可以省略字段列表，默认所有字段</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> stuinfo <span class="keyword">VALUES</span>(<span class="number">8</span>,<span class="string">&#x27;林忆莲&#x27;</span>,<span class="string">&#x27;女&#x27;</span>,<span class="string">&#x27;lin@126.com&#x27;</span>,<span class="number">12</span>,<span class="number">3</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> stuinfo <span class="keyword">VALUES</span>(<span class="keyword">NULL</span>,<span class="string">&#x27;小黄&#x27;</span>,<span class="string">&#x27;男&#x27;</span>,<span class="string">&#x27;dd@12.com&#x27;</span>,<span class="number">12</span>,<span class="number">3</span>);</span><br></pre></td></tr></table></figure>

<h3 id="设置自增长列"><a href="#设置自增长列" class="headerlink" title="设置自增长列"></a>设置自增长列</h3><ol>
<li>自增长列要求必须设置在一个键上，比如主键或唯一键</li>
<li>自增长列要求数据类型为数值型</li>
<li>一个表至多有一个自增长列</li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> gradeinfo(</span><br><span class="line">	gradeID <span class="type">INT</span> <span class="keyword">PRIMARY</span> KEY AUTO_INCREMENT,</span><br><span class="line">	gradeName <span class="type">VARCHAR</span>(<span class="number">20</span>)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> gradeinfo <span class="keyword">VALUES</span>(<span class="keyword">NULL</span>,<span class="string">&#x27;一年级&#x27;</span>),(<span class="keyword">NULL</span>,<span class="string">&#x27;2年级&#x27;</span>),(<span class="keyword">NULL</span>,<span class="string">&#x27;3年级&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> gradeinfo(gradename)<span class="keyword">VALUES</span>(<span class="string">&#x27;一年级&#x27;</span>),(<span class="string">&#x27;2年级&#x27;</span>),(<span class="string">&#x27;3年级&#x27;</span>);</span><br></pre></td></tr></table></figure>

<h2 id="修改数据"><a href="#修改数据" class="headerlink" title="修改数据"></a>修改数据</h2><ol>
<li>修改单表的记录</li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 语法</span></span><br><span class="line">update 表名</span><br><span class="line"><span class="keyword">set</span> 列<span class="operator">=</span>新值,列<span class="operator">=</span>新值,...</span><br><span class="line"><span class="keyword">where</span> 筛选条件;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 案例1</span></span><br><span class="line">UPDATE beauty </span><br><span class="line"><span class="keyword">set</span> phone<span class="operator">=</span><span class="string">&#x27;138999999&#x27;</span></span><br><span class="line"><span class="keyword">WHERE</span> name <span class="keyword">like</span> <span class="string">&#x27;唐%&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 案例2</span></span><br><span class="line">UPDATE boys <span class="keyword">SET</span> boyname<span class="operator">=</span><span class="string">&#x27;张飞&#x27;</span>,usercp<span class="operator">=</span><span class="number">10</span></span><br><span class="line"><span class="keyword">WHERE</span> id<span class="operator">=</span><span class="number">2</span>;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>修改多表的记录</li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- sql92语法</span></span><br><span class="line">update 表<span class="number">1</span> 别名,表<span class="number">2</span> 别名</span><br><span class="line"><span class="keyword">set</span> 列<span class="operator">=</span>值,....</span><br><span class="line"><span class="keyword">WHERE</span> 连接条件</span><br><span class="line"><span class="keyword">and</span> 筛选条件;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- sql99语法</span></span><br><span class="line">update 表<span class="number">1</span> 别名</span><br><span class="line"><span class="keyword">inner</span><span class="operator">|</span><span class="keyword">left</span><span class="operator">|</span><span class="keyword">right</span> <span class="keyword">join</span> 表<span class="number">2</span> 别名</span><br><span class="line"><span class="keyword">on</span> 连接条件</span><br><span class="line"><span class="keyword">set</span> 列<span class="operator">=</span>值,....</span><br><span class="line"><span class="keyword">WHERE</span> 筛选条件;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 案例1</span></span><br><span class="line">UPDATE boys bo</span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> beauty b <span class="keyword">on</span> bo.id <span class="operator">=</span> b.boyfriend_id</span><br><span class="line"><span class="keyword">SET</span> b.phone<span class="operator">=</span><span class="number">114</span></span><br><span class="line"><span class="keyword">WHERE</span> bo.boyName<span class="operator">=</span><span class="string">&#x27;张无忌&#x27;</span>;</span><br></pre></td></tr></table></figure>

<h2 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h2><ol>
<li>delete语句：语法：<code>delete from 表名 where 筛选条件;</code></li>
<li>truncate语句：语法：<code>truncate table 表名;</code></li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 案例1：删除姓李所有信息</span></span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> stuinfo <span class="keyword">WHERE</span> stuname <span class="keyword">LIKE</span> <span class="string">&#x27;李%&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 案例2：删除表中所有数据</span></span><br><span class="line"><span class="keyword">TRUNCATE</span> <span class="keyword">TABLE</span> stuinfo ;</span><br></pre></td></tr></table></figure>

<h3 id="【面试题】delete和truncate的区别"><a href="#【面试题】delete和truncate的区别" class="headerlink" title="【面试题】delete和truncate的区别"></a>【面试题】delete和truncate的区别</h3><ol>
<li><code>delete</code>可以添加<code>WHERE</code>条件<br><code>TRUNCATE</code>不能添加<code>WHERE</code>条件，一次性清除所有数据</li>
<li><code>truncate</code>的效率较高</li>
<li>如果删除带自增长列的表，<br>使用<code>DELETE</code>删除后，重新插入数据，记录从断点处开始<br>使用<code>TRUNCATE</code>删除后，重新插入数据，记录从1开始</li>
<li><code>delete</code> 删除数据，会返回受影响的行数<br><code>TRUNCATE</code>删除数据，不返回受影响的行数</li>
<li><code>delete</code>删除数据，可以支持事务回滚<br><code>TRUNCATE</code>删除数据，不支持事务回滚</li>
</ol>
<h1 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h1><p>概念：由一条或多条sql语句组成，要么都成功，要么都失败</p>
<p>特性：ACID：原子性、一致性、隔离性、持久性</p>
<p>分类：</p>
<ul>
<li>隐式事务：没有明显的开启和结束标记<pre><code>     比如dml语句的insert、update、delete语句本身就是一条事务
     `insert into stuinfo values(1,&#39;john&#39;,&#39;男&#39;,&#39;ert@dd.com&#39;,12);`
</code></pre>
</li>
<li>显式事务：具有明显的开启和结束标记<pre><code>     一般由多条sql语句组成，必须具有明显的开启和结束标记
</code></pre>
</li>
</ul>
<p>步骤：取消隐式事务自动开启的功能</p>
<ol>
<li>开启事务</li>
<li>编写事务需要的sql语句（1条或多条）<br><code>insert into stuinfo values(1,&#39;john&#39;,&#39;男&#39;,&#39;ert@dd.com&#39;,12);</code><br><code>insert into stuinfo values(1,&#39;john&#39;,&#39;男&#39;,&#39;ert@dd.com&#39;,12);</code></li>
<li>结束事务</li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> VARIABLES <span class="keyword">LIKE</span> <span class="string">&#x27;%auto%&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 演示事务的使用步骤</span></span><br><span class="line"><span class="comment">-- 1、取消事务自动开启</span></span><br><span class="line"><span class="keyword">SET</span> autocommit <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 2、开启事务</span></span><br><span class="line"><span class="keyword">START</span> TRANSACTION;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 3、编写事务的sql语句</span></span><br><span class="line"><span class="comment">-- 将张三丰的钱-5000</span></span><br><span class="line">UPDATE stuinfo <span class="keyword">SET</span> balance<span class="operator">=</span>balance<span class="number">-5000</span> <span class="keyword">WHERE</span> stuid <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="comment">-- 将灭绝的钱+5000</span></span><br><span class="line">UPDATE stuinfo <span class="keyword">SET</span> balance<span class="operator">=</span>balance<span class="operator">+</span><span class="number">5000</span> <span class="keyword">WHERE</span> stuid <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 4、结束事务</span></span><br><span class="line"><span class="comment">-- 提交</span></span><br><span class="line"><span class="keyword">commit</span>;</span><br><span class="line"><span class="comment">-- 回滚</span></span><br><span class="line"><span class="keyword">ROLLBACK</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> stuinfo;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>学习笔记</category>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>django笔记04 - 数据库</title>
    <url>/2019/01/26/django%E7%AC%94%E8%AE%B004/</url>
    <content><![CDATA[<h1 id="Django配置连接数据库"><a href="#Django配置连接数据库" class="headerlink" title="Django配置连接数据库"></a>Django配置连接数据库</h1><p>settings.py文件中数据库相关的配置</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">DATABASES = &#123;</span><br><span class="line">    <span class="string">&#x27;default&#x27;</span>: &#123;</span><br><span class="line">        <span class="comment"># 数据库引擎（是mysql还是oracle等）</span></span><br><span class="line">        <span class="string">&#x27;ENGINE&#x27;</span>: <span class="string">&#x27;django.db.backends.mysql&#x27;</span>,</span><br><span class="line">        <span class="comment"># 数据库的名字</span></span><br><span class="line">        <span class="string">&#x27;NAME&#x27;</span>: <span class="string">&#x27;dfz&#x27;</span>,</span><br><span class="line">        <span class="comment"># 连接mysql数据库的用户名</span></span><br><span class="line">        <span class="string">&#x27;USER&#x27;</span>: <span class="string">&#x27;root&#x27;</span>,</span><br><span class="line">        <span class="comment"># 连接mysql数据库的密码</span></span><br><span class="line">        <span class="string">&#x27;PASSWORD&#x27;</span>: <span class="string">&#x27;root&#x27;</span>,</span><br><span class="line">        <span class="comment"># mysql数据库的主机地址</span></span><br><span class="line">        <span class="string">&#x27;HOST&#x27;</span>: <span class="string">&#x27;127.0.0.1&#x27;</span>,</span><br><span class="line">        <span class="comment"># mysql数据库的端口号</span></span><br><span class="line">        <span class="string">&#x27;PORT&#x27;</span>: <span class="string">&#x27;3306&#x27;</span>,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h1 id="在Django中操作数据库"><a href="#在Django中操作数据库" class="headerlink" title="在Django中操作数据库"></a>在Django中操作数据库</h1><p>下面是使用原生sql语句操作</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 使用django封装好的connection对象，会自动读取settings.py中数据库的配置信息</span></span><br><span class="line"><span class="keyword">from</span> django.db <span class="keyword">import</span> connection</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取游标对象</span></span><br><span class="line">cursor = connection.cursor()</span><br><span class="line"><span class="comment"># 拿到游标对象后执行sql语句</span></span><br><span class="line">cursor.execute(<span class="string">&quot;select * from book&quot;</span>)</span><br><span class="line"><span class="comment"># 获取所有的数据</span></span><br><span class="line">rows = cursor.fetchall()</span><br><span class="line"><span class="comment"># 遍历查询到的数据</span></span><br><span class="line"><span class="keyword">for</span> row <span class="keyword">in</span> rows:</span><br><span class="line">    <span class="built_in">print</span>(row)</span><br></pre></td></tr></table></figure>

<p>以上的<code>execute</code>以及<code>fetchall</code>方法都是<code>Python DB API</code>规范中定义好的。任何使用<code>Python</code>来操作<code>MySQL</code>的驱动程序都应该遵循这个规范。所以不管是使用<code>pymysql</code>或者是<code>mysqlclient</code>或者是<code>mysqldb</code>，他们的接口都是一样的。</p>
<h1 id="Python-DB-API下规范下cursor对象常用接口："><a href="#Python-DB-API下规范下cursor对象常用接口：" class="headerlink" title="Python DB API下规范下cursor对象常用接口："></a>Python DB API下规范下cursor对象常用接口：</h1><ol>
<li><code>description</code>：如果<code>cursor</code>执行了查询的<code>sql</code>代码。那么读取<code>cursor.description</code>属性的时候，将返回一个列表，这个列表中装的是元组，元组中装的分别是<code>(name,type_code,display_size,internal_size,precision,scale,null_ok)</code>，其中<code>name</code>代表的是查找出来的数据的字段名称，其他参数暂时用处不大。</li>
<li><code>rowcount</code>：代表的是在执行了<code>sql</code>语句后受影响的行数。</li>
<li><code>close</code>：关闭游标。关闭游标以后就再也不能使用了，否则会抛出异常。</li>
<li><code>execute(sql[,parameters])</code>：执行某个<code>sql</code>语句。如果在执行<code>sql</code>语句的时候还需要传递参数，那么可以传给<code>parameters</code>参数。示例代码如下：</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">cursor.execute(<span class="string">&quot;select * from article where id=%s&quot;</span>,(<span class="number">1</span>,))</span><br></pre></td></tr></table></figure>

<ol start="5">
<li><code>fetchone</code>：在执行了查询操作以后，获取第一条数据。</li>
<li><code>fetchmany(size)</code>：在执行查询操作以后，获取多条数据。具体是多少条要看传的<code>size</code>参数。如果不传<code>size</code>参数，那么默认是获取第一条数据。</li>
<li><code>fetchall</code>：获取所有满足<code>sql</code>语句的数据。</li>
</ol>
<h1 id="ORM模型的创建和映射："><a href="#ORM模型的创建和映射：" class="headerlink" title="ORM模型的创建和映射："></a>ORM模型的创建和映射：</h1><h2 id="创建ORM模型："><a href="#创建ORM模型：" class="headerlink" title="创建ORM模型："></a>创建ORM模型：</h2><p><code>ORM</code>模型一般都是放在<code>app</code>的<code>models.py</code>文件中。每个<code>app</code>都可以拥有自己的模型。并且如果这个模型想要映射到数据库中，那么这个<code>app</code>必须要放在<code>settings.py</code>的<code>INSTALLED_APP</code>中进行安装。以下是写一个简单的书籍<code>ORM</code>模型。示例代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.db <span class="keyword">import</span> models</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Book</span>(<span class="params">models.Model</span>):</span></span><br><span class="line">    name = models.CharField(max_length=<span class="number">20</span>,null=<span class="literal">False</span>)</span><br><span class="line">    author = models.CharField(max_length=<span class="number">20</span>,null=<span class="literal">False</span>)</span><br><span class="line">    pub_time = models.DateTimeField(default=datetime.now)</span><br><span class="line">    price = models.FloatField(default=<span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<p>以上便定义了一个模型。这个模型继承自<code>django.db.models.Model</code>，如果这个模型想要映射到数据库中，就必须继承自这个类。这个模型以后映射到数据库中，表名是模型名称的小写形式，为<code>book</code>。在这个表中，有四个字段，一个为<code>name</code>，这个字段是保存的是书的名称，是<code>varchar</code>类型，最长不能超过20个字符，并且不能为空。第二个字段是作者名字类型，同样也是<code>varchar</code>类型，长度不能超过20个。第三个是出版时间，数据类型是<code>datetime</code>类型，默认是保存这本书籍的时间。第五个是这本书的价格，是浮点类型。<br>还有一个字段我们没有写，就是主键<code>id</code>，在<code>django</code>中，如果一个模型没有定义主键，那么将会自动生成一个自动增长的<code>int</code>类型的主键，并且这个主键的名字就叫做<code>id</code>。</p>
<h2 id="映射模型到数据库中："><a href="#映射模型到数据库中：" class="headerlink" title="映射模型到数据库中："></a>映射模型到数据库中：</h2><p>将<code>ORM</code>模型映射到数据库中，总结起来就是以下几步：</p>
<ol>
<li>在<code>settings.py</code>中，配置好<code>DATABASES</code>，做好数据库相关的配置。</li>
<li>在<code>app</code>中的<code>models.py</code>中定义好模型，这个模型必须继承自<code>django.db.models</code>。</li>
<li>将这个<code>app</code>添加到<code>settings.py</code>的<code>INSTALLED_APP</code>中。</li>
<li>在命令行终端，进入到项目所在的路径，然后执行命令<code>python manage.py makemigrations</code>来生成迁移脚本文件。</li>
<li>同样在命令行中，执行命令<code>python manage.py migrate</code>来将迁移脚本文件映射到数据库中。</li>
</ol>
<h1 id="ORM对数据库的基本操作"><a href="#ORM对数据库的基本操作" class="headerlink" title="ORM对数据库的基本操作"></a>ORM对数据库的基本操作</h1><h2 id="添加数据"><a href="#添加数据" class="headerlink" title="添加数据"></a>添加数据</h2><p>只要使用ORM模型创建一个对象。然后再调用这个ORM模型的<code>save</code>方法就可以保存了。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">book = Book(name=<span class="string">&#x27;西游记&#x27;</span>,author=<span class="string">&#x27;吴承恩&#x27;</span>,price=<span class="number">100</span>)</span><br><span class="line">book.save()</span><br></pre></td></tr></table></figure>

<h2 id="查找数据："><a href="#查找数据：" class="headerlink" title="查找数据："></a>查找数据：</h2><p>所有的查找工作都是使用模型上的<code>objects</code>属性来完成的。当然也可以自定义查询对象。这部分功能会在后面讲到。</p>
<ol>
<li>根据主键进行查找：使用主键进行查找。可以使用<code>objects.get</code>方法。然后传递<code>pk=xx</code>的方式进行查找。示例代码如下：</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">book = Book.objects.get(pk=<span class="number">2</span>)</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>根据其他字段进行查找：可以使用<code>objects.filter</code>方法进行查找。示例代码如下：</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">books = Book.objects.<span class="built_in">filter</span>(name=<span class="string">&#x27;三国演义&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>使用<code>filter</code>方法返回来的是一个<code>QuerySet</code>对象。这个对象类似于列表。我们可以使用这个对象的<code>first</code>方法来获取第一个值。</p>
<h2 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h2><p>首先查找到对应的数据模型。然后再执行这个模型的<code>delete</code>方法即可删除。示例代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">book = Book.objects.get(pk=<span class="number">1</span>)</span><br><span class="line">book.delete()</span><br></pre></td></tr></table></figure>

<h2 id="修改数据："><a href="#修改数据：" class="headerlink" title="修改数据："></a>修改数据：</h2><p>首先查找到对应的数据模型。然后修改这个模型上的属性的值。再执行<code>save</code>方法即可修改完成。示例代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">book = Book.objects.get(pk=<span class="number">2</span>)</span><br><span class="line">book.price = <span class="number">200</span></span><br><span class="line">book.save()</span><br></pre></td></tr></table></figure>

<h1 id="常用Field笔记："><a href="#常用Field笔记：" class="headerlink" title="常用Field笔记："></a>常用Field笔记：</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Article</span>(<span class="params">models.Model</span>):</span></span><br><span class="line">    <span class="comment"># 如果想要使用自己定义的Field来作为主键，那么必须设置primary_key=True</span></span><br><span class="line">    <span class="built_in">id</span> = models.BigAutoField(primary_key=<span class="literal">True</span>)</span><br><span class="line">    <span class="comment"># 在定义字段的时候，如果没有指定null=True，那么默认情况下，null=False</span></span><br><span class="line">    <span class="comment"># 就是不能为空</span></span><br><span class="line">    <span class="comment"># 如果想要使用可以为null的BooleanField，那么应该使用NullBooleanField来代替</span></span><br><span class="line">    removed = models.NullBooleanField()</span><br><span class="line">    <span class="comment"># CharField：如果是超过了254个字符，那么就不建议使用啦</span></span><br><span class="line">    <span class="comment"># 就推荐使用TextField：longtext</span></span><br><span class="line">    title = models.CharField(max_length=<span class="number">200</span>)</span><br><span class="line">    <span class="comment"># auto_now_add：是在第一次添加数据进去的时候会自动获取当前的时间，创建时间</span></span><br><span class="line">    <span class="comment"># auto_now：每次这个对象调用save方法的时候都会将当前的时间更新，更新时间</span></span><br><span class="line">    create_time = models.DateTimeField(auto_now=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>

<h2 id="navie时间和aware时间"><a href="#navie时间和aware时间" class="headerlink" title="navie时间和aware时间"></a>navie时间和aware时间</h2><ol>
<li>navie时间：不知道自己的时间表示的是哪个时区的。也就是不知道自己几斤几两。比较幼稚。</li>
<li>aware时间：知道自己的时间表示的是哪个时区的。也就是比较清醒。</li>
</ol>
<h3 id="pytz库"><a href="#pytz库" class="headerlink" title="pytz库"></a>pytz库</h3><p>专门用来处理时区的库。这个库会经常更新一些时区的数据，不需要我们担心。并且这个库在安装Django的时候会默认的安装。如果没有安装，那么可以通过<code>pip install pytz</code>的方式进行安装。</p>
<h3 id="astimezone方法："><a href="#astimezone方法：" class="headerlink" title="astimezone方法："></a>astimezone方法：</h3><p>将一个时区的时间转换为另外一个时区的时间。这个方法只能被<code>aware</code>类型的时间调用。不能被<code>navie</code>类型的时间调用。<br>示例代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pytz</span><br><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</span><br><span class="line">now = datetime.now() <span class="comment"># 这是一个navie类型的时间</span></span><br><span class="line">utc_timezone = pytz.timezone(<span class="string">&quot;UTC&quot;</span>) <span class="comment"># 定义UTC的时区对象</span></span><br><span class="line">utc_now = now.astimezone(utc_timezone) <span class="comment"># 将当前的时间转换为UTC时区的时间</span></span><br><span class="line">&gt;&gt; ValueError: astimezone() cannot be applied to a naive datetime <span class="comment"># 会抛出一个异常，原因就是因为navie类型的时间不能调用astimezone方法</span></span><br><span class="line"></span><br><span class="line">now = now.replace(tzinfo=pytz.timezone(<span class="string">&#x27;Asia/Shanghai&#x27;</span>))</span><br><span class="line">utc_now = now.astimezone(utc_timezone)</span><br><span class="line"><span class="comment"># 这时候就可以正确的转换。</span></span><br></pre></td></tr></table></figure>

<h3 id="replace方法"><a href="#replace方法" class="headerlink" title="replace方法"></a>replace方法</h3><p>可以将一个时间的某些属性进行更改。</p>
<h3 id="django-utils-timezone-now方法"><a href="#django-utils-timezone-now方法" class="headerlink" title="django.utils.timezone.now方法"></a>django.utils.timezone.now方法</h3><p>会根据<code>settings.py</code>中是否设置了<code>USE_TZ=True</code>获取当前的时间。如果设置了，那么就获取一个<code>aware</code>类型的<code>UTC</code>时间。如果没有设置，那么就会获取一个<code>navie</code>类型的时间。</p>
<h3 id="django-utils-timezone-localtime方法"><a href="#django-utils-timezone-localtime方法" class="headerlink" title="django.utils.timezone.localtime方法"></a>django.utils.timezone.localtime方法</h3><p>会根据<code>setting.py</code>中的<code>TIME_ZONE</code>来将一个<code>aware</code>类型的时间转换为<code>TIME_ZONE</code>指定时区的时间。<br>html模板中，会自动转换为当前时区时间。<code>views</code>中可以使用<code>localtime</code>转换为当前时区</p>
<h2 id="DateField："><a href="#DateField：" class="headerlink" title="DateField："></a>DateField：</h2><p>日期类型。在<code>Python</code>中是<code>datetime.date</code>类型，可以记录年月日。在映射到数据库中也是<code>date</code>类型。使用这个<code>Field</code>可以传递以下几个参数：</p>
<ol>
<li><code>auto_now</code>：在每次这个数据保存的时候，都使用当前的时间。比如作为一个记录修改日期的字段，可以将这个属性设置为<code>True</code>。</li>
<li><code>auto_now_add</code>：在每次数据第一次被添加进去的时候，都使用当前的时间。比如作为一个记录第一次入库的字段，可以将这个属性设置为<code>True</code>。</li>
</ol>
<h2 id="DateTimeField："><a href="#DateTimeField：" class="headerlink" title="DateTimeField："></a>DateTimeField：</h2><p>日期时间类型，类似于<code>DateField</code>。不仅仅可以存储日期，还可以存储时间。映射到数据库中是<code>datetime</code>类型。这个<code>Field</code>也可以使用<code>auto_now</code>和<code>auto_now_add</code>两个属性。</p>
<h2 id="TimeField："><a href="#TimeField：" class="headerlink" title="TimeField："></a>TimeField：</h2><p>时间类型。在数据库中是<code>time</code>类型。在<code>Python</code>中是<code>datetime.time</code>类型。</p>
<h2 id="EmailField："><a href="#EmailField：" class="headerlink" title="EmailField："></a>EmailField：</h2><p>类似于<code>CharField</code>。在数据库底层也是一个<code>varchar</code>类型。最大长度是254个字符。</p>
<h2 id="FileField："><a href="#FileField：" class="headerlink" title="FileField："></a>FileField：</h2><p>用来存储文件的。这个请参考后面的文件上传章节部分。</p>
<h3 id="ImageField："><a href="#ImageField：" class="headerlink" title="ImageField："></a>ImageField：</h3><p>用来存储图片文件的。这个请参考后面的图片上传章节部分。</p>
<h3 id="FloatField："><a href="#FloatField：" class="headerlink" title="FloatField："></a>FloatField：</h3><p>浮点类型。映射到数据库中是<code>float</code>类型。</p>
<h3 id="IntegerField："><a href="#IntegerField：" class="headerlink" title="IntegerField："></a>IntegerField：</h3><p>整形。值的区间是<code>-2147483648——2147483647</code>。</p>
<h3 id="BigIntegerField："><a href="#BigIntegerField：" class="headerlink" title="BigIntegerField："></a>BigIntegerField：</h3><p>大整形。值的区间是<code>-9223372036854775808——9223372036854775807</code>。</p>
<h3 id="PositiveIntegerField："><a href="#PositiveIntegerField：" class="headerlink" title="PositiveIntegerField："></a>PositiveIntegerField：</h3><p>正整形。值的区间是<code>0——2147483647</code>。</p>
<h3 id="SmallIntegerField："><a href="#SmallIntegerField：" class="headerlink" title="SmallIntegerField："></a>SmallIntegerField：</h3><p>小整形。值的区间是<code>-32768——32767</code>。</p>
<h3 id="PositiveSmallIntegerField："><a href="#PositiveSmallIntegerField：" class="headerlink" title="PositiveSmallIntegerField："></a>PositiveSmallIntegerField：</h3><p>正小整形。值的区间是<code>0——32767</code>。</p>
<h3 id="TextField："><a href="#TextField：" class="headerlink" title="TextField："></a>TextField：</h3><p>大量的文本类型。映射到数据库中是longtext类型。</p>
<h3 id="UUIDField："><a href="#UUIDField：" class="headerlink" title="UUIDField："></a>UUIDField：</h3><p>只能存储<code>uuid</code>格式的字符串。<code>uuid</code>是一个32位的全球唯一的字符串，一般用来作为主键。</p>
<h3 id="URLField："><a href="#URLField：" class="headerlink" title="URLField："></a>URLField：</h3><p>类似于<code>CharField</code>，只不过只能用来存储<code>url</code>格式的字符串。并且默认的<code>max_length</code>是200。</p>
<h2 id="Field常用的参数"><a href="#Field常用的参数" class="headerlink" title="Field常用的参数"></a>Field常用的参数</h2><h3 id="null："><a href="#null：" class="headerlink" title="null："></a>null：</h3><p>如果设置为<code>True</code>，<code>Django</code>将会在映射表的时候指定是否为空。默认是为<code>False</code>。在使用字符串相关的<code>Field</code>（CharField/TextField）的时候，官方推荐尽量不要使用这个参数，也就是保持默认值<code>False</code>。因为<code>Django</code>在处理字符串相关的<code>Field</code>的时候，即使这个<code>Field</code>的<code>null=False</code>，如果你没有给这个<code>Field</code>传递任何值，那么<code>Django</code>也会使用一个空的字符串<code>&quot;&quot;</code>来作为默认值存储进去。因此如果再使用<code>null=True</code>，<code>Django</code>会产生两种空值的情形（NULL或者空字符串）。如果想要在表单验证的时候允许这个字符串为空，那么建议使用<code>blank=True</code>。如果你的<code>Field</code>是<code>BooleanField</code>，那么对应的可空的字段则为<code>NullBooleanField</code>。</p>
<h3 id="blank："><a href="#blank：" class="headerlink" title="blank："></a>blank：</h3><p>标识这个字段在表单验证的时候是否可以为空。默认是<code>False</code>。<br>这个和<code>null</code>是有区别的，<code>null</code>是一个纯数据库级别的。而<code>blank</code>是表单验证级别的。</p>
<h3 id="db-column："><a href="#db-column：" class="headerlink" title="db_column："></a>db_column：</h3><p>这个字段在数据库中的名字。如果没有设置这个参数，那么将会使用模型中属性的名字。</p>
<h3 id="default："><a href="#default：" class="headerlink" title="default："></a>default：</h3><p>默认值。可以为一个值，或者是一个函数，但是不支持<code>lambda</code>表达式。并且不支持列表/字典/集合等可变的数据结构。</p>
<h3 id="primary-key："><a href="#primary-key：" class="headerlink" title="primary_key："></a>primary_key：</h3><p>是否为主键。默认是<code>False</code>。</p>
<h3 id="unique："><a href="#unique：" class="headerlink" title="unique："></a>unique：</h3><p>在表中这个字段的值是否唯一。一般是设置手机号码/邮箱等。</p>
<h2 id="模型中Meta配置"><a href="#模型中Meta配置" class="headerlink" title="模型中Meta配置"></a>模型中<code>Meta</code>配置</h2><p>对于一些模型级别的配置。我们可以在模型中定义一个类，叫做<code>Meta</code>。然后在这个类中添加一些类属性来控制模型的作用。比如我们想要在数据库映射的时候使用自己指定的表名，而不是使用模型的名称。那么我们可以在<code>Meta</code>类中添加一个<code>db_table</code>的属性。示例代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Book</span>(<span class="params">models.Model</span>):</span></span><br><span class="line">    name = models.CharField(max_length=<span class="number">20</span>,null=<span class="literal">False</span>)</span><br><span class="line">    desc = models.CharField(max_length=<span class="number">100</span>,name=<span class="string">&#x27;description&#x27;</span>,db_column=<span class="string">&quot;description1&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Meta</span>:</span></span><br><span class="line">    db_table = <span class="string">&#x27;book_model&#x27;</span></span><br></pre></td></tr></table></figure>

<p>以下将对<code>Meta</code>类中的一些常用配置进行解释。</p>
<h3 id="db-table："><a href="#db-table：" class="headerlink" title="db_table："></a>db_table：</h3><p>这个模型映射到数据库中的表名。如果没有指定这个参数，那么在映射的时候将会使用模型名来作为默认的表名。</p>
<h3 id="ordering："><a href="#ordering：" class="headerlink" title="ordering："></a>ordering：</h3><p>设置在提取数据的排序方式。后面章节会讲到如何查找数据。比如我想在查找数据的时候根据添加的时间排序，那么示例代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Book</span>(<span class="params">models.Model</span>):</span></span><br><span class="line">name = models.CharField(max_length=<span class="number">20</span>,null=<span class="literal">False</span>)</span><br><span class="line">desc = models.CharField(max_length=<span class="number">100</span>,name=<span class="string">&#x27;description&#x27;</span>,db_column=<span class="string">&quot;description1&quot;</span>)</span><br><span class="line">pub_date = models.DateTimeField(auto_now_add=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Meta</span>:</span></span><br><span class="line">db_table = <span class="string">&#x27;book_model&#x27;</span></span><br><span class="line">ordering = [<span class="string">&#x27;pub_date&#x27;</span>]     <span class="comment">#[&#x27;-pub_date&#x27;]是反向排序</span></span><br></pre></td></tr></table></figure>

<h1 id="外键和表关系"><a href="#外键和表关系" class="headerlink" title="外键和表关系"></a>外键和表关系</h1><h2 id="外键"><a href="#外键" class="headerlink" title="外键"></a>外键</h2><p>在<code>MySQL</code>中，表有两种引擎，一种是<code>InnoDB</code>，另外一种是<code>myisam</code>。如果使用的是<code>InnoDB</code>引擎，是支持外键约束的。外键的存在使得<code>ORM</code>框架在处理表关系的时候异常的强大。因此这里我们首先来介绍下外键在Django中的使用。</p>
<p>类定义为<code>class ForeignKey(to,on_delete,**options)</code>。第一个参数是引用的是哪个模型，第二个参数是在使用外键引用的模型数据被删除了，这个字段该如何处理，比如有<code>CASCADE</code>、<code>SET_NULL</code>等。这里以一个实际案例来说明。比如有一个<code>User</code>和一个<code>Article</code>两个模型。一个<code>User</code>可以发表多篇文章，一个<code>Article</code>只能有一个<code>Author</code>，并且通过外键进行引用。那么相关的示例代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span>(<span class="params">models.Model</span>):</span></span><br><span class="line">    username = models.CharField(max_length=<span class="number">20</span>)</span><br><span class="line">    password = models.CharField(max_length=<span class="number">100</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Article</span>(<span class="params">models.Model</span>):</span></span><br><span class="line">    title = models.CharField(max_length=<span class="number">100</span>)</span><br><span class="line">    content = models.TextField()</span><br><span class="line">    author = models.ForeignKey(<span class="string">&quot;User&quot;</span>,on_delete=models.CASCADE)  <span class="comment">#外键</span></span><br></pre></td></tr></table></figure>

<p>以上使用ForeignKey来定义模型之间的关系。即在article的实例中可以通过author属性来操作对应的User模型。这样使用起来非常的方便。示例代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">article = Article(title=<span class="string">&#x27;abc&#x27;</span>,content=<span class="string">&#x27;123&#x27;</span>)</span><br><span class="line">author = User(username=<span class="string">&#x27;张三&#x27;</span>,password=<span class="string">&#x27;111111&#x27;</span>)</span><br><span class="line">article.author = author</span><br><span class="line">article.save()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改article.author上的值</span></span><br><span class="line">article.author.username = <span class="string">&#x27;李四&#x27;</span></span><br><span class="line">article.save()</span><br></pre></td></tr></table></figure>

<p>为什么使用了<code>ForeignKey</code>后，就能通过<code>author</code>访问到对应的<code>user</code>对象呢。因此在底层，<code>Django</code>为<code>Article</code>表添加了一个属性名<code>_id</code>的字段（比如<code>author</code>的字段名称是<code>author_id</code>），这个字段是一个外键，记录着对应的作者的主键。以后通过<code>article.author</code>访问的时候，实际上是先通过<code>author_id</code>找到对应的数据，然后再提取<code>User</code>表中的这条数据，形成一个模型。</p>
<p>如果想要引用另外一个app的模型，那么应该在传递to参数的时候，使用<code>app.model_name</code>进行指定。以上例为例，如果<code>User</code>和<code>Article</code>不是在同一个<code>app</code>中，那么在引用的时候的示例代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># User模型在user这个app中</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span>(<span class="params">models.Model</span>):</span></span><br><span class="line">    username = models.CharField(max_length=<span class="number">20</span>)</span><br><span class="line">    password = models.CharField(max_length=<span class="number">100</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Article模型在article这个app中</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Article</span>(<span class="params">models.Model</span>):</span></span><br><span class="line">    title = models.CharField(max_length=<span class="number">100</span>)</span><br><span class="line">    content = models.TextField()</span><br><span class="line">    author = models.ForeignKey(<span class="string">&quot;user.User&quot;</span>,on_delete=models.CASCADE)  <span class="comment">#引用时指定所在app，app.model_name</span></span><br></pre></td></tr></table></figure>

<p>如果模型的外键引用的是本身自己这个模型，那么<code>to</code>参数可以为<code>self</code>，或者是这个模型的名字。在论坛开发中，一般评论都可以进行二级评论，即可以针对另外一个评论进行评论，那么在定义模型的时候就需要使用外键来引用自身。示例代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Comment</span>(<span class="params">models.Model</span>):</span></span><br><span class="line">    content = models.TextField()</span><br><span class="line">    origin_comment = models.ForeignKey(<span class="string">&#x27;self&#x27;</span>,on_delete=models.CASCADE,null=<span class="literal">True</span>)</span><br><span class="line">    <span class="comment"># 或者</span></span><br><span class="line">    <span class="comment"># origin_comment = models.ForeignKey(&#x27;Comment&#x27;,on_delete=models.CASCADE,null=True)</span></span><br></pre></td></tr></table></figure>

<h2 id="外键删除操作"><a href="#外键删除操作" class="headerlink" title="外键删除操作"></a>外键删除操作</h2><p>如果一个模型使用了外键。那么在对方那个模型被删掉后，该进行什么样的操作。可以通过<code>on_delete</code>来指定。可以指定的类型如下：</p>
<ol>
<li><code>CASCADE</code>：级联操作。如果外键对应的那条数据被删除了，那么这条数据也会被删除。</li>
<li><code>PROTECT</code>：受保护。即只要这条数据引用了外键的那条数据，那么就不能删除外键的那条数据。</li>
<li><code>SET_NULL</code>：设置为空。如果外键的那条数据被删除了，那么在本条数据上就将这个字段设置为空。如果设置这个选项，前提是要指定这个字段可以为空。</li>
<li><code>SET_DEFAULT</code>：设置默认值。如果外键的那条数据被删除了，那么本条数据上就将这个字段设置为默认值。如果设置这个选项，前提是要指定这个字段一个默认值。</li>
<li><code>SET()</code>：如果外键的那条数据被删除了。那么将会获取SET函数中的值来作为这个外键的值。SET函数可以接收一个可以调用的对象（比如函数或者方法），如果是可以调用的对象，那么会将这个对象调用后的结果作为值返回回去。</li>
<li><code>DO_NOTHING</code>：不采取任何行为。一切全看数据库级别的约束。</li>
</ol>
<p><strong>以上这些选项只是Django级别的，数据级别依旧是RESTRICT！</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Article</span>(<span class="params">models.Model</span>):</span></span><br><span class="line">    category = models.ForeignKey(<span class="string">&#x27;Category&#x27;</span>, on_delete=models.SET(Category.objects.get(pk=<span class="number">4</span>)), null=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>

<h2 id="表关系笔记："><a href="#表关系笔记：" class="headerlink" title="表关系笔记："></a>表关系笔记：</h2><h3 id="一对多："><a href="#一对多：" class="headerlink" title="一对多："></a>一对多：</h3><ol>
<li>应用场景：比如文章和作者之间的关系。一个文章只能由一个作者编写，但是一个作者可以写多篇文章。文章和作者之间的关系就是典型的多对一的关系。</li>
<li>实现方式：一对多或者多对一，都是通过<code>ForeignKey</code>来实现的。还是以文章和作者的案例进行讲解。</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span>(<span class="params">models.Model</span>):</span></span><br><span class="line">    username = models.CharField(max_length=<span class="number">20</span>)</span><br><span class="line">    password = models.CharField(max_length=<span class="number">100</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Article</span>(<span class="params">models.Model</span>):</span></span><br><span class="line">    title = models.CharField(max_length=<span class="number">100</span>)</span><br><span class="line">    content = models.TextField()</span><br><span class="line">    author = models.ForeignKey(<span class="string">&quot;User&quot;</span>,on_delete=models.CASCADE)</span><br></pre></td></tr></table></figure>

<p>那么以后在给<code>Article</code>对象指定<code>author</code>，就可以使用以下代码来完成：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">article = Article(title=<span class="string">&#x27;abc&#x27;</span>,content=<span class="string">&#x27;123&#x27;</span>)</span><br><span class="line">author = User(username=<span class="string">&#x27;zhiliao&#x27;</span>,password=<span class="string">&#x27;111111&#x27;</span>)</span><br><span class="line"><span class="comment"># 要先保存到数据库中</span></span><br><span class="line">author.save()</span><br><span class="line">article.author = author</span><br><span class="line">article.save()</span><br></pre></td></tr></table></figure>

<p>并且以后如果想要获取某个用户下所有的文章，可以通过<code>article_set</code>来实现。示例代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">user = User.objects.first()</span><br><span class="line"><span class="comment"># 获取第一个用户写的所有文章</span></span><br><span class="line">articles = user.article_set.<span class="built_in">all</span>()</span><br><span class="line"><span class="keyword">for</span> article <span class="keyword">in</span> articles:</span><br><span class="line">    <span class="built_in">print</span>(article)</span><br></pre></td></tr></table></figure>

<p>并且如果想要将文章添加到某个分类中。可以使用一下的方式：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">category = Category.objects.first()</span><br><span class="line">article = Article(title=<span class="string">&#x27;bbb&#x27;</span>,content=<span class="string">&#x27;vvv&#x27;</span>)</span><br><span class="line">article.author = FrontUser.objects.first()</span><br><span class="line">category.article_set.add(article,bulk=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li>使用<code>bulk=False</code>，那么Django会自动的保存article，而不需要在添加到category之前先保存article。</li>
<li>或者是另外一种解决方式是，在添加到<code>category.article_set</code>中之前，先将<code>article</code>保存到数据库中。但是如果<code>article.category</code>不能为空，那么就产生一种死循环了，article没有<code>category</code>不能保存，而将article添加到<code>cateogry.artile_set</code>中，又需要article之前是已经存储到数据库中的。</li>
<li>如果是上面的那种需求，建议使用<code>bulk=False</code>的解决方案。</li>
</ul>
<h3 id="一对一："><a href="#一对一：" class="headerlink" title="一对一："></a>一对一：</h3><ol>
<li>在Django中一对一是通过<code>models.OnetToOneField</code>来实现的。这个<code>OneToOneField</code>其实本质上就是一个外键，只不过这个外键有一个<code>唯一约束（unique key）</code>，来实现一对一。</li>
<li>以后如果想要反向引用，那么是通过引用的模型的名字转换为小写的形式进行访问。比如以下模型：</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FrontUser</span>(<span class="params">models.Model</span>):</span></span><br><span class="line">    username = models.CharField(max_length=<span class="number">200</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserExtension</span>(<span class="params">models.Model</span>):</span></span><br><span class="line">    school = models.CharField(max_length=<span class="number">100</span>)</span><br><span class="line">    user = models.OneToOneField(<span class="string">&quot;FrontUser&quot;</span>,on_delete=models.CASCADE)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过userextension来访问UserExtension对象</span></span><br><span class="line">user = FrontUser.objects.first()</span><br><span class="line"><span class="built_in">print</span>(user.userextension)</span><br></pre></td></tr></table></figure>

<p><code>UserExtension</code>的对象，可以通过<code>user</code>来访问到对应的user对象。并且<code>FrontUser</code>对象可以使用<code>userextension</code>来访问对应的<code>UserExtension</code>对象。<br>如果不想使用Django默认的引用属性名字。那么可以在<code>OneToOneField</code>中添加一个<code>related_name</code>参数。示例代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FrontUser</span>(<span class="params">models.Model</span>):</span></span><br><span class="line">    username = models.CharField(max_length=<span class="number">200</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserExtension</span>(<span class="params">models.Model</span>):</span></span><br><span class="line">    school = models.CharField(max_length=<span class="number">100</span>)</span><br><span class="line">    user = models.OneToOneField(<span class="string">&quot;FrontUser&quot;</span>,on_delete=models.CASCADE,related_name=<span class="string">&#x27;extension&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过extension来访问到UserExtension对象</span></span><br><span class="line">user = FrontUser.objects.first()</span><br><span class="line"><span class="built_in">print</span>(user.extension)</span><br></pre></td></tr></table></figure>

<p>那么以后就<code>FrontUser</code>的对象就可以通过<code>extension</code>属性来访问到对应的<code>UserExtension</code>对象。</p>
<h3 id="多对多："><a href="#多对多：" class="headerlink" title="多对多："></a>多对多：</h3><ol>
<li><p>应用场景：比如文章和标签的关系。一篇文章可以有多个标签，一个标签可以被多个文章所引用。因此标签和文章的关系是典型的多对多的关系。</p>
</li>
<li><p>实现方式：<code>Django</code>为这种多对多的实现提供了专门的<code>Field</code>。叫做<code>ManyToManyField</code>。还是拿文章和标签为例进行讲解。示例代码如下：</p>
</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Article</span>(<span class="params">models.Model</span>):</span></span><br><span class="line">    title = models.CharField(max_length=<span class="number">100</span>)</span><br><span class="line">    content = models.TextField()</span><br><span class="line">    tags = models.ManyToManyField(<span class="string">&quot;Tag&quot;</span>,related_name=<span class="string">&quot;articles&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tag</span>(<span class="params">models.Model</span>):</span></span><br><span class="line">    name = models.CharField(max_length=<span class="number">50</span>)</span><br></pre></td></tr></table></figure>

<p>在数据库层面，实际上<code>Django</code>是为这种多对多的关系建立了一个中间表。这个中间表分别定义了两个外键，引用到<code>article</code>和<code>tag</code>两张表的主键。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">many_to_many_view</span>(<span class="params">request</span>):</span></span><br><span class="line">    <span class="comment"># article = Article.objects.first()  #获得文章</span></span><br><span class="line">    <span class="comment"># tag = Tag(name=&#x27;冷门文章&#x27;)    #新建标签</span></span><br><span class="line">    <span class="comment"># tag.save()</span></span><br><span class="line">    <span class="comment"># article.tag_set.add(tag)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># tag = Tag.objects.get(pk=1)</span></span><br><span class="line">    <span class="comment"># article = Article.objects.get(pk=3)</span></span><br><span class="line">    <span class="comment"># tag.articles.add(article)</span></span><br><span class="line"></span><br><span class="line">    article = Article.objects.get(pk=<span class="number">1</span>)</span><br><span class="line">    tags = article.tags.<span class="built_in">all</span>()</span><br><span class="line">    <span class="keyword">for</span> tag <span class="keyword">in</span> tags:</span><br><span class="line">        <span class="built_in">print</span>(tag)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> HttpResponse(<span class="string">&quot;success&quot;</span>)</span><br></pre></td></tr></table></figure>

<h1 id="查询条件笔记："><a href="#查询条件笔记：" class="headerlink" title="查询条件笔记："></a>查询条件笔记：</h1><h2 id="exact"><a href="#exact" class="headerlink" title="exact"></a>exact</h2><p><code>exact</code>：在底层会被翻译成<code>=</code>。</p>
<h2 id="iexact"><a href="#iexact" class="headerlink" title="iexact"></a>iexact</h2><p><code>iexact</code>：在底层会被翻译成<code>LIKE</code>。</p>
<ul>
<li><code>LIKE</code>和<code>=</code>：大部分情况下都是等价的，只有少数情况下是不等价的。</li>
<li><code>exict</code>和<code>iexact</code>：他们的区别其实就是<code>LIKE</code>和<code>=</code>的区别，因为exact会被翻译成<code>=</code>，而<code>iexact</code>会被翻译成<code>LIKE</code>。</li>
<li>因为<code>field__exact=xxx</code>其实等价于<code>filed=xxx</code>，因此我们直接使用<code>filed=xxx</code>就可以了，并且因为大部分情况<code>exact</code>和<code>iexact</code>又是等价的，因此我们以后直接使用<code>field=xxx</code>就可以了。</li>
</ul>
<h2 id="QuerySet-query"><a href="#QuerySet-query" class="headerlink" title="QuerySet.query"></a>QuerySet.query</h2><p><code>QuerySet.query</code>：<code>query</code>可以用来查看这个<code>ORM</code>查询语句最终被翻译成的<code>SQL</code>语句。但是<code>query</code>只能被用在<code>QuerySet</code>对象上，不能用在普通的<code>ORM模型</code>上。因此如果你的查询语句是通过<code>get</code>来获取数据的，那么就不能使用<code>query</code>，因为<code>get</code>返回的是满足条件的<code>ORM</code>模型，而不是<code>QuerySet</code>。如果你是通过<code>filter</code>等其他返回<code>QuerySet</code>的方法查询的，那么就可以使用<code>query</code>。</p>
<h2 id="contains"><a href="#contains" class="headerlink" title="contains"></a>contains</h2><p><code>contains</code>：使用大小写敏感的判断，某个字符串是否在指定的字段中。这个判断条件会使用大小敏感，因此在被翻译成<code>SQL</code>语句的时候，会使用<code>like binary</code>，而<code>like binary</code>就是使用大小写敏感的。</p>
<h2 id="icontains"><a href="#icontains" class="headerlink" title="icontains"></a>icontains</h2><p><code>icontains</code>：使用大小写不敏感的判断，某个字符串是否被包含在指定的字段中。这个查询语句在被翻译成<code>SQL</code>的时候，使用的是<code>like</code>，而<code>like</code>在<code>MySQL</code>层面就是不区分大小写的。</p>
<h2 id="contains和iexact区别"><a href="#contains和iexact区别" class="headerlink" title="contains和iexact区别"></a>contains和iexact区别</h2><p><code>contains</code>和<code>icontains</code>，在被翻译成<code>SQL</code>的时候使用的是<code>%hello%</code>，就是只要整个字符串中出现了<code>hello</code>都能过够被找到，而<code>iexact</code>没有百分号，那么意味着只有完全相等的时候才会被匹配到。</p>
<h2 id="in"><a href="#in" class="headerlink" title="in"></a>in</h2><p><code>in</code>：可以直接指定某个字段的是否在某个集合中。示例代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">articles = Article.objects.<span class="built_in">filter</span>(id__in=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])</span><br></pre></td></tr></table></figure>

<p>也可以通过其他的表的字段来判断是否在某个集合中。示例代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">categories = Category.objects.<span class="built_in">filter</span>(article__id__in=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])</span><br></pre></td></tr></table></figure>

<p>如果要判断相关联的表的字段，那么也是通过<code>__</code>来连接。并且在做关联查询的时候，不需要写<code>models_set</code>，直接使用<code>模型的名字的小写化</code>就可以了。比如通过分类去查找相应的文章，那么通过<code>article__id__in</code>就可以了，而不是写成<code>article_set__id__in</code>的形式。当然如果你不想使用默认的形式，可以在外键定义的时候传递<code>related_query_name</code>来指定反向查询的名字。示例代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Category</span>(<span class="params">models.Model</span>):</span></span><br><span class="line">    name = models.CharField(max_length=<span class="number">100</span>)</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Meta</span>:</span></span><br><span class="line">        db_table = <span class="string">&#x27;category&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Article</span>(<span class="params">models.Model</span>):</span></span><br><span class="line">    title = models.CharField(max_length=<span class="number">200</span>)</span><br><span class="line">    content = models.TextField()</span><br><span class="line">    cateogry = models.ForeignKey(<span class="string">&quot;Category&quot;</span>,on_delete=models.CASCADE,null=<span class="literal">True</span>,related_query_name=<span class="string">&#x27;articles&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Meta</span>:</span></span><br><span class="line">        db_table = <span class="string">&#x27;article&#x27;</span></span><br></pre></td></tr></table></figure>

<p>因为在<code>cateogry</code>的<code>ForeignKey</code>中指定了<code>related_query_name</code>为<code>articles</code>，因此你不能再使用<code>article</code>来进行反向查询了。这时候就需要通过<code>articles__id__in</code>来进行反向查询。</p>
<p>反向查询是将模型名字小写化。比如<code>article__in</code>。可以通过<code>related_query_name</code>来指定自己的方式，而不使用默认的方式。<br>反向引用是将模型名字小写化，然后再加上<code>_set</code>，比如<code>article_set</code>，可以通过<code>related_name</code>来指定自己的方式，而不是用默认的方式。</p>
<p>并且，如果在做反向查询的时候，如果查询的字段就是模型的主键，那么可以省略掉这个字段，直接写成<code>article__in</code>就可以了，不需要这个<code>id</code>了。</p>
<p><code>in</code>不仅仅可以指定列表/元组，还可以为<code>QuerySet</code>。比如要查询“文章标题中包含有hello的所有分类”，那么可以通过以下代码来实现：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">articles = Article.objects.<span class="built_in">filter</span>(title__icontains=<span class="string">&#x27;hello&#x27;</span>)</span><br><span class="line">categories = Category.objects.<span class="built_in">filter</span>(articles__in=articles)</span><br><span class="line"><span class="keyword">for</span> cateogry <span class="keyword">in</span> categories:</span><br><span class="line">    <span class="built_in">print</span>(cateogry)</span><br></pre></td></tr></table></figure>

<h2 id="gt、gte、lt、lte"><a href="#gt、gte、lt、lte" class="headerlink" title="gt、gte、lt、lte"></a><code>gt</code>、<code>gte</code>、<code>lt</code>、<code>lte</code></h2><p><code>gt</code>、<code>gte</code>、<code>lt</code>、<code>lte</code>：代表的是大于、大于等于、小于、小于等于的条件。示例代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">articles = Article.objects.<span class="built_in">filter</span>(id__lte=<span class="number">3</span>)  <span class="comment">#小于等于3</span></span><br></pre></td></tr></table></figure>

<h2 id="startswith、istartswith、endswith、iendswith"><a href="#startswith、istartswith、endswith、iendswith" class="headerlink" title="startswith、istartswith、endswith、iendswith"></a><code>startswith</code>、<code>istartswith</code>、<code>endswith</code>、<code>iendswith</code></h2><p><code>startswith</code>、<code>istartswith</code>、<code>endswith</code>、<code>iendswith</code>：表示以某个值开始，不区分大小写的以某个值开始、以某个值结束、不区分大小写的以某个值结束。示例代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">articles = Article.objects.<span class="built_in">filter</span>(title__endswith=<span class="string">&quot;hello&quot;</span>)</span><br></pre></td></tr></table></figure>

<h2 id="时间查询条件"><a href="#时间查询条件" class="headerlink" title="时间查询条件"></a>时间查询条件</h2><h3 id="range"><a href="#range" class="headerlink" title="range"></a>range</h3><p><code>range</code>：可以指定一个时间段。并且时间应该标记为<code>aware</code>时间，不然django会报警告。Filtering a DateTimeField with dates won’t include items on the last day. 示例代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime,time</span><br><span class="line"><span class="keyword">from</span> django.utils.timezone <span class="keyword">import</span> make_aware</span><br><span class="line"></span><br><span class="line">start_time = make_aware(datetime(year=<span class="number">2018</span>,month=<span class="number">4</span>,day=<span class="number">4</span>,hour=<span class="number">17</span>,minute=<span class="number">0</span>,second=<span class="number">0</span>))</span><br><span class="line">end_time = make_aware(datetime(year=<span class="number">2018</span>,month=<span class="number">4</span>,day=<span class="number">4</span>,hour=<span class="number">18</span>,minute=<span class="number">0</span>,second=<span class="number">0</span>))</span><br><span class="line">articles = Article.objects.<span class="built_in">filter</span>(create_time__range=(start_time,end_time))</span><br><span class="line"><span class="built_in">print</span>(articles.query)</span><br><span class="line"><span class="built_in">print</span>(articles)</span><br></pre></td></tr></table></figure>

<h3 id="date"><a href="#date" class="headerlink" title="date"></a>date</h3><p><code>date</code>：用年月日来进行过滤。如果想要使用这个过滤条件，那么前提必须要在<code>MySQL</code>中添加好那些时区文件。示例代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">articles = Article.objects.<span class="built_in">filter</span>(create_time__date=datetime(year=<span class="number">2018</span>,month=<span class="number">4</span>,day=<span class="number">4</span>))</span><br></pre></td></tr></table></figure>

<h3 id="year-month-day"><a href="#year-month-day" class="headerlink" title="year/month/day"></a>year/month/day</h3><p><code>year/month/day</code>：表示根据年/月/日进行查找。示例代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">articles = Article.objects.<span class="built_in">filter</span>(create_time__year__gte=<span class="number">2018</span>)</span><br></pre></td></tr></table></figure>

<h3 id="week-day"><a href="#week-day" class="headerlink" title="week_day"></a>week_day</h3><p><code>week_day</code>：根据星期来进行查找。1表示星期天，7表示星期六，2-6代表的是星期一到星期五。比如要查找星期三的所有文章，那么可以通过以下代码来实现：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">articles = Article.objects.<span class="built_in">filter</span>(create_time__week_day=<span class="number">4</span>)</span><br></pre></td></tr></table></figure>

<h3 id="time"><a href="#time" class="headerlink" title="time"></a>time</h3><p><code>time</code>：根据分时秒来进行查找。如果要具体到秒，一般比较难匹配到，可以使用区间的方式来进行查找。区间使用<code>range</code>条件。比如想要获取17时/10分/27-28秒之间的文章，那么可以通过以下代码来实现：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">start_time = time(hour=<span class="number">17</span>,minute=<span class="number">10</span>,second=<span class="number">27</span>)</span><br><span class="line">end_time = time(hour=<span class="number">17</span>,minute=<span class="number">10</span>,second=<span class="number">28</span>)</span><br><span class="line">articles = Article.objects.<span class="built_in">filter</span>(create_time__time__range=(start_time,end_time))</span><br></pre></td></tr></table></figure>

<h2 id="regex和iregex"><a href="#regex和iregex" class="headerlink" title="regex和iregex"></a><code>regex</code>和<code>iregex</code></h2><p><code>regex</code>和<code>iregex</code>：大小写敏感和大小写不敏感的正则表达式。示例代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">articles = Article.objects.<span class="built_in">filter</span>(title__regex=<span class="string">r&#x27;^hello&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>以上代码的意思是提取所有标题以<code>hello</code>字符串开头的文章。</p>
<h1 id="聚合函数笔记："><a href="#聚合函数笔记：" class="headerlink" title="聚合函数笔记："></a>聚合函数笔记：</h1><ol>
<li>所有的聚合函数都是放在<code>django.db.models</code>下面。</li>
<li>聚合函数不能够单独的执行，需要放在一些可以执行聚合函数的方法下面中去执行。比如<code>aggregate</code>。示例代码如下：</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.db.models <span class="keyword">import</span> Avg</span><br><span class="line"></span><br><span class="line">result = Book.objects.aggregate(Avg(<span class="string">&quot;price&quot;</span>))</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>聚合函数执行完成后，自动给这个聚合函数的值取个名字。取别名的规则，默认是<code>field+__+聚合函数名字</code>形成的。比如以上代码形成的名字叫做<code>price__avg</code>。如果不想使用默认的名字，那么可以在使用聚合函数的时候传递关键字参数进去，参数的名字就是聚合函数执行完成的名字。实示例代码如下：</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">result = Book.objects.aggregate(avg=Avg(<span class="string">&quot;price&quot;</span>))</span><br></pre></td></tr></table></figure>

<p>以上传递了关键字参数<code>avg=Avg(&quot;price&quot;)</code>，那么以后<code>Avg</code>聚合函数执行完成的名字就叫做<code>avg</code>。</p>
<h2 id="aggregate"><a href="#aggregate" class="headerlink" title="aggregate"></a>aggregate</h2><p><code>aggregate</code>：这个方法不会返回一个<code>QuerySet</code>对象，而是返回一个字典。这个字典中的<code>key</code>就是聚合函数的名字，值就是聚合函数执行后的结果。</p>
<h2 id="annotate"><a href="#annotate" class="headerlink" title="annotate"></a>annotate</h2><p><code>aggregate</code>和<code>annotate</code>的相同和不同：<br>    * 相同：这两个方法都可以执行聚合函数。<br>    * 不同：<br>        - <code>aggregate</code>返回的是一个字典，在这个字典中存储的是这个聚合函数执行的结果。而<code>annotate</code>返回的是一个<code>QuerySet</code>对象，并且会在查找的模型上添加一个聚合函数的属性。<br>        - <code>aggregate</code>不会做分组，而<code>annotate</code>会使用<code>group by</code>子句进行分组，只有调用了<code>group by</code>子句，才能对每一条数据求聚合函数的值。<code>annotate</code>在原来模型字段的基础之上添加一个使用了聚合函数的字段，并且在使用聚合函数的时候，会使用当前这个模型的主键进行分组（group by）。</p>
<p><code>aggregate</code>和<code>annotate</code>方法可以在任何的<code>QuerySet</code>对象上调用。因此只要是返回了<code>QuerySet</code>对象，那么就可以进行链式调用。比如要获取2018年度的销售总额，那么可以先过滤年份，再求聚合函数。示例代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">BookOrder.objects.<span class="built_in">filter</span>(create_time__year=<span class="number">2018</span>).aggregate(total=Sum(<span class="string">&#x27;price&#x27;</span>))</span><br></pre></td></tr></table></figure>

<h2 id="Count"><a href="#Count" class="headerlink" title="Count"></a>Count</h2><p><code>Count</code>：用来求某个数据的个数。比如要求所有图书的数量，那么可以使用以下代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">result = Book.objects.aggregate(book_nums=Count(<span class="string">&quot;id&quot;</span>))</span><br></pre></td></tr></table></figure>

<p>并且<code>Count</code>可以传递<code>distinct=True</code>参数，用来剔除那些重复的值，只保留一个。比如要获取作者表中，不同邮箱的个数，那么这时候可以使用<code>distinct=True</code>。示例代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">result = Author.objects.aggregate(email_nums=Count(<span class="string">&#x27;email&#x27;</span>,distinct=<span class="literal">True</span>))</span><br></pre></td></tr></table></figure>

<h2 id="Max和Min"><a href="#Max和Min" class="headerlink" title="Max和Min"></a><code>Max</code>和<code>Min</code></h2><p><code>Max</code>和<code>Min</code>：求指定字段的最大值和最小值。示例代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">result = Author.objects.aggregate(<span class="built_in">max</span>=Max(<span class="string">&quot;age&quot;</span>),<span class="built_in">min</span>=Min(<span class="string">&quot;age&quot;</span>))</span><br></pre></td></tr></table></figure>

<h2 id="Sum"><a href="#Sum" class="headerlink" title="Sum"></a>Sum</h2><p><code>Sum</code>：求某个字段值的总和。示例代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">result = BookOrder.objects.aggregate(total=Sum(<span class="string">&#x27;price&#x27;</span>))</span><br></pre></td></tr></table></figure>

<h1 id="F表达式和Q表达式"><a href="#F表达式和Q表达式" class="headerlink" title="F表达式和Q表达式"></a>F表达式和Q表达式</h1><h2 id="F表达式"><a href="#F表达式" class="headerlink" title="F表达式"></a>F表达式</h2><p><code>F表达式</code>： 动态的获取某个字段上的值。并且这个F表达式，不会真正的去数据库中查询数据，他相当于只是起一个标识的作用。比如想要将原来每本图书的价格都在原来的基础之上增加10元，那么可以使用以下代码来实现：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.db.models <span class="keyword">import</span> F</span><br><span class="line"></span><br><span class="line">Book.objects.update(price=F(<span class="string">&quot;price&quot;</span>)+<span class="number">10</span>)</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 获取名字和邮箱相同的作者</span></span><br><span class="line">authors = Author.objects.<span class="built_in">filter</span>(name=F(<span class="string">&quot;email&quot;</span>))</span><br></pre></td></tr></table></figure>

<h2 id="Q表达式"><a href="#Q表达式" class="headerlink" title="Q表达式"></a>Q表达式</h2><p><code>Q表达式</code>：使用<code>Q</code>表达式包裹查询条件，可以在条件之间进行多种操作。与、或、非等，从而实现一些复杂的查询操作。例子如下：</p>
<ul>
<li>查找价格大于100，并且评分达到4.85以上的图书：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 不使用Q表达式的</span></span><br><span class="line">books = Book.objects.<span class="built_in">filter</span>(price__gte=<span class="number">100</span>,rating__gte=<span class="number">4.85</span>)</span><br><span class="line"><span class="comment"># 使用Q表达式的</span></span><br><span class="line">books = Book.objects.<span class="built_in">filter</span>(Q(price__gte=<span class="number">100</span>)&amp;Q(rating__gte=<span class="number">4.85</span>))</span><br></pre></td></tr></table></figure>

<ul>
<li>查找价格低于100元，或者评分低于4分的图书：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">books = Book.objects.<span class="built_in">filter</span>(Q(price__gte=<span class="number">100</span>)&amp;Q(rating__gte=<span class="number">4.85</span>))</span><br></pre></td></tr></table></figure>

<ul>
<li>获取价格大于100，并且图书名字中不包含”传“字的图书：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">books = Book.objects.<span class="built_in">filter</span>(Q(price__gte=<span class="number">100</span>)&amp;~Q(name__icontains=<span class="string">&#x27;传&#x27;</span>))</span><br></pre></td></tr></table></figure>

<h1 id="QuerySet-API："><a href="#QuerySet-API：" class="headerlink" title="QuerySet API："></a>QuerySet API：</h1><h2 id="模型-objects："><a href="#模型-objects：" class="headerlink" title="模型.objects："></a>模型.objects：</h2><p>这个对象是<code>django.db.models.manager.Manager</code>的对象，这个类是一个空壳类，他上面的所有方法都是从<code>QuerySet</code>这个类上面拷贝过来的。因此我们只要学会了<code>QuerySet</code>，这个<code>objects</code>也就知道该如何使用了。</p>
<p><code>Manager</code>源码解析：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">class_name = <span class="string">&quot;BaseManagerFromQuerySet&quot;</span></span><br><span class="line"></span><br><span class="line">class_dict = &#123;</span><br><span class="line">    <span class="string">&#x27;_queryset_class&#x27;</span>: QuerySet</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class_dict.update(cls._get_queryset_methods(QuerySet))</span><br><span class="line"></span><br><span class="line"><span class="comment"># type动态的时候创建类</span></span><br><span class="line"><span class="comment"># 第一个参数是用来指定创建的类的名字。创建的类名是：BaseManagerFromQuerySet</span></span><br><span class="line"><span class="comment"># 第二个参数是用来指定这个类的父类。</span></span><br><span class="line"><span class="comment"># 第三个参数是用来指定这个类的一些属性和方法</span></span><br><span class="line"><span class="keyword">return</span> <span class="built_in">type</span>(class_name,(cls,),class_dict)</span><br><span class="line"></span><br><span class="line">_get_queryset_methods：这个方法就是将QuerySet中的一些方法拷贝出来</span><br></pre></td></tr></table></figure>

<h2 id="filter-exclude-annotate：过滤-排除满足条件的-给模型添加新的字段。"><a href="#filter-exclude-annotate：过滤-排除满足条件的-给模型添加新的字段。" class="headerlink" title="filter/exclude/annotate：过滤/排除满足条件的/给模型添加新的字段。"></a><code>filter/exclude/annotate</code>：过滤/排除满足条件的/给模型添加新的字段。</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Article.objects.exclude(title__contains=<span class="string">&#x27;hello&#x27;</span>)</span><br><span class="line"></span><br><span class="line">articles = Article.objects.annotate(author_name=F(<span class="string">&quot;author__name&quot;</span>))</span><br></pre></td></tr></table></figure>

<h2 id="order-by："><a href="#order-by：" class="headerlink" title="order_by："></a>order_by：</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 根据创建的时间正序排序</span></span><br><span class="line">articles = Article.objects.order_by(<span class="string">&quot;create_time&quot;</span>)</span><br><span class="line"><span class="comment"># 根据创建的时间倒序排序</span></span><br><span class="line">articles = Article.objects.order_by(<span class="string">&quot;-create_time&quot;</span>)</span><br><span class="line"><span class="comment"># 根据作者的名字进行排序</span></span><br><span class="line">articles = Article.objects.order_by(<span class="string">&quot;author__name&quot;</span>)</span><br><span class="line"><span class="comment"># 首先根据创建的时间进行排序，如果时间相同，则根据作者的名字进行排序</span></span><br><span class="line">articles = Article.objects.order_by(<span class="string">&quot;create_time&quot;</span>,<span class="string">&#x27;author__name&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>一定要注意的一点是，多个<code>order_by</code>，会把前面排序的规则给打乱，而使用后面的排序方式。比如以下代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">articles = Article.objects.order_by(<span class="string">&quot;create_time&quot;</span>).order_by(<span class="string">&quot;author__name&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>它会根据作者的名字进行排序，而不是使用文章的创建时间。</p>
<p>当然，也可以在模型定义的在<code>Meta</code>类中定义<code>ordering</code>来指定默认的排序方式。示例代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Meta</span>:</span></span><br><span class="line">    db_table = <span class="string">&#x27;book_order&#x27;</span></span><br><span class="line">    ordering = [<span class="string">&#x27;create_time&#x27;</span>,<span class="string">&#x27;-price&#x27;</span>]</span><br></pre></td></tr></table></figure>

<p>还可以根据<code>annotate</code>定义的字段进行排序。比如要实现图书的销量进行排序，那么示例代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">books = Book.objects.annotate(order_nums=Count(<span class="string">&quot;bookorder&quot;</span>)).order_by(<span class="string">&quot;-order_nums&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> book <span class="keyword">in</span> books:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;%s/%s&#x27;</span>%(book.name,book.order_nums))</span><br></pre></td></tr></table></figure>

<h2 id="values"><a href="#values" class="headerlink" title="values"></a>values</h2><p>只想提取其中的几个字段，可以使用<code>values</code>来进行指定，并且使用了<code>values</code>方法后，提取出的<code>QuerySet</code>中的数据类型不是模型，而是在<code>values</code>方法中指定的字段和值形成的字典：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">books = Book.objects.values(<span class="string">&#x27;id&#x27;</span>,<span class="string">&#x27;name&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>提取这个模型上关联的的对象的属性，查找顺序和<code>filter</code>的用法是一样的：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">books = Book.objects.values(<span class="string">&#x27;id&#x27;</span>,<span class="string">&#x27;name&#x27;</span>,<span class="string">&#x27;author__name&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>以上会提取<code>author</code>的<code>name</code>字段，如果想更改字段名，可以使用关键字参数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">books = Book.objects.values(<span class="string">&#x27;id&#x27;</span>, <span class="string">&#x27;name&#x27;</span>, author_name=F(<span class="string">&#x27;author__name&#x27;</span>))</span><br></pre></td></tr></table></figure>

<p>自定义的名字，不能和模型上本身拥有的字段一样，否则会报错。</p>
<p>在<code>values</code>中，也可以使用聚合函数来形成一个新的字段。比如获取每本图书的销量：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">books = Book.objects.values(<span class="string">&#x27;id&#x27;</span>, <span class="string">&#x27;name&#x27;</span>, order_nums=Count(<span class="string">&#x27;bookorder&#x27;</span>))</span><br></pre></td></tr></table></figure>

<p>如果调用<code>values</code>方法的时候，没有传递任何的参数，那么会获取这个模型上的所有字段以及对于的值形成的字典：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">books = Book.objects.values()</span><br></pre></td></tr></table></figure>

<p>那么<code>books</code>中的值如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&#123;<span class="string">&#x27;id&#x27;</span>:<span class="number">1</span>, <span class="string">&#x27;name&#x27;</span>:<span class="string">&#x27;三国演义&#x27;</span>, <span class="string">&#x27;pages&#x27;</span>:<span class="number">987</span>, <span class="string">&#x27;price&#x27;</span>:<span class="number">108.0</span>, <span class="string">&#x27;rating&#x27;</span>:<span class="number">3.9</span>, <span class="string">&#x27;author_id&#x27;</span>:<span class="number">3</span>&#125;</span><br></pre></td></tr></table></figure>

<h2 id="values-list"><a href="#values-list" class="headerlink" title="values_list"></a>values_list</h2><p>和<code>values</code>是一样的作用，只不过返回的<code>QuerySet</code>中，装的不是字典，而是元组。示例代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">books = Book.objects.values_list(<span class="string">&#x27;id&#x27;</span>, <span class="string">&#x27;name&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>以上的返回结果是：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">(<span class="number">1</span>,<span class="string">&#x27;三国演义&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>如果给<code>values_list</code>只指定一个字段，那么我们可以指定<code>flat=True</code>，这样返回的结果就不再是一个元组，而是整个字段的值。<code>flat</code>只能用在只有一个字段的情况下，否则就会报错。示例代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">books = Book.objects.values_list(<span class="string">&#x27;name&#x27;</span>, flat=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>

<p>那么以上返回的结果是：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;三国演义&#x27;</span></span><br></pre></td></tr></table></figure>

<h2 id="all方法"><a href="#all方法" class="headerlink" title="all方法"></a><code>all</code>方法</h2><p>这个简单的返回一个<code>QuerySet</code>对象，这个<code>QuerySet</code>对象没有经过任何的修改（比如：过滤等）。</p>
<h2 id="select-related"><a href="#select-related" class="headerlink" title="select_related"></a>select_related</h2><p>在查找某个表的数据的时候，可以一次性把相关联的其它表的数据都提取出来。以后再访问相关表的数据的时候，不用再次查找数据库，可以节省一些开销。示例代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">books = Book.objects.select_related(<span class="string">&#x27;author&#x27;</span>,<span class="string">&#x27;publisher&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> book <span class="keyword">in</span> books:</span><br><span class="line">    <span class="built_in">print</span>(book.author.name)</span><br><span class="line">    <span class="comment"># 因为在提取Book的时候，使用了select_related，那么以后再访问book.author的时候，不会再次向数据库重新发起查询</span></span><br></pre></td></tr></table></figure>

<p>注意：这个方法只能用在外键的关联对象上，对于那种多对多，或者是多对一的情况，不能使用它来实现，应该使用<code>prefetch_related</code>来实现。</p>
<h2 id="prefetch-related"><a href="#prefetch-related" class="headerlink" title="prefetch_related"></a>prefetch_related</h2><p>与<code>select_related</code>方法类似，也是在查询语句时，提前将指定的数据查找出来。只不过这个方法是用来解决多对多，或者多对一的情况。这个方法会产生两个查询语句。所以，如果在这个方法中查询使用外键关联的模型的时候，也会产生两个查询语句，因此如果查询的是外键关联的模型，建议使用<code>select_related</code>方法。<br>在查询多对多或者多对一的关联的对象的时候，与使用模型访问传递的字符串一样。比如要获取图书上的所有订单，示例代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">books = Book.objects.prefetch_related(<span class="string">&#x27;bookorder_set&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p><strong>注意</strong>：在使用<code>prefetch_related</code>查找出来的<code>bookorder_set</code>，建议不要再对其进行任何操作，比如<code>filter</code>，不然又会产生N多查询语句。</p>
<p>如果确实想要对预先查找的集合进行操作，可以用<code>django.db.models.Prefetch</code>完成。示例代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.db.models <span class="keyword">import</span> Prefetch</span><br><span class="line"></span><br><span class="line"><span class="comment"># 先使用Prefetch吧查找的条件写好，在放到prefetch_related中</span></span><br><span class="line">prefetch = Prefetch(<span class="string">&quot;bookorder_set&quot;</span>,queryset=BookOrder.objects.<span class="built_in">filter</span>(price__gte=<span class="number">90</span>))</span><br><span class="line">books = Book.objects.prefetch_related(prefetch)</span><br><span class="line"><span class="keyword">for</span> book <span class="keyword">in</span> books:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;=&#x27;</span>*<span class="number">30</span>)</span><br><span class="line">    <span class="built_in">print</span>(book.name)</span><br><span class="line">    orders = book.bookorder_set.<span class="built_in">all</span>()</span><br><span class="line">    <span class="keyword">for</span> order <span class="keyword">in</span> orders:</span><br><span class="line">        <span class="built_in">print</span>(order.<span class="built_in">id</span>)</span><br></pre></td></tr></table></figure>

<h2 id="defer和only"><a href="#defer和only" class="headerlink" title="defer和only"></a>defer和only</h2><p>这两个方法都会返回一个<code>QuerySet</code>对象，并且这个<code>QuerySet</code>中装的都是模型，而不是字典。</p>
<ol>
<li><code>defer</code>：这个方法用来告诉<code>ORM</code>，在查询某个模型的时候，过滤掉某些字段。注意：使用了<code>defer</code>了的字段，如果以后再使用这个字段，会重新发起一次请求。因此要谨慎操作。</li>
<li><code>only</code>：这个方法用来告诉<code>ORM</code>，在查询某个模型的时候，值提取几个字段。注意：没有加在<code>only</code>中的字段，以后如果使用了，那么也会重新发起一次请求。因此要谨慎操作。</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">books = Book.objects.only(<span class="string">&#x27;name&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> book <span class="keyword">in</span> books:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;%s/%s&#x27;</span>%(book.<span class="built_in">id</span>,book.price))</span><br></pre></td></tr></table></figure>

<h2 id="get方法"><a href="#get方法" class="headerlink" title="get方法"></a>get方法</h2><p>这个方法给定的条件只能匹配到一条数据，如果匹配到多条数据，或没有匹配到任何数据，都会报错。一般用于查询主键。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">book = Book.objects.get(<span class="built_in">id</span>=<span class="number">5</span>)</span><br><span class="line"><span class="built_in">print</span>(book)</span><br><span class="line"><span class="built_in">print</span>(connection.queries)</span><br></pre></td></tr></table></figure>

<h2 id="create方法"><a href="#create方法" class="headerlink" title="create方法"></a>create方法</h2><p>创建一条数据，并且将这个数据保存到数据库中，以下的代码是等价的：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">publisher = Publisher(name=<span class="string">&#x27;人民邮电出版社&#x27;</span>)</span><br><span class="line">publisher.save()</span><br><span class="line"></span><br><span class="line">Publisher.objects.create(name=<span class="string">&#x27;人民邮电出版社&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h2 id="get-or-create"><a href="#get-or-create" class="headerlink" title="get_or_create"></a>get_or_create</h2><p>如果给定的条件有数据，那么就会把这个数据直接提取出来。如果给定的条件没有数据，那么就会先创建数据，然后再把数据返回回来。这个方法的返回值是一个元组，元组的第一个参数<code>obj</code>是这个对象，第二个参数<code>created</code>代表是否创建的，是返回<code>True</code>。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">obj,created= Category.objects.get_or_create(title=<span class="string">&#x27;默认分类&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h2 id="bulk-create"><a href="#bulk-create" class="headerlink" title="bulk_create"></a>bulk_create</h2><p>一次性创建多个数据。示例代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">publisher = Publisher.objects.bulk_create([</span><br><span class="line">    Publisher(name=<span class="string">&#x27;123出版社&#x27;</span>),</span><br><span class="line">    Publisher(name=<span class="string">&#x27;abc出版社&#x27;</span>),</span><br><span class="line">])</span><br></pre></td></tr></table></figure>

<h2 id="count"><a href="#count" class="headerlink" title="count"></a>count</h2><p>获取提取的数据的个数。如果想要知道总共有多少条数据，那么建议使用<code>count</code>，而不是使用<code>len(articles)</code>这种。因为<code>count</code>在底层是使用<code>select count(*)</code>来实现的，这种方式比使用<code>len</code>函数更加的高效。</p>
<h2 id="firtst和last"><a href="#firtst和last" class="headerlink" title="firtst和last"></a>firtst和last</h2><p>返回<code>QuerySet</code>中的第一条和最后一条数据。</p>
<h2 id="aggregate-1"><a href="#aggregate-1" class="headerlink" title="aggregate"></a>aggregate</h2><p>使用聚合函数。</p>
<h2 id="exists"><a href="#exists" class="headerlink" title="exists"></a>exists</h2><p>判断某个条件的数据是否存在。如果要判断某个条件的元素是否存在，那么建议使用<code>exists</code>，这比使用<code>count</code>或者直接判断<code>QuerySet</code>更有效得多。示例代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> Article.objects.<span class="built_in">filter</span>(title__contains=<span class="string">&#x27;hello&#x27;</span>).exists():</span><br><span class="line">    <span class="built_in">print</span>(<span class="literal">True</span>)</span><br><span class="line"><span class="comment"># 比使用count更高效：</span></span><br><span class="line"><span class="keyword">if</span> Article.objects.<span class="built_in">filter</span>(title__contains=<span class="string">&#x27;hello&#x27;</span>).count() &gt; <span class="number">0</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="literal">True</span>)</span><br><span class="line"><span class="comment"># 也比直接判断QuerySet更高效：</span></span><br><span class="line"><span class="keyword">if</span> Article.objects.<span class="built_in">filter</span>(title__contains=<span class="string">&#x27;hello&#x27;</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>

<h2 id="distinct"><a href="#distinct" class="headerlink" title="distinct"></a>distinct</h2><p>去除掉那些重复的数据。这个方法如果底层数据库用的是<code>MySQL</code>，那么不能传递任何的参数。比如想要提取所有销售的价格超过80元的图书，并且删掉那些重复的，那么可以使用<code>distinct</code>来帮我们实现，示例代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">books = Book.objects.<span class="built_in">filter</span>(bookorder__price__gte=<span class="number">80</span>).distinct()</span><br></pre></td></tr></table></figure>

<p>需要注意的是，如果在<code>distinct</code>之前使用了<code>order_by</code>，那么因为<code>order_by</code>会提取<code>order_by</code>中指定的字段，因此再使用<code>distinct</code>就会根据多个字段来进行唯一化，所以就不会把那些重复的数据删掉。示例代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">orders = BookOrder.objects.order_by(<span class="string">&quot;create_time&quot;</span>).values(<span class="string">&quot;book_id&quot;</span>).distinct()</span><br></pre></td></tr></table></figure>

<p>那么以上代码因为使用了<code>order_by</code>，即使使用了<code>distinct</code>，也会把重复的<code>book_id</code>提取出来。</p>
<h2 id="update"><a href="#update" class="headerlink" title="update"></a>update</h2><p>执行更新操作，在<code>SQL</code>底层走的也是<code>update</code>命令。比如要将所有<code>category</code>为空的<code>article</code>的<code>article</code>字段都更新为默认的分类。示例代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Article.objects.<span class="built_in">filter</span>(category__isnull=<span class="literal">True</span>).update(category_id=<span class="number">3</span>)</span><br></pre></td></tr></table></figure>

<p>注意这个方法走的是更新的逻辑。所以更新完成后保存到数据库中不会执行<code>save</code>方法，因此不会更新<code>auto_now</code>设置的字段。</p>
<h2 id="delete"><a href="#delete" class="headerlink" title="delete"></a>delete</h2><p>删除所有满足条件的数据。删除数据的时候，要注意<code>on_delete</code>指定的处理方式。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Author.objects.<span class="built_in">filter</span>(id__gte=<span class="number">3</span>).delete()</span><br></pre></td></tr></table></figure>

<h2 id="切片操作"><a href="#切片操作" class="headerlink" title="切片操作"></a>切片操作</h2><p>有时候我们查找数据，有可能只需要其中的一部分。那么这时候可以使用切片操作来帮我们完成。<code>QuerySet</code>使用切片操作就跟列表使用切片操作是一样的。示例代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">books = Book.objects.<span class="built_in">all</span>()[<span class="number">1</span>:<span class="number">3</span>]   <span class="comment">#1,2</span></span><br><span class="line"><span class="keyword">for</span> book <span class="keyword">in</span> books:</span><br><span class="line">    <span class="built_in">print</span>(book)</span><br></pre></td></tr></table></figure>

<p>切片操作并不是把所有数据从数据库中提取出来再做切片操作。而是在数据库层面使用<code>LIMIT</code>和<code>OFFSET</code>来帮我们完成。所以如果只需要取其中一部分的数据的时候，建议大家使用切片操作。</p>
<h2 id="什么时候Django会将QuerySet转换为SQL去执行"><a href="#什么时候Django会将QuerySet转换为SQL去执行" class="headerlink" title="什么时候Django会将QuerySet转换为SQL去执行"></a>什么时候<code>Django</code>会将<code>QuerySet</code>转换为<code>SQL</code>去执行</h2><p>生成一个<code>QuerySet</code>对象并不会马上转换为<code>SQL</code>语句去执行。<br>比如我们获取<code>Book</code>表下所有的图书：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">books = Book.objects.<span class="built_in">all</span>()</span><br><span class="line"><span class="built_in">print</span>(connection.queries)</span><br></pre></td></tr></table></figure>

<p>我们可以看到在打印<code>connection.quries</code>的时候打印的是一个空的列表。说明上面的<code>QuerySet</code>并没有真正的执行。<br>在以下情况下<code>QuerySet</code>会被转换为<code>SQL</code>语句执行：</p>
<ul>
<li>迭代：在遍历<code>QuerySet</code>对象的时候，会首先先执行这个<code>SQL</code>语句，然后再把这个结果返回进行迭代。比如以下代码就会转换为<code>SQL</code>语句：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> book <span class="keyword">in</span> Book.objects.<span class="built_in">all</span>():</span><br><span class="line">    <span class="built_in">print</span>(book)</span><br></pre></td></tr></table></figure>

<ul>
<li>使用步长做切片操作：<code>QuerySet</code>可以类似于列表一样做切片操作。做切片操作本身不会执行<code>SQL</code>语句，但是如果如果在做切片操作的时候提供了步长，那么就会立马执行SQL语句。需要注意的是，做切片后不能再执行<code>filter</code>方法，否则会报错。</li>
<li>调用<code>len</code>函数：调用<code>len</code>函数用来获取<code>QuerySet</code>中总共有多少条数据也会执行<code>SQL</code>语句。</li>
<li>调用<code>list</code>函数：调用<code>list</code>函数用来将一个<code>QuerySet</code>对象转换为<code>list</code>对象也会立马执行<code>SQL</code>语句。</li>
<li>判断：如果对某个<code>QuerySet</code>进行判断，也会立马执行<code>SQL</code>语句。</li>
</ul>
<h1 id="ORM实例"><a href="#ORM实例" class="headerlink" title="ORM实例"></a>ORM实例</h1><p>ORM模型如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.db <span class="keyword">import</span> models</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>(<span class="params">models.Model</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;学生表&quot;&quot;&quot;</span></span><br><span class="line">    name = models.CharField(max_length=<span class="number">100</span>)</span><br><span class="line">    gender = models.SmallIntegerField()</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Meta</span>:</span></span><br><span class="line">        db_table = <span class="string">&#x27;student&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Course</span>(<span class="params">models.Model</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;课程表&quot;&quot;&quot;</span></span><br><span class="line">    name = models.CharField(max_length=<span class="number">100</span>)</span><br><span class="line">    teacher = models.ForeignKey(<span class="string">&quot;Teacher&quot;</span>,on_delete=models.SET_NULL,null=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Meta</span>:</span></span><br><span class="line">        db_table = <span class="string">&#x27;course&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Score</span>(<span class="params">models.Model</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;分数表&quot;&quot;&quot;</span></span><br><span class="line">    student = models.ForeignKey(<span class="string">&quot;Student&quot;</span>,on_delete=models.CASCADE)</span><br><span class="line">    course = models.ForeignKey(<span class="string">&quot;Course&quot;</span>,on_delete=models.CASCADE)</span><br><span class="line">    number = models.FloatField()</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Meta</span>:</span></span><br><span class="line">        db_table = <span class="string">&#x27;score&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Teacher</span>(<span class="params">models.Model</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;老师表&quot;&quot;&quot;</span></span><br><span class="line">    name = models.CharField(max_length=<span class="number">100</span>)</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Meta</span>:</span></span><br><span class="line">        db_table = <span class="string">&#x27;teacher&#x27;</span></span><br></pre></td></tr></table></figure>

<h2 id="查询平均成绩大于60分的同学的id和平均成绩；"><a href="#查询平均成绩大于60分的同学的id和平均成绩；" class="headerlink" title="查询平均成绩大于60分的同学的id和平均成绩；"></a>查询平均成绩大于60分的同学的id和平均成绩；</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">rows = Student.objects.annotate(avg=Avg(<span class="string">&quot;score__number&quot;</span>)).<span class="built_in">filter</span>(avg__gte=<span class="number">60</span>).values(<span class="string">&quot;id&quot;</span>,<span class="string">&quot;avg&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> row <span class="keyword">in</span> rows:</span><br><span class="line">    <span class="built_in">print</span>(row)</span><br></pre></td></tr></table></figure>

<h2 id="查询所有同学的id、姓名、选课的数、总成绩；"><a href="#查询所有同学的id、姓名、选课的数、总成绩；" class="headerlink" title="查询所有同学的id、姓名、选课的数、总成绩；"></a>查询所有同学的id、姓名、选课的数、总成绩；</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">rows = Student.objects.annotate(course_nums=Count(<span class="string">&quot;score__course&quot;</span>),total_score=Sum(<span class="string">&quot;score__number&quot;</span>))</span><br><span class="line">.values(<span class="string">&quot;id&quot;</span>,<span class="string">&quot;name&quot;</span>,<span class="string">&quot;course_nums&quot;</span>,<span class="string">&quot;total_score&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> row <span class="keyword">in</span> rows:</span><br><span class="line">    <span class="built_in">print</span>(row)</span><br></pre></td></tr></table></figure>

<h2 id="查询姓“李”的老师的个数；"><a href="#查询姓“李”的老师的个数；" class="headerlink" title="查询姓“李”的老师的个数；"></a>查询姓“李”的老师的个数；</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">teacher_nums = Teacher.objects.<span class="built_in">filter</span>(name__startswith=<span class="string">&quot;李&quot;</span>).count()</span><br><span class="line"><span class="built_in">print</span>(teacher_nums)</span><br></pre></td></tr></table></figure>

<h2 id="查询没学过“黄老师”课的同学的id、姓名；"><a href="#查询没学过“黄老师”课的同学的id、姓名；" class="headerlink" title="查询没学过“黄老师”课的同学的id、姓名；"></a>查询没学过“黄老师”课的同学的id、姓名；</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">rows = Student.objects.exclude(score__course__teacher__name=<span class="string">&quot;黄老师&quot;</span>).values(<span class="string">&#x27;id&#x27;</span>,<span class="string">&#x27;name&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> row <span class="keyword">in</span> rows:</span><br><span class="line">    <span class="built_in">print</span>(row)</span><br></pre></td></tr></table></figure>

<h2 id="查询学过课程id为1和2的所有同学的id、姓名；"><a href="#查询学过课程id为1和2的所有同学的id、姓名；" class="headerlink" title="查询学过课程id为1和2的所有同学的id、姓名；"></a>查询学过课程id为1和2的所有同学的id、姓名；</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">rows = Student.objects.<span class="built_in">filter</span>(score__course__in=[<span class="number">1</span>,<span class="number">2</span>]).distinct().values(<span class="string">&#x27;id&#x27;</span>,<span class="string">&#x27;name&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> row <span class="keyword">in</span> rows:</span><br><span class="line">    <span class="built_in">print</span>(row)</span><br></pre></td></tr></table></figure>

<h2 id="查询学过“黄老师”所教的所有课的同学的学号、姓名；"><a href="#查询学过“黄老师”所教的所有课的同学的学号、姓名；" class="headerlink" title="查询学过“黄老师”所教的所有课的同学的学号、姓名；"></a>查询学过“黄老师”所教的所有课的同学的学号、姓名；</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">rows = Student.objects.annotate(nums=Count(<span class="string">&quot;score__course&quot;</span>,<span class="built_in">filter</span>=Q(score__course__teacher__name=<span class="string">&#x27;黄老师&#x27;</span>))).<span class="built_in">filter</span>(nums=Course.objects.<span class="built_in">filter</span>(teacher__name=<span class="string">&#x27;黄老师&#x27;</span>).count()).values(<span class="string">&#x27;id&#x27;</span>,<span class="string">&#x27;name&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> row <span class="keyword">in</span> rows:</span><br><span class="line">    <span class="built_in">print</span>(row)</span><br></pre></td></tr></table></figure>

<h2 id="查询所有课程成绩小于60分的同学的id和姓名；"><a href="#查询所有课程成绩小于60分的同学的id和姓名；" class="headerlink" title="查询所有课程成绩小于60分的同学的id和姓名；"></a>查询所有课程成绩小于60分的同学的id和姓名；</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">students = Student.objects.exclude(score__number__gt=<span class="number">60</span>)</span><br><span class="line"><span class="keyword">for</span> student <span class="keyword">in</span> students:</span><br><span class="line">    <span class="built_in">print</span>(student)</span><br></pre></td></tr></table></figure>

<h2 id="查询没有学全所有课的同学的id、姓名；"><a href="#查询没有学全所有课的同学的id、姓名；" class="headerlink" title="查询没有学全所有课的同学的id、姓名；"></a>查询没有学全所有课的同学的id、姓名；</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">students = Student.objects.annotate(num=Count(F(<span class="string">&quot;score__course&quot;</span>))).<span class="built_in">filter</span>(num__lt=Course.objects.count()).values(<span class="string">&#x27;id&#x27;</span>,<span class="string">&#x27;name&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> student <span class="keyword">in</span> students:</span><br><span class="line">    <span class="built_in">print</span>(student)</span><br></pre></td></tr></table></figure>

<h2 id="查询所有学生的姓名、平均分，并且按照平均分从高到低排序；"><a href="#查询所有学生的姓名、平均分，并且按照平均分从高到低排序；" class="headerlink" title="查询所有学生的姓名、平均分，并且按照平均分从高到低排序；"></a>查询所有学生的姓名、平均分，并且按照平均分从高到低排序；</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">students = Student.objects.annotate(avg=Avg(<span class="string">&quot;score__number&quot;</span>)).order_by(<span class="string">&quot;-avg&quot;</span>).values(<span class="string">&#x27;name&#x27;</span>,<span class="string">&#x27;avg&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> student <span class="keyword">in</span> students:</span><br><span class="line">    <span class="built_in">print</span>(student)</span><br></pre></td></tr></table></figure>

<h2 id="查询各科成绩的最高和最低分，以如下形式显示：课程ID，课程名称，最高分，最低分："><a href="#查询各科成绩的最高和最低分，以如下形式显示：课程ID，课程名称，最高分，最低分：" class="headerlink" title="查询各科成绩的最高和最低分，以如下形式显示：课程ID，课程名称，最高分，最低分："></a>查询各科成绩的最高和最低分，以如下形式显示：课程ID，课程名称，最高分，最低分：</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">courses = Course.objects.annotate(<span class="built_in">min</span>=Min(<span class="string">&quot;score__number&quot;</span>),<span class="built_in">max</span>=Max(<span class="string">&quot;score__number&quot;</span>)).values(<span class="string">&quot;id&quot;</span>,<span class="string">&#x27;name&#x27;</span>,<span class="string">&#x27;min&#x27;</span>,<span class="string">&#x27;max&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> course <span class="keyword">in</span> courses:</span><br><span class="line">    <span class="built_in">print</span>(course)</span><br></pre></td></tr></table></figure>

<h2 id="查询每门课程的平均成绩，按照平均成绩进行排序；"><a href="#查询每门课程的平均成绩，按照平均成绩进行排序；" class="headerlink" title="查询每门课程的平均成绩，按照平均成绩进行排序；"></a>查询每门课程的平均成绩，按照平均成绩进行排序；</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">courses = Course.objects.annotate(avg=Avg(<span class="string">&quot;score__number&quot;</span>)).order_by(<span class="string">&#x27;avg&#x27;</span>).values(<span class="string">&#x27;id&#x27;</span>,<span class="string">&#x27;name&#x27;</span>,<span class="string">&#x27;avg&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> course <span class="keyword">in</span> courses:</span><br><span class="line">    <span class="built_in">print</span>(course)</span><br></pre></td></tr></table></figure>

<h2 id="统计总共有多少女生，多少男生；"><a href="#统计总共有多少女生，多少男生；" class="headerlink" title="统计总共有多少女生，多少男生；"></a>统计总共有多少女生，多少男生；</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">rows = Student.objects.aggregate(male_num=Count(<span class="string">&quot;gender&quot;</span>,<span class="built_in">filter</span>=Q(gender=<span class="number">1</span>)),female_num=Count(<span class="string">&quot;gender&quot;</span>,<span class="built_in">filter</span>=Q(gender=<span class="number">2</span>)))</span><br><span class="line"><span class="built_in">print</span>(rows)</span><br></pre></td></tr></table></figure>

<h2 id="将“黄老师”的每一门课程都在原来的基础之上加5分；"><a href="#将“黄老师”的每一门课程都在原来的基础之上加5分；" class="headerlink" title="将“黄老师”的每一门课程都在原来的基础之上加5分；"></a>将“黄老师”的每一门课程都在原来的基础之上加5分；</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">rows = Score.objects.<span class="built_in">filter</span>(course__teacher__name=<span class="string">&#x27;黄老师&#x27;</span>).update(number=F(<span class="string">&quot;number&quot;</span>)+<span class="number">5</span>)</span><br><span class="line"><span class="built_in">print</span>(rows)</span><br></pre></td></tr></table></figure>

<h2 id="查询两门以上不及格的同学的id、姓名、以及不及格课程数；"><a href="#查询两门以上不及格的同学的id、姓名、以及不及格课程数；" class="headerlink" title="查询两门以上不及格的同学的id、姓名、以及不及格课程数；"></a>查询两门以上不及格的同学的id、姓名、以及不及格课程数；</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">students = Student.objects.annotate(bad_count=Count(<span class="string">&quot;score__number&quot;</span>,<span class="built_in">filter</span>=Q(score__number__lt=<span class="number">60</span>))).<span class="built_in">filter</span>(bad_count__gte=<span class="number">2</span>).values(<span class="string">&#x27;id&#x27;</span>,<span class="string">&#x27;name&#x27;</span>,<span class="string">&#x27;bad_count&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> student <span class="keyword">in</span> students:</span><br><span class="line">    <span class="built_in">print</span>(student)</span><br></pre></td></tr></table></figure>

<h2 id="查询每门课的选课人数；"><a href="#查询每门课的选课人数；" class="headerlink" title="查询每门课的选课人数；"></a>查询每门课的选课人数；</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">courses = Course.objects.annotate(student_nums=Count(<span class="string">&quot;score__student&quot;</span>)).values(<span class="string">&#x27;id&#x27;</span>,<span class="string">&#x27;name&#x27;</span>,<span class="string">&#x27;student_nums&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> course <span class="keyword">in</span> courses:</span><br><span class="line">    <span class="built_in">print</span>(course)</span><br></pre></td></tr></table></figure>

<h1 id="ORM模型迁移"><a href="#ORM模型迁移" class="headerlink" title="ORM模型迁移"></a>ORM模型迁移</h1><h2 id="命令说明"><a href="#命令说明" class="headerlink" title="命令说明"></a>命令说明</h2><h3 id="makemigrations"><a href="#makemigrations" class="headerlink" title="makemigrations"></a>makemigrations</h3><p>将模型生成迁移脚本。模型所在的app，必须放在<code>settings.py</code>中的<code>INSTALLED_APPS</code>中。这个命令有以下几个常用选项：</p>
<ul>
<li><code>app_label</code>：后面可以跟一个或者多个app，那么就只会针对这几个app生成迁移脚本。如果没有任何的app_label，那么会检查<code>INSTALLED_APPS</code>中所有的app下的模型，针对每一个app都生成响应的迁移脚本。</li>
<li><code>--name</code>：给这个迁移脚本指定一个名字。</li>
<li><code>--empty</code>：生成一个空的迁移脚本。如果你想写自己的迁移脚本，可以使用这个命令来实现一个空的文件，然后自己再在文件中写迁移脚本。</li>
</ul>
<h3 id="migrate"><a href="#migrate" class="headerlink" title="migrate"></a>migrate</h3><p>将新生成的迁移脚本。映射到数据库中。创建新的表或者修改表的结构。以下一些常用的选项：</p>
<ul>
<li><code>app_label</code>：将某个app下的迁移脚本映射到数据库中。如果没有指定，那么会将所有在<code>INSTALLED_APPS</code>中的app下的模型都映射到数据库中。</li>
<li><code>app_label migrationname</code>：将某个app下指定名字的migration文件映射到数据库中。</li>
<li><code>--fake</code>：可以将指定的迁移脚本名字添加到数据库中。但是并不会把迁移脚本转换为SQL语句，修改数据库中的表。</li>
<li><code>--fake-initial</code>：将第一次生成的迁移文件版本号记录在数据库中。但并不会真正的执行迁移脚本。</li>
<li><code>showmigrations</code>：查看某个app下的迁移文件。如果后面没有app，那么将查看<code>INSTALLED_APPS</code>中所有的迁移文件。</li>
</ul>
<p>sqlmigrate：查看某个迁移文件在映射到数据库中的时候，转换的SQL语句。</p>
<h2 id="migrate原理说明"><a href="#migrate原理说明" class="headerlink" title="migrate原理说明"></a>migrate原理说明</h2><h3 id="migrate做了什么事情："><a href="#migrate做了什么事情：" class="headerlink" title="migrate做了什么事情："></a>migrate做了什么事情：</h3><ol>
<li>将相关的迁移脚本翻译成SQL语句，在数据库中执行这个SQL语句。</li>
<li>如果这个SQL语句执行没有问题，那么就会将这个迁移脚本的名字记录到<code>django_migrations</code>中。</li>
</ol>
<h3 id="migrate怎么判断哪些迁移脚本需要执行"><a href="#migrate怎么判断哪些迁移脚本需要执行" class="headerlink" title="migrate怎么判断哪些迁移脚本需要执行"></a>migrate怎么判断哪些迁移脚本需要执行</h3><p>它会将代码项目中的迁移脚本和数据库中<code>django_migrations</code>表中的迁移脚本进行对比，如果发现数据库中，没有这个迁移脚本，那么就会执行这个迁移脚本。</p>
<h2 id="执行migrate命令的时候报错的解决办法"><a href="#执行migrate命令的时候报错的解决办法" class="headerlink" title="执行migrate命令的时候报错的解决办法"></a>执行migrate命令的时候报错的解决办法</h2><h3 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h3><p>执行<code>migrate</code>命令会报错的原因是。数据库的<code>django_migrations</code>表中的迁移版本记录和代码中的迁移脚本不一致导致的。</p>
<h3 id="解决办法："><a href="#解决办法：" class="headerlink" title="解决办法："></a>解决办法：</h3><h3 id="使用-fake参数："><a href="#使用-fake参数：" class="headerlink" title="使用--fake参数："></a>使用<code>--fake</code>参数：</h3><p>首先对比数据库中的迁移脚本和代码中的迁移脚本。然后找到哪个不同，之后再使用<code>--fake</code>，将代码中的迁移脚本添加到<code>django_migrations</code>中，但是并不会执行<code>sql</code>语句。这样就可以避免每次执行<code>migrate</code>的时候，都执行一些重复的迁移脚本。</p>
<h3 id="终极解决方案："><a href="#终极解决方案：" class="headerlink" title="终极解决方案："></a>终极解决方案：</h3><p>如果代码中的迁移脚本和数据库中的迁移脚本实在太多，很难找到准确出错位置。那么这时候就可以使用以下终极解决方案。就是清除之前的迁移脚本，重新映射，将出问题的app下的所有模型和数据库中表保持一致。操作步骤如下：</p>
<ol>
<li>将出问题的app下的所有模型，都和数据库中的表保持一致。</li>
<li>将出问题的app下的所有迁移脚本文件都删掉。再在<code>django_migrations</code>表中将出问题的app相关的迁移记录都删掉。</li>
<li>使用<code>makemigrations</code>，重新将模型生成一个迁移脚本。</li>
<li>使用<code>migrate --fake-initial</code>参数，将刚刚生成的迁移脚本，标记为已经完成（因为这些模型相对应的表，其实都已经在数据库中存在了，不需要重复执行了）。</li>
<li>之后可以正常映射了。</li>
</ol>
<h1 id="根据已有的表自动生成模型"><a href="#根据已有的表自动生成模型" class="headerlink" title="根据已有的表自动生成模型"></a>根据已有的表自动生成模型</h1><ol>
<li><p>首先需要在<code>settings.py</code>中配置好数据库相关信息</p>
</li>
<li><p>通过<code>python manage.py inspectdb &gt; models.py</code>，将表转换为模型后的代码，输出到<code>models.py</code>文件。如果只是想要转换一个表为模型。那么可以指定表的名字<code>python manage.py inspectdb article_article &gt; models.py</code></p>
</li>
<li><p>修正模型：新生成的ORM模型有些地方可能不太适合使用。比如模型的名字，表之间的关系等等。那么以下选项还需要重新配置一下：</p>
<ul>
<li>模型名：自动生成的模型，是根据表的名字生成的，可能不是你想要的。这时候模型的名字你可以改成任何你想要的。</li>
<li>模型所属app：根据自己的需要，将相应的模型放在对应的app中。放在同一个app中也是没有任何问题的。只是不方便管理。</li>
<li>模型外键引用：将所有使用<code>ForeignKey</code>的地方，模型引用都改成字符串。这样不会产生模型顺序的问题。另外，如果引用的模型已经移动到其他的app中了，那么还要加上这个app的前缀。</li>
<li>让<code>Django</code>管理模型：将<code>Meta</code>下的<code>managed=False</code>删掉，如果保留这个，那么以后这个模型有任何的修改，使用<code>migrate</code>都不会映射到数据库中。</li>
<li>当有多对多的时候，应该也要修正模型。将中间表注释了，然后使用<code>ManyToManyField</code>来实现多对多。并且，使用<code>ManyToManyField</code>生成的中间表的名字可能和数据库中那个中间表的名字不一致，这时候肯定就不能正常连接了。那么可以通过<code>db_table</code>来指定中间表的名字。示例代码如下：</li>
</ul>
 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Article</span>(<span class="params">models.Model</span>):</span></span><br><span class="line">title = models.CharField(max_length=<span class="number">100</span>, blank=<span class="literal">True</span>, null=<span class="literal">True</span>)</span><br><span class="line">content = models.TextField(blank=<span class="literal">True</span>, null=<span class="literal">True</span>)</span><br><span class="line">author = models.ForeignKey(<span class="string">&#x27;front.User&#x27;</span>, models.SET_NULL, blank=<span class="literal">True</span>, null=<span class="literal">True</span>)</span><br><span class="line"><span class="comment"># 使用ManyToManyField模型到表，生成的中间表的规则是：article_tags</span></span><br><span class="line"><span class="comment"># 但现在已经存在的表的名字叫做：article_tag</span></span><br><span class="line"><span class="comment"># 可以使用db_table，指定中间表的名字</span></span><br><span class="line">tags = models.ManyToManyField(<span class="string">&quot;Tag&quot;</span>,db_table=<span class="string">&#x27;article_tag&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Meta</span>:</span></span><br><span class="line">    db_table = <span class="string">&#x27;article&#x27;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>表名：切记不要修改表的名字。不然映射到数据库中，会发生找不到对应表的错误。</li>
</ul>
</li>
<li><p>执行命令<code>python manage.py makemigrations</code>生成初始化的迁移脚本。方便后面通过ORM来管理表。这时候还需要执行命令<code>python manage.py migrate [app_name] --fake-initial</code>，因为如果不使用<code>--fake-initial</code>，那么会将迁移脚本会映射到数据库中。这时候迁移脚本会新创建表，而这个表之前是已经存在了的，所以肯定会报错。此时我们只要将这个<code>0001-initial</code>的状态修改为已经映射，而不真正执行映射，下次再<code>migrate</code>的时候，就会忽略它。</p>
</li>
<li><p>将<code>Django</code>的核心表映射到数据库中：<code>Django</code>中还有一些核心的表也是需要创建的。不然有些功能是用不了的。比如<code>auth</code>相关表。如果这个数据库之前就是使用<code>Django</code>开发的，那么这些表就已经存在了。可以不用管了。如果之前这个数据库不是使用<code>Django</code>开发的，那么应该使用<code>migrate</code>命令将<code>Django</code>中的核心模型映射到数据库中。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>django</category>
      </categories>
      <tags>
        <tag>django</tag>
      </tags>
  </entry>
  <entry>
    <title>《MySQL必知必会》笔记</title>
    <url>/2019/02/09/%E3%80%8AMySQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%E3%80%8B%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="第1章-了解SQL"><a href="#第1章-了解SQL" class="headerlink" title="第1章 了解SQL"></a>第1章 了解SQL</h1><p>在使用多列作为主键时，上述条件必须应用到构成主键的所有列，所有列值的组合必须是唯一的（但单个列的值可以不唯一）</p>
<p><code>SQL</code>（发音为字母S-Q-L或sequel）是结构化查询语言（Structured Query Language）</p>
<h1 id="第2章-MySQL简介"><a href="#第2章-MySQL简介" class="headerlink" title="第2章 MySQL简介"></a>第2章 MySQL简介</h1><p>数据的所有存储、检索、管理和处理实际上是由数据库软件——DBMS（数据库管理系统-DataBase Management System）完成的</p>
<span id="more"></span>

<h1 id="第3章-使用MySQL"><a href="#第3章-使用MySQL" class="headerlink" title="第3章 使用MySQL"></a>第3章 使用MySQL</h1><p><code>SHOW DATABASES；</code>，返回可用数据库的一个列表</p>
<p><code>SHOW TABLES;</code>，返回当前选择的数据库内可用表的列表</p>
<p><code>SHOW COLUMNS FROM customers;</code>，查看表结构：字段名、数据类型、是否允许NULL、键信息、默认值以及其他信息（如字段cust_id的auto_increment）</p>
<p><code>DESCRIBE customers；</code>，是<code>SHOW COLUMNS FROM customers；</code>的一种快捷方式</p>
<h1 id="第4章-检索数据"><a href="#第4章-检索数据" class="headerlink" title="第4章 检索数据"></a>第4章 检索数据</h1><p><code>SQL</code>是不区分大小写的，许多SQL开发人员喜欢对所有SQL关键字使用大写，而对所有列和表名使用小写，这样做使代码更易于阅读和调试。<br>SQL语句可以在一行上给出，也可以分成许多行。多数SQL开发人员认为将SQL语句分成多行更容易阅读和调试。</p>
<p><code>DISTINCT</code>关键字，检索出有不同值的列表</p>
<p><code>SELECT DISTINCT vend_id FROM products;</code>,只返回不同值的vend_id行</p>
<p><code>DISTINCT</code>关键字应用于所有列而不仅是前置它的列，如果给出<code>SELECT DISTINCT vend_id, prod_price</code>，除非指定的两个列都不同，否则所有行都将被检索出来。</p>
<p><code>SELECT prod_name FROM products LIMIT 5;</code>，<code>LIMIT 5</code>指示<code>MySQL</code>返回不多于5行。</p>
<p><code>SELECT prod_name FROM products LIMIT 5,5;</code>，<code>LIMIT 5, 5</code>指示<code>MySQL</code>返回从行5开始的5行。第一个数为开始位置，第二个数为要检索的行数。行0检索出来的第一行为行0，而不是行1。因此，<code>LIMIT 1, 1</code>将检索出第二行而不是第一行。</p>
<p><code>LIMIT 4 OFFSET 3</code>意为从行3开始取4行，就像LIMIT 3, 4一样。</p>
<h1 id="第5章-排序检索数据"><a href="#第5章-排序检索数据" class="headerlink" title="第5章 排序检索数据"></a>第5章 排序检索数据</h1><p>关系数据库设计理论认为，如果不明确规定排序顺序，则不应该假定检索出的数据的顺序有意义。<br><code>ORDER BY</code>子句取一个或多个列的名字，据此对输出进行排序:</p>
<p><code>SELECT prod_name FROM products ORDER BY prod_name;</code>，对prod_name以字母顺序排序。</p>
<p>为了按多个列排序，只要指定列名，列名之间用逗号分开即可（就像选择多个列时所做的那样）。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># 首先按价格，然后再按名称排序</span><br><span class="line"># 以下是一条命令，分号算作结束，分行便于阅读</span><br><span class="line"><span class="keyword">SELECT</span> prod_id, prod_price, prod_name <span class="keyword">FROM</span> products</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> prod_price, prod_name;</span><br></pre></td></tr></table></figure>

<p>默认升序，为了进行降序排序，必须指定DESC关键字</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> prod_id, prod_price, prod_name</span><br><span class="line"><span class="keyword">FROM</span> products</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> prod_price <span class="keyword">DESC</span>;</span><br></pre></td></tr></table></figure>

<p><code>DESC</code>关键字只应用到直接位于其前面的列名，下面的例子以降序排序产品（最贵的在最前面），然后再对产品名排序（默认升序）：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> prod_id, prod_price, prod_name</span><br><span class="line"><span class="keyword">FROM</span> products</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> prod_price <span class="keyword">DESC</span>, prod_name;</span><br></pre></td></tr></table></figure>

<p>在多个列上降序排序 如果想在多个列上进行降序排序，必须对每个列指定<code>DESC</code>关键字。与<code>DESC</code>相反的关键字是<code>ASC（ASCENDING）</code>，在升序排序时可以指定它。但实际上，<code>ASC</code>没有多大用处，因为升序是默认的（如果既不指定<code>ASC</code>也不指定<code>DESC</code>，则假定为<code>ASC</code>）。</p>
<p>在字典（dictionary）排序顺序中，A被视为与a相同，这是MySQL（和大多数数据库管理系统）的默认行为。</p>
<p>使用<code>ORDER BY</code>和<code>LIMIT</code>的组合，能够找出一个列中最高或最低的值。下面的例子演示如何找出最昂贵物品的值:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> prod_price</span><br><span class="line"><span class="keyword">FROM</span> products</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> prod_price <span class="keyword">DESC</span></span><br><span class="line">LIMIT <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>在给出<code>ORDER BY</code>子句时，应该保证它位于<code>FROM</code>子句之后。如果使用<code>LIMIT</code>，它必须位于<code>ORDER BY</code>之后。使用子句的次序不对将产生错误消息。</p>
<h1 id="第6章-过滤数据"><a href="#第6章-过滤数据" class="headerlink" title="第6章 过滤数据"></a>第6章 过滤数据</h1><p>WHERE子句在表名（FROM子句）之后给出</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> prod_name, prod_price</span><br><span class="line"><span class="keyword">FROM</span> products</span><br><span class="line"><span class="keyword">WHERE</span> prod_price <span class="operator">=</span> <span class="number">2.5</span>;</span><br></pre></td></tr></table></figure>

<p>条件操作符（WHERE子句操作符）</p>
<table>
<thead>
<tr>
<th align="center">操作符</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">=</td>
<td align="center">等于</td>
</tr>
<tr>
<td align="center">&lt;&gt;</td>
<td align="center">不等于</td>
</tr>
<tr>
<td align="center">!=</td>
<td align="center">不等于</td>
</tr>
<tr>
<td align="center">&lt;</td>
<td align="center">小于</td>
</tr>
<tr>
<td align="center">&lt;=</td>
<td align="center">小于等于</td>
</tr>
<tr>
<td align="center">&gt;</td>
<td align="center">大于</td>
</tr>
<tr>
<td align="center">&gt;=</td>
<td align="center">大于等于</td>
</tr>
<tr>
<td align="center">BETWEEN</td>
<td align="center">在指定的两个值之间</td>
</tr>
</tbody></table>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> prod_name, prod_price</span><br><span class="line"><span class="keyword">FROM</span> products</span><br><span class="line"><span class="keyword">WHERE</span> prod_name <span class="operator">=</span> <span class="string">&#x27;fuses&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p><code>MySQL</code>在执行匹配时默认不区分大小写，所以<code>fuses</code>与<code>Fuses</code>匹配。<br>如果将值与串类型的列进行比较，则需要限定引号。用来与数值列进行比较的值不用引号。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> prod_name, prod_price</span><br><span class="line"><span class="keyword">FROM</span> products</span><br><span class="line"><span class="keyword">WHERE</span> prod_price <span class="keyword">BETWEEN</span> <span class="number">5</span> <span class="keyword">AND</span> <span class="number">10</span>;</span><br></pre></td></tr></table></figure>

<p><code>BETWEEN</code>匹配范围中所有的值，包括指定的开始值和结束值。</p>
<p><code>SELECT</code>语句有一个特殊的<code>WHERE</code>子句，可用来检查具有<code>NULL</code>值的列。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> prod_name</span><br><span class="line"><span class="keyword">FROM</span> products</span><br><span class="line"><span class="keyword">WHERE</span> prod_price <span class="keyword">IS</span> <span class="keyword">NULL</span>;</span><br></pre></td></tr></table></figure>

<p>在通过过滤选择出不具有特定值的行时，你可能希望返回具有<code>NULL</code>值的行。但是，不行。因为未知具有特殊的含义，数据库不知道它们是否匹配，所以在匹配过滤或不匹配过滤时不返回它们。因此，在过滤数据时，一定要验证返回数据中确实给出了被过滤列具有<code>NULL</code>的行。</p>
<h1 id="第7章-数据过滤"><a href="#第7章-数据过滤" class="headerlink" title="第7章 数据过滤"></a>第7章 数据过滤</h1><p>操作符（operator）：用来联结或改变<code>WHERE</code>子句中的子句的关键字。也称为逻辑操作符（logical operator）。<code>AND</code>操作符，<code>OR</code>操作符，<code>IN</code>操作符，<code>NOT</code>操作符。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> prod_id, prod_price, prod_name</span><br><span class="line"><span class="keyword">FROM</span> products</span><br><span class="line"><span class="keyword">WHERE</span> vend_id <span class="operator">=</span> <span class="number">1003</span> <span class="keyword">AND</span> prod_price <span class="operator">&lt;=</span><span class="number">10</span>;</span><br></pre></td></tr></table></figure>

<p>此<code>SQL</code>语句检索由供应商1003制造且价格小于等于10美元的所有产品的名称和价格。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> prod_name, prod_price</span><br><span class="line"><span class="keyword">FROM</span> products</span><br><span class="line"><span class="keyword">WHERE</span> vend_id <span class="operator">=</span> <span class="number">1002</span> <span class="keyword">OR</span> vend_id <span class="operator">=</span> <span class="number">1003</span>;</span><br></pre></td></tr></table></figure>

<p>此SQL语句检索由任一个指定供应商制造的所有产品的产品名和价格。<code>OR</code>操作符告诉<code>DBMS</code>匹配任一条件而不是同时匹配两个条件。</p>
<p><code>SQL</code>（像多数语言一样）在处理<code>OR</code>操作符前，优先处理<code>AND</code>操作符，<code>AND</code>在计算次序中优先级更高。任何时候使用具有<code>AND</code>和<code>OR</code>操作符的<code>WHERE</code>子句，都应该使用圆括号明确地分组操作符。</p>
<p><code>IN</code>操作符用来指定条件范围，范围中的每个条件都可以进行匹配。<code>IN</code>操作符完成与<code>OR</code>相同的功能。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> prod_name, prod_price</span><br><span class="line"><span class="keyword">FROM</span> products</span><br><span class="line"><span class="keyword">WHERE</span> vend_id <span class="keyword">IN</span> (<span class="number">1002</span>,<span class="number">1003</span>)</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> prod_name;</span><br></pre></td></tr></table></figure>

<p>此<code>SELECT</code>语句检索供应商1002和1003制造的所有产品，与下面的<code>SQL</code>语句效果相同。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> prod_name, prod_price</span><br><span class="line"><span class="keyword">FROM</span> products</span><br><span class="line"><span class="keyword">WHERE</span> vend_id <span class="operator">=</span> <span class="number">1002</span> <span class="keyword">OR</span> vend_id <span class="operator">=</span> <span class="number">1003</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> prod_name;</span><br></pre></td></tr></table></figure>

<p><code>IN</code>操作符优点具体如下：</p>
<ol>
<li>在使用长的合法选项清单时，IN操作符的语法更清楚且更直观。</li>
<li>在使用IN时，计算的次序更容易管理（因为使用的操作符更少）。</li>
<li>IN操作符一般比OR操作符清单执行更快。</li>
<li>IN的最大优点是可以包含其他SELECT语句，使得能够更动态地建立WHERE子句。</li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> prod_name, prod_price</span><br><span class="line"><span class="keyword">FROM</span> products</span><br><span class="line"><span class="keyword">WHERE</span> vend_id <span class="keyword">NOT</span> <span class="keyword">IN</span> (<span class="number">1002</span>,<span class="number">1003</span>)</span><br></pre></td></tr></table></figure>

<p>此<code>SELECT</code>语句列出除1002和1003之外的所有供应商制造的产品</p>
<p><code>MySQL</code>支持使用<code>NOT</code>对<code>IN</code>、<code>BETWEEN</code>和<code>EXISTS</code>子句取反</p>
<h1 id="第8章-用通配符进行过滤"><a href="#第8章-用通配符进行过滤" class="headerlink" title="第8章 用通配符进行过滤"></a>第8章 用通配符进行过滤</h1><p>操作符何时不是操作符？答案是在它作为谓词（predi-cate）时。</p>
<p><code>%</code>表示任何字符出现任意次数。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># 找出所有以词jet起头的产品</span><br><span class="line"><span class="keyword">SELECT</span> prod_id, prod_name</span><br><span class="line"><span class="keyword">FROM</span> products</span><br><span class="line"><span class="keyword">WHERE</span> prod_name <span class="keyword">LIKE</span> <span class="string">&#x27;jet%&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>根据MySQL的配置方式，搜索可以是区分大小写的。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># 可以使用多个通配符</span><br><span class="line"><span class="keyword">SELECT</span> prod_id, prod_name</span><br><span class="line"><span class="keyword">FROM</span> products</span><br><span class="line"><span class="keyword">WHERE</span> prod_name <span class="keyword">LIKE</span> `<span class="operator">%</span>anvil<span class="operator">%</span>`</span><br></pre></td></tr></table></figure>

<p><code>%</code>代表搜索模式中给定位置的0个、1个或多个字符。</p>
<p>尾空格可能会干扰通配符匹配,解决这个问题的一个简单的办法是在搜索模式最后附加一个%。一个更好的办法是使用函数（第11章将会介绍）去掉首尾空格。</p>
<p>即使是<code>WHERE prod_name LIKE &#39;%&#39;</code>也不能匹配用值NULL作为产品名的行。</p>
<p><code>_</code>下划线只匹配单个字符而不是多个字符</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> prod_id, prod_name</span><br><span class="line"><span class="keyword">FROM</span> products</span><br><span class="line"><span class="keyword">WHERE</span> prod_name <span class="keyword">LIKE</span> <span class="string">&#x27;_ ton anvil&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>通配符技巧：</p>
<ol>
<li>不要过度使用通配符。如果其他操作符能达到相同的目的，应该使用其他操作符。</li>
<li>在确实需要使用通配符时，除非绝对有必要，否则不要把它们用在搜索模式的开始处。把通配符置于搜索模式的开始处，搜索起来是最慢的。</li>
<li>仔细注意通配符的位置。如果放错地方，可能不会返回想要的数据。</li>
</ol>
<h1 id="第9章-用正则表达式进行搜索"><a href="#第9章-用正则表达式进行搜索" class="headerlink" title="第9章 用正则表达式进行搜索"></a>第9章 用正则表达式进行搜索</h1><p>检索列prod_name包含文本1000的所有行：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> prod_name</span><br><span class="line"><span class="keyword">FROM</span> products</span><br><span class="line"><span class="keyword">WHERE</span> prod_name REGEXP <span class="string">&#x27;1000&#x27;</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> prod_name</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> prod_name</span><br><span class="line"><span class="keyword">FROM</span> products</span><br><span class="line"><span class="keyword">WHERE</span> prod_name REGEXP <span class="string">&#x27;.000&#x27;</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> prod_name;</span><br></pre></td></tr></table></figure>

<p><code>.</code>是正则表达式语言中一个特殊的字符。它表示匹配任意一个字符。</p>
<p>MySQL中的正则表达式匹配（自版本3.23.4后）不区分大小写（即，大写和小写都匹配）。为区分大小写，可使用<code>BINARY</code>关键字，如<code>WHERE prod_name REGEXP BINARY &#39;JetPack .000&#39;</code>。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> prod_name</span><br><span class="line"><span class="keyword">FROM</span> products</span><br><span class="line"><span class="keyword">WHERE</span> prod_name REGEXP <span class="string">&#x27;1000|2000&#x27;</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> prod_name;</span><br></pre></td></tr></table></figure>

<p><code>|</code>为正则表达式的<code>OR</code>操作符。它表示匹配其中之一，因此1000和2000都匹配并返回。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> prod_name</span><br><span class="line"><span class="keyword">FROM</span> products</span><br><span class="line"><span class="keyword">WHERE</span> prod_name REGEXP <span class="string">&#x27;[123] Ton&#x27;</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> prod_name</span><br></pre></td></tr></table></figure>

<p><code>[123]</code>定义一组字符，它的意思是匹配1或2或3。</p>
<p>为否定一个字符集，在集合的开始处放置一个<code>^</code>即可。尽管<code>[123]</code>匹配字符1、2或3，但<code>[^123]</code>却匹配除这些字符外的任何东西。</p>
<p>下面的集合将匹配数字0到9：<code>[0123456789]</code>，可简化为<code>[0-9]</code>。<code>[1-3]</code>和<code>[6-9]</code>也是合法的范围。<code>[a-z]</code>匹配任意字母字符。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> prod_name</span><br><span class="line"><span class="keyword">FROM</span> products</span><br><span class="line"><span class="keyword">WHERE</span> prod_name REGEXP <span class="string">&#x27;[1-5] Ton&#x27;</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> prod_name</span><br></pre></td></tr></table></figure>

<p>为了匹配特殊字符，必须用<code>\\</code>为前导。<code>\\-</code>表示查找<code>-</code>, <code>\\．</code>表示查找<code>．</code>。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> vend_name</span><br><span class="line"><span class="keyword">FROM</span> vendors</span><br><span class="line"><span class="keyword">WHERE</span> vend_name REGEXP `\\.`</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> vend_name;</span><br></pre></td></tr></table></figure>

<p>转义。这包括<code>．</code>、<code>|</code>、<code>[]</code>以及迄今为止使用过的其他特殊字符。<code>\\</code>也用来引用元字符（具有特殊含义的字符）</p>
<p>空白元字符：</p>
<table>
<thead>
<tr>
<th align="center">元字符</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">\f</td>
<td align="center">换页</td>
</tr>
<tr>
<td align="center">\n</td>
<td align="center">换行</td>
</tr>
<tr>
<td align="center">\r</td>
<td align="center">回车</td>
</tr>
<tr>
<td align="center">\t</td>
<td align="center">制表</td>
</tr>
<tr>
<td align="center">\v</td>
<td align="center">纵向制表</td>
</tr>
</tbody></table>
<p>多数正则表达式实现使用单个反斜杠转义特殊字符，以便能使用这些字符本身。但<code>MySQL</code>要求两个反斜杠（<code>MySQL</code>自己解释一个，正则表达式库解释另一个）。</p>
<p>为更方便工作，可以使用预定义的字符集，称为字符类。</p>
<table>
<thead>
<tr>
<th align="center">类</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">[:alnum:]</td>
<td align="center">任意字母和数字（同[a-zA-Z0-9]）</td>
</tr>
<tr>
<td align="center">[:alpha:]</td>
<td align="center">任意字符（同[a-zA-Z]）</td>
</tr>
<tr>
<td align="center">[:blank:]</td>
<td align="center">空格和制表（同[\t]）</td>
</tr>
<tr>
<td align="center">[:cntrl:]</td>
<td align="center">ASCII 0到31和127</td>
</tr>
<tr>
<td align="center">[:digit:]</td>
<td align="center">任意数字（同[0-9]）</td>
</tr>
<tr>
<td align="center">[:graph:]</td>
<td align="center">与[:print:]相同，但不包括空格</td>
</tr>
<tr>
<td align="center">[:lower:]</td>
<td align="center">任意小写字母（同[a-z]）</td>
</tr>
<tr>
<td align="center">[:print:]</td>
<td align="center">任意可打印字符</td>
</tr>
<tr>
<td align="center">[:punct:]</td>
<td align="center">既不在[:alnum:]又不在[:cntrl:]中的任意字符</td>
</tr>
<tr>
<td align="center">[:space:]</td>
<td align="center">包括空格在内的任意空白字符（同[\f\n\r\t\v]）</td>
</tr>
<tr>
<td align="center">[:upper:]</td>
<td align="center">任意大写字母（同[a-Z]）</td>
</tr>
<tr>
<td align="center">[:xdigit:]</td>
<td align="center">任意十六进制数字（同[a-fA-F0-9]）</td>
</tr>
</tbody></table>
<p>正则表达式重复元字符:</p>
<table>
<thead>
<tr>
<th align="center">元字符</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">*</td>
<td align="center">0个或多个匹配</td>
</tr>
<tr>
<td align="center">+</td>
<td align="center">1个或多个匹配（等于{1，}）</td>
</tr>
<tr>
<td align="center">?</td>
<td align="center">0个或1个匹配（等于{0,1}）</td>
</tr>
<tr>
<td align="center">{n}</td>
<td align="center">指定数目的匹配</td>
</tr>
<tr>
<td align="center">{n,}</td>
<td align="center">不少于指定数目的匹配</td>
</tr>
<tr>
<td align="center">{n,m}</td>
<td align="center">匹配数目的范围(m不超过255)</td>
</tr>
</tbody></table>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> prod_name</span><br><span class="line"><span class="keyword">FROM</span> products</span><br><span class="line"><span class="keyword">WHERE</span> prod_name REGEXP <span class="string">&#x27;\\([0-9] sticks?\\)&#x27;</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> prod_name</span><br></pre></td></tr></table></figure>

<p>匹配到<code>TNT (1 stick)</code>，<code>TNT (5 sticks)</code>。<br>正则表达式<code>\\([0-9] sticks? \\)</code>需要解说一下。<code>\\(</code>匹配<code>(</code>, <code>[0-9]</code>匹配任意数字（这个例子中为1和5）, <code>sticks？</code>匹配<code>stick</code>和<code>sticks</code>（<code>s</code>后的<code>?</code>使<code>s</code>可选，因为<code>?</code>匹配它前面的任何字符的0次或1次出现）, <code>\\)</code>匹配<code>)</code>。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> prod_name</span><br><span class="line"><span class="keyword">FROM</span> products</span><br><span class="line">WHERE prod_name REGEXP `[[:DIGIT:]]&#123;4&#125;`</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> prod_name;</span><br></pre></td></tr></table></figure>

<p><code>[:digit:]</code>匹配任意数字，因而它为数字的一个集合。<code>&#123;4&#125;</code>确切地要求它前面的字符（任意数字）出现4次，所以<code>[[:digit:]]&#123;4&#125;</code>匹配连在一起的任意4位数字。</p>
<p>为了匹配特定位置的文本，需要使用定位符：</p>
<table>
<thead>
<tr>
<th align="center">元字符</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">^</td>
<td align="center">文本的开始</td>
</tr>
<tr>
<td align="center">$</td>
<td align="center">文本的结尾</td>
</tr>
<tr>
<td align="center">[[:&lt;:]]</td>
<td align="center">词的开始</td>
</tr>
<tr>
<td align="center">[[:&gt;:]]</td>
<td align="center">词的结尾</td>
</tr>
</tbody></table>
<p>查询以一个数（包括以小数点开始的数）开始的所有产品，需要使用^定位符：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> prod_name</span><br><span class="line"><span class="keyword">FROM</span> products</span><br><span class="line"><span class="keyword">WHERE</span> prod_name REGEXP <span class="string">&#x27;^[0-9\\.]&#x27;</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> prod_name;</span><br></pre></td></tr></table></figure>

<p><code>^</code>有两种用法。在集合中（用<code>[和]</code>定义），用它来否定该集合，如<code>[^1002,1003]</code>。否则，用来指串的开始处。</p>
<p><code>LIKE</code>和<code>REGEXP</code>的不同在于，<code>LIKE</code>匹配整个串而<code>REGEXP</code>匹配子串。利用定位符，通过用<code>^</code>开始每个表达式，用<code>$</code>结束每个表达式，可以使<code>REGEXP</code>的作用与<code>LIKE</code>一样。</p>
<h1 id="第10章-创建计算字段"><a href="#第10章-创建计算字段" class="headerlink" title="第10章 创建计算字段"></a>第10章 创建计算字段</h1><p>计算字段并不实际存在于数据库表中。计算字段是运行时在SELECT语句内创建的。从客户机（如应用程序）的角度来看，计算字段的数据是以与其他列的数据相同的方式返回的。</p>
<p><code>Concat()</code>拼接串，即把多个串连接起来形成一个较长的串。多数<code>DBMS</code>使用<code>+</code>或<code>||</code>来实现拼接，<code>MySQL</code>则使用<code>Concat()</code>函数来实现。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> Concat(vend_name, <span class="string">&#x27; (&#x27;</span>, vend_country, <span class="string">&#x27;)&#x27;</span>)</span><br><span class="line"><span class="keyword">FROM</span> vendors</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> vend_name;</span><br></pre></td></tr></table></figure>

<p>上面的<code>SELECT</code>语句连接以下4个元素：</p>
<ul>
<li>存储在vend_name列中的名字；</li>
<li>包含一个空格和一个左圆括号的串；</li>
<li>存储在vend_country列中的国家；</li>
<li>包含一个右圆括号的串。</li>
</ul>
<p>输出为<code>ACME (USA)</code>。</p>
<p><code>MySQL</code>的<code>RTrim()</code>函数可以删除数据右侧多余的空格。<br><code>MySQL</code>除了支持<code>RTrim()</code>，还支持<code>LTrim()</code>（去掉串左边的空格）以及<code>Trim()</code>（去掉串左右两边的空格）。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> Concat(RTrim(vend_name), <span class="string">&#x27; (&#x27;</span>, RTrim(vend_country), <span class="string">&#x27;)&#x27;</span>)</span><br><span class="line"><span class="keyword">FROM</span> vendors</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> vend_name</span><br></pre></td></tr></table></figure>

<p>别名用<code>AS</code>关键字赋予</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> Concat(RTrim(vend_name), <span class="string">&#x27; (&#x27;</span>, RTrim(vend_country), <span class="string">&#x27;)&#x27;</span>) <span class="keyword">AS</span></span><br><span class="line">vend_title</span><br><span class="line"><span class="keyword">FROM</span> vendors</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> vend_name</span><br></pre></td></tr></table></figure>

<p>现在的列名为<code>vend_title</code>，任何客户机应用都可以按名引用这个列，就像它是一个实际的表列一样。</p>
<p>如下汇总物品的价格:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> prod_id,</span><br><span class="line">       quantity,</span><br><span class="line">       item_price,</span><br><span class="line">       quantity<span class="operator">*</span>item_price <span class="keyword">AS</span> expanded_price</span><br><span class="line"><span class="keyword">FROM</span> orderitems</span><br><span class="line"><span class="keyword">WHERE</span> order_num <span class="operator">=</span> <span class="number">20005</span>;</span><br></pre></td></tr></table></figure>

<p><img data-src="AS%E5%85%B3%E9%94%AE%E5%AD%97.jpg" alt="输出结果"></p>
<p>输出中显示的<code>expanded_price</code>列为一个计算字段，此计算为<code>quantity*item_price</code>。客户机应用现在可以使用这个新计算列，就像使用其他列一样。</p>
<p>基本算术操作符:</p>
<table>
<thead>
<tr>
<th align="center">操作符</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">+</td>
<td align="center">加</td>
</tr>
<tr>
<td align="center">-</td>
<td align="center">减</td>
</tr>
<tr>
<td align="center">*</td>
<td align="center">乘</td>
</tr>
<tr>
<td align="center">/</td>
<td align="center">除</td>
</tr>
</tbody></table>
<h1 id="第11章-使用数据处理函数"><a href="#第11章-使用数据处理函数" class="headerlink" title="第11章 使用数据处理函数"></a>第11章 使用数据处理函数</h1><p>大多数<code>SQL</code>实现支持以下类型的函数:</p>
<ul>
<li>用于处理文本串（如删除或填充值，转换值为大写或小写）的文本函数。</li>
<li>用于在数值数据上进行算术操作（如返回绝对值，进行代数运算）的数值函数。</li>
<li>用于处理日期和时间值并从这些值中提取特定成分（例如，返回两个日期之差，检查日期有效性等）的日期和时间函数。</li>
<li>返回DBMS正使用的特殊信息（如返回用户登录信息，检查版本细节）的系统函数。</li>
</ul>
<p><code>Upper()</code>函数：将文本转换为大写</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> vend_name, <span class="built_in">Upper</span>(vend_name) <span class="keyword">AS</span> vend_name_upcase</span><br><span class="line"><span class="keyword">FROM</span> vendors</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> vend_name</span><br></pre></td></tr></table></figure>

<p>常用的文本处理函数：</p>
<table>
<thead>
<tr>
<th align="center">函数</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Left()</td>
<td align="center">返回串左边的字符</td>
</tr>
<tr>
<td align="center">Length()</td>
<td align="center">返回串的长度</td>
</tr>
<tr>
<td align="center">Locate()</td>
<td align="center">返回串的一个子串</td>
</tr>
<tr>
<td align="center">Lower</td>
<td align="center">将串转换为小写</td>
</tr>
<tr>
<td align="center">LTrim()</td>
<td align="center">去掉串左边的空格</td>
</tr>
<tr>
<td align="center">Right()</td>
<td align="center">返回串右边的字符</td>
</tr>
<tr>
<td align="center">Rtrim()</td>
<td align="center">去掉串右边的空格</td>
</tr>
<tr>
<td align="center">Soundex()</td>
<td align="center">返回串的SOUNDEX值</td>
</tr>
<tr>
<td align="center">SubString()</td>
<td align="center">返回子串的字符</td>
</tr>
<tr>
<td align="center">Upper()</td>
<td align="center">将串转换为大写</td>
</tr>
</tbody></table>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> cust_name, cust_contact</span><br><span class="line"><span class="keyword">FROM</span> customers</span><br><span class="line"><span class="keyword">WHERE</span> Soundex(cust_contact) <span class="operator">=</span> Soundex(<span class="string">&#x27;Y Lie&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p><code>Soundex()</code>函数进行搜索，它匹配所有发音类似于<code>Y.Lie</code>的联系名。<br><code>WHERE</code>子句使用<code>Soundex()</code>函数来转换<code>cust_contact</code>列值和搜索串为它们的<code>SOUNDEX</code>值。因为<code>Y.Lee</code>和<code>Y.Lie</code>发音相似，所以它们的<code>SOUNDEX</code>值匹配，因此<code>WHERE</code>子句正确地过滤出了所需的数据。</p>
<p>常用的日期和时间处理函数：</p>
<table>
<thead>
<tr>
<th align="center">函数</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">AddDate()</td>
<td align="center">增加一个日期（天，周等）</td>
</tr>
<tr>
<td align="center">AddTime()</td>
<td align="center">增加一个时间（时，分等）</td>
</tr>
<tr>
<td align="center">CurDate()</td>
<td align="center">返回当前日期</td>
</tr>
<tr>
<td align="center">CurTime()</td>
<td align="center">返回当前时间</td>
</tr>
<tr>
<td align="center">Date()</td>
<td align="center">返回日期时间的日期部分</td>
</tr>
<tr>
<td align="center">DateDiff()</td>
<td align="center">计算两个日期之差</td>
</tr>
<tr>
<td align="center">Date_Add()</td>
<td align="center">高度灵活的日期运算函数</td>
</tr>
<tr>
<td align="center">Date_Format()</td>
<td align="center">返回一个格式化的日期或时间串</td>
</tr>
<tr>
<td align="center">Day()</td>
<td align="center">返回一个日期的天数部分</td>
</tr>
<tr>
<td align="center">DayOfWeek()</td>
<td align="center">对于一个日期，返回对于的星期几</td>
</tr>
<tr>
<td align="center">Hour()</td>
<td align="center">返回一个时间的小时部分</td>
</tr>
<tr>
<td align="center">Minute()</td>
<td align="center">返回一个时间的分钟部分</td>
</tr>
<tr>
<td align="center">Month()</td>
<td align="center">返回一个日期的月份部分</td>
</tr>
<tr>
<td align="center">Now()</td>
<td align="center">返回当前日期和时间</td>
</tr>
<tr>
<td align="center">Second()</td>
<td align="center">返回一个时间的秒部分</td>
</tr>
<tr>
<td align="center">Time()</td>
<td align="center">返回一个日期时间的时间部分</td>
</tr>
<tr>
<td align="center">Year()</td>
<td align="center">返回一个日期的年份部分</td>
</tr>
</tbody></table>
<p><code>MySQL</code>使用的日期格式必须为<code>yyyy-mm-dd</code>。</p>
<p><code>Date(order_date)</code>指示<code>MySQL</code>仅提取列的日期部分。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> cust_id, order_num</span><br><span class="line"><span class="keyword">FROM</span> orders</span><br><span class="line"><span class="keyword">WHERE</span> <span class="type">Date</span>(order_date) <span class="operator">=</span> <span class="string">&#x27;2005-09-01&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>检索出2005年9月下的所有订单：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> cust_id, order_num</span><br><span class="line"><span class="keyword">FROM</span> orders</span><br><span class="line"><span class="keyword">WHERE</span> <span class="type">Date</span>(order_date) <span class="keyword">BETWEEN</span> <span class="string">&#x27;2005-09-01&#x27;</span> <span class="keyword">AND</span> <span class="string">&#x27;2005-09-30&#x27;</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> cust_id, order_num</span><br><span class="line"><span class="keyword">FROM</span> orders</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">Year</span>(order_date) <span class="operator">=</span> <span class="number">2005</span> <span class="keyword">AND</span> <span class="keyword">Month</span>(order_date) <span class="operator">=</span> <span class="number">9</span>;</span><br></pre></td></tr></table></figure>

<p><code>Month()</code>从日期中返回月份。因此，<code>WHERE Year(order_date)= 2005 AND Month(order_date) = 9</code>检索出<code>order_date</code>为2005年9月的所有行</p>
<p>常用的数值处理函数：</p>
<table>
<thead>
<tr>
<th align="center">函数</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Abs()</td>
<td align="center">返回一个数的绝对值</td>
</tr>
<tr>
<td align="center">Cos()</td>
<td align="center">返回一个角度的余弦</td>
</tr>
<tr>
<td align="center">Exp()</td>
<td align="center">返回一个数的指数值</td>
</tr>
<tr>
<td align="center">Mod()</td>
<td align="center">返回除操作的余数</td>
</tr>
<tr>
<td align="center">Pi()</td>
<td align="center">返回圆周率</td>
</tr>
<tr>
<td align="center">Rand()</td>
<td align="center">返回一个随机数</td>
</tr>
<tr>
<td align="center">Sin()</td>
<td align="center">返回一个角度的正弦</td>
</tr>
<tr>
<td align="center">Sqrt()</td>
<td align="center">返回一个数的平方根</td>
</tr>
<tr>
<td align="center">Tan()</td>
<td align="center">返回一个角度的正切</td>
</tr>
</tbody></table>
<h1 id="第12章-汇总数据"><a href="#第12章-汇总数据" class="headerlink" title="第12章 汇总数据"></a>第12章 汇总数据</h1><p>用于汇总检索数据，例子有：</p>
<ul>
<li>确定表中行数（或者满足某个条件或包含某个特定值的行数）。</li>
<li>获得表中行组的和。</li>
<li>找出表列（或所有行或某些特定的行）的最大值、最小值和平均值</li>
</ul>
<p>聚集函数：</p>
<table>
<thead>
<tr>
<th align="center">函数</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">AVG()</td>
<td align="center">返回某列的平均值</td>
</tr>
<tr>
<td align="center">COUNT()</td>
<td align="center">返回某列的行数</td>
</tr>
<tr>
<td align="center">MAX()</td>
<td align="center">返回某列的最大值</td>
</tr>
<tr>
<td align="center">MIN()</td>
<td align="center">返回某列的最小值</td>
</tr>
<tr>
<td align="center">SUM()</td>
<td align="center">返回某列值之和</td>
</tr>
</tbody></table>
<p><code>AVG()</code>通过对表中行数计数并计算特定列值之和，求得该列的平均值。<code>AVG()</code>可用来返回所有列的平均值，也可以用来返回特定列或行的平均值。</p>
<p>使用<code>AVG()</code>返回<code>products</code>表中所有产品的平均价格：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">AVG</span>(prod_price) <span class="keyword">AS</span> avg_price</span><br><span class="line"><span class="keyword">FROM</span> products</span><br></pre></td></tr></table></figure>

<p><code>AVG()</code>也可以用来确定特定列或行的平均值。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">AVG</span>(prod_price) <span class="keyword">AS</span> AVG_price</span><br><span class="line"><span class="keyword">FROM</span> products</span><br><span class="line"><span class="keyword">WHERE</span> vend_id <span class="operator">=</span> <span class="number">1003</span>;</span><br></pre></td></tr></table></figure>

<p>此<code>WHERE</code>子句仅过滤出<code>vend_id</code>为1003的产品，因此<code>avg_price</code>中返回的值只是该供应商的产品的平均值。</p>
<p><code>AVG()</code>只能用来确定特定数值列的平均值，而且列名必须作为函数参数给出。为了获得多个列的平均值，必须使用多个<code>AVG()</code>函数。</p>
<p>可利用<code>COUNT()</code>确定表中行的数目或符合特定条件的行的数目</p>
<p><code>COUNT()</code>函数有两种使用方式:</p>
<ul>
<li>使用<code>COUNT(*)</code>对表中行的数目进行计数，不管表列中包含的是空值（NULL）还是非空值。</li>
<li>使用<code>COUNT(column)</code>对特定列中具有值的行进行计数，忽略NULL值。</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">AS</span> num_cust</span><br><span class="line"><span class="keyword">FROM</span> customers;</span><br></pre></td></tr></table></figure>

<p>上面返回<code>customers</code>表中客户的总数，在此例子中，利用<code>COUNT(*)</code>对所有行计数，不管行中各列有什么值。计数值在<code>num_cust</code>中返回。</p>
<p>下面的例子只对具有电子邮件地址的客户计数:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(cust_email) <span class="keyword">AS</span> num_cust</span><br><span class="line"><span class="keyword">FROM</span> customers;</span><br></pre></td></tr></table></figure>

<p><code>NULL</code>值，如果指定列名，则指定列的值为空的行被<code>COUNT()</code>函数忽略，但如果<code>COUNT()</code>函数中用的是星号（<code>*</code>），则不忽略。</p>
<p><code>MAX()</code>返回指定列中的最大值。<code>MAX()</code>要求指定列名。在用于文本数据时，如果数据按相应的列排序，则<code>MAX()</code>返回最后一行。<code>MAX()</code>函数忽略列值为<code>NULL</code>的行。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">MAX</span>(prod_price) <span class="keyword">AS</span> max_price</span><br><span class="line"><span class="keyword">FROM</span> products;</span><br></pre></td></tr></table></figure>

<p><code>MAX()</code>返回<code>products</code>表中最贵的物品的价格。</p>
<p><code>MIN()</code>,它返回指定列的最小值。<code>MIN()</code>要求指定列名。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">MIN</span>(pro_price) <span class="keyword">AS</span> min_price</span><br><span class="line"><span class="keyword">FROM</span> products;</span><br></pre></td></tr></table></figure>

<p><code>MIN()</code>返回<code>products</code>表中最便宜物品的价格。</p>
<p><code>SUM()</code>用来返回指定列值的和（总计）。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">SUM</span>(quantity) <span class="keyword">AS</span> items_ordered</span><br><span class="line"><span class="keyword">FROM</span> orderitems</span><br><span class="line"><span class="keyword">WHERE</span> order_num <span class="operator">=</span> <span class="number">20005</span>;</span><br></pre></td></tr></table></figure>

<p>函数<code>SUM(quantity)</code>返回订单中所有物品数量之和，<code>WHERE</code>子句保证只统计某个物品订单中的物品。</p>
<p>下面的例子中，合计每项物品的<code>item_price*quantity</code>，得出总的订单金额。<br>函数<code>SUM(item_price*quantity)</code>返回订单中所有物品价钱之和，<code>WHERE</code>子句同样保证只统计某个物品订单中的物品。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">SUM</span>(item_price<span class="operator">*</span>quantity) <span class="keyword">AS</span> total_price</span><br><span class="line"><span class="keyword">FROM</span> orderitems</span><br><span class="line"><span class="keyword">WHERE</span> order_num <span class="operator">=</span> <span class="number">20005</span>;</span><br></pre></td></tr></table></figure>

<p>下面使用了<code>DISTINCT</code>参数，因此平均值只考虑各个不同的价格。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">AVG</span>(<span class="keyword">DISTINCT</span> prod_price) <span class="keyword">AS</span> avg_price</span><br><span class="line"><span class="keyword">FROM</span> products</span><br><span class="line"><span class="keyword">WHERE</span> vend_id <span class="operator">=</span> <span class="number">1003</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">AS</span> num_items,</span><br><span class="line">       <span class="built_in">MIN</span>(prod_price) <span class="keyword">AS</span> price_min,</span><br><span class="line">       <span class="built_in">MAX</span>(prod_price) <span class="keyword">AS</span> price_max,</span><br><span class="line">       <span class="built_in">AVG</span>(prod_price) <span class="keyword">AS</span> price_avg,</span><br><span class="line"><span class="keyword">FROM</span> products;</span><br></pre></td></tr></table></figure>

<p>单条<code>SELECT</code>语句执行了4个聚集计算，返回4个值（<code>products</code>表中物品的数目，产品价格的最低、最高以及平均值）。</p>
<p>在指定别名以包含某个聚集函数的结果时，不应该使用表中实际的列名。</p>
<h1 id="第13章-分组数据"><a href="#第13章-分组数据" class="headerlink" title="第13章 分组数据"></a>第13章 分组数据</h1><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> vend_id, <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">AS</span> num_prods</span><br><span class="line"><span class="keyword">FROM</span> products</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> vend_id;</span><br></pre></td></tr></table></figure>

<p>上面的<code>SELECT</code>语句指定了两个列，<code>vend_id</code>包含产品供应商的<code>ID</code>, <code>num_prods</code>为计算字段（用<code>COUNT(*)</code>函数建立）。<code>GROUP BY</code>子句指示<code>MySQL</code>按<code>vend_id</code>排序并分组数据。这导致对每个<code>vend_id</code>而不是整个表计算<code>num_prods</code>一次。</p>
<p><code>GROUP BY</code>子句指示<code>MySQL</code>分组数据，然后对每个组而不是整个结果集进行聚集。</p>
<p>重要的规定：</p>
<ul>
<li><code>GROUP BY</code>子句可以包含任意数目的列。这使得能对分组进行嵌套，为数据分组提供更细致的控制。</li>
<li>如果在<code>GROUP BY</code>子句中嵌套了分组，数据将在最后规定的分组上进行汇总。换句话说，在建立分组时，指定的所有列都一起计算（所以不能从个别的列取回数据）。</li>
<li><code>GROUP BY</code>子句中列出的每个列都必须是检索列或有效的表达式（但不能是聚集函数）。如果在<code>SELECT</code>中使用表达式，则必须在<code>GROUP BY</code>子句中指定相同的表达式。不能使用别名。</li>
<li>除聚集计算语句外，<code>SELECT</code>语句中的每个列都必须在<code>GROUP BY</code>子句中给出。</li>
<li>如果分组列中具有<code>NULL</code>值，则<code>NULL</code>将作为一个分组返回。如果列中有多行<code>NULL</code>值，它们将分为一组。</li>
<li><code>GROUP BY</code>子句必须出现在<code>WHERE</code>子句之后，<code>ORDER BY</code>子句之前。</li>
</ul>
<p>使用<code>WITH ROLLUP</code>关键字，可以得到每个分组以及每个分组汇总级别（针对每个分组）的值，如下所示：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># 不太明白，需要再具体查查</span><br><span class="line"><span class="keyword">SELECT</span> vend_id, <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">AS</span> num_prods</span><br><span class="line"><span class="keyword">FROM</span> products</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> vend_id <span class="keyword">WITH</span> <span class="keyword">ROLLUP</span></span><br></pre></td></tr></table></figure>

<p><code>WHERE</code>过滤行，而<code>HAVING</code>过滤分组，<code>HAVING</code>支持所有<code>WHERE</code>操作符。<br><code>WHERE</code>在数据分组前进行过滤，HAVING在数据分组后进行过滤。<code>WHERE</code>排除的行不包括在分组中。这可能会改变计算值，从而影响<code>HAVING</code>子句中基于这些值过滤掉的分组。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> cust_id, <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">AS</span> orders</span><br><span class="line"><span class="keyword">FROM</span> orders</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> cust_id</span><br><span class="line"><span class="keyword">HAVING</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="operator">&gt;=</span> <span class="number">2</span>;</span><br></pre></td></tr></table></figure>

<p><code>HAVING</code>过滤<code>COUNT(*) &gt;=2</code>（两个以上的订单）的那些分组。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> vend_id, <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">AS</span> num_prods</span><br><span class="line"><span class="keyword">FROM</span> products</span><br><span class="line"><span class="keyword">WHERE</span> prod_price <span class="operator">&gt;=</span> <span class="number">10</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> vend_id</span><br><span class="line"><span class="keyword">HAVING</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="operator">&gt;=</span><span class="number">2</span>;</span><br></pre></td></tr></table></figure>

<p>上面列出具有2个（含）以上、价格为10（含）以上的产品的供应商。<br><code>WHERE</code>子句过滤所有<code>prod_price</code>至少为10的行。然后按<code>vend_id</code>分组数据，<code>HAVING</code>子句过滤计数为2或2以上的分组</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> order_num, <span class="built_in">SUM</span>(quantity<span class="operator">*</span>item_price) <span class="keyword">AS</span> ordertotal</span><br><span class="line"><span class="keyword">FROM</span> orderitems</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> order_num</span><br><span class="line"><span class="keyword">HAVING</span> <span class="built_in">SUM</span>(quantity<span class="operator">*</span>item_price) <span class="operator">&gt;=</span> <span class="number">50</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> ordertotal;</span><br></pre></td></tr></table></figure>

<p><code>GROUP BY</code>子句用来按订单号（<code>order_num</code>列）分组数据，以便<code>SUM(*)</code>函数能够返回总计订单价格。<code>HAVING</code>子句过滤数据，使得只返回总计订单价格大于等于50的订单。最后，用<code>ORDER BY</code>子句排序输出。</p>
<p><code>SELECT</code>语句中子句的顺序：</p>
<table>
<thead>
<tr>
<th align="center">子句</th>
<th align="center">说明</th>
<th align="center">是否必须使用</th>
</tr>
</thead>
<tbody><tr>
<td align="center">SELECT</td>
<td align="center">要返回的列或表达式</td>
<td align="center">是</td>
</tr>
<tr>
<td align="center">FROM</td>
<td align="center">从中检索数据的表</td>
<td align="center">仅在从表选择数据时使用</td>
</tr>
<tr>
<td align="center">WHERE</td>
<td align="center">行级过滤</td>
<td align="center">否</td>
</tr>
<tr>
<td align="center">GROUP BY</td>
<td align="center">分组说明</td>
<td align="center">仅在按组计算聚集时使用</td>
</tr>
<tr>
<td align="center">HAVING</td>
<td align="center">组级过滤</td>
<td align="center">否</td>
</tr>
<tr>
<td align="center">ORDER BY</td>
<td align="center">输出排序顺序</td>
<td align="center">否</td>
</tr>
<tr>
<td align="center">LIMIT</td>
<td align="center">要检索的行数</td>
<td align="center">否</td>
</tr>
</tbody></table>
<h1 id="第14章-使用子查询"><a href="#第14章-使用子查询" class="headerlink" title="第14章 使用子查询"></a>第14章 使用子查询</h1><p>把第一个查询（返回订单号的那一个）变为子查询组合两个查询</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> cust_id</span><br><span class="line"><span class="keyword">FROM</span> orders</span><br><span class="line"><span class="keyword">WHERE</span> order_num <span class="keyword">IN</span> (<span class="keyword">SELECT</span> order_num</span><br><span class="line">                    <span class="keyword">FROM</span> orderitems</span><br><span class="line">                    <span class="keyword">WHERE</span> prod_id <span class="operator">=</span> <span class="string">&#x27;TNT2&#x27;</span>);</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> cust_name, cust_contact</span><br><span class="line"><span class="keyword">FROM</span> customer</span><br><span class="line"><span class="keyword">WHERE</span> cust_id <span class="keyword">IN</span> (<span class="keyword">SELECT</span> cust_id</span><br><span class="line">                  <span class="keyword">FROM</span> orders</span><br><span class="line">                  <span class="keyword">WHERE</span> order_num <span class="keyword">IN</span> (<span class="keyword">SELECT</span> order_num</span><br><span class="line">                                      <span class="keyword">FROM</span> orderitems</span><br><span class="line">                                      <span class="keyword">WHERE</span> prod_id <span class="operator">=</span> <span class="string">&#x27;TNT2&#x27;</span>);)</span><br></pre></td></tr></table></figure>

<p>为了执行上述<code>SELECT</code>语句，<code>MySQL</code>实际上必须执行3条<code>SELECT</code>语句。最里边的子查询返回订单号列表，此列表用于其外面的子查询的<code>WHERE</code>子句。外面的子查询返回客户<code>ID</code>列表，此客户<code>ID</code>列表用于最外层查询的<code>WHERE</code>子句。最外层查询确实返回所需的数据。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> cust_name, </span><br><span class="line">       cust_state,</span><br><span class="line">       (<span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>)</span><br><span class="line">        <span class="keyword">FROM</span> orders</span><br><span class="line">        <span class="keyword">WHERE</span> orders.cust_id <span class="operator">=</span> customers.cust_id) <span class="keyword">AS</span> orders</span><br><span class="line"><span class="keyword">FROM</span> customers</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> cust_name;</span><br></pre></td></tr></table></figure>

<p><code>orders</code>是一个计算字段，它是由圆括号中的子查询建立的。该子查询对检索出的每个客户执行一次。<br>子查询中使用了完全限定列名。</p>
<p>下面的语句告诉<code>SQL</code>比较<code>orders</code>表中的<code>cust_id</code>与当前正从<code>customers</code>表中检索的<code>cust_id</code>：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">WHERE</span> orders.cust_id <span class="operator">=</span> customers.cust_id</span><br></pre></td></tr></table></figure>

<h1 id="第15章-联结表"><a href="#第15章-联结表" class="headerlink" title="第15章 联结表"></a>第15章 联结表</h1><p>外键为某个表中的一列，它包含另一个表的主键值</p>
<p>联结是一种机制，用来在一条SELECT语句中关联表，因此称之为联结。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> vend_name, prod_name, prod_price</span><br><span class="line"><span class="keyword">FROM</span> vendors, products</span><br><span class="line"><span class="keyword">WHERE</span> vendors.vend_id <span class="operator">=</span> products.vend_id</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> vend_name, prod_name;</span><br></pre></td></tr></table></figure>

<p>这两个表用<code>WHERE</code>子句正确联结，<code>WHERE</code>子句指示<code>MySQL</code>匹配<code>vendors</code>表中的<code>vend_id</code>和<code>products</code>表中的<code>vend_id</code>。<br>在联结两个表时，你实际上做的是将第一个表中的每一行与第二个表中的每一行配对。</p>
<p>应该保证所有联结都有WHERE子句，否则<code>MySQ</code>L将返回比想要的数据多得多的数据。</p>
<p>等值联结，基于两个表之间的相等测试。这种联结也称为内部联结</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> vend_name, prod_name, prod_price</span><br><span class="line"><span class="keyword">FROM</span> vendors <span class="keyword">INNER</span> <span class="keyword">JOIN</span> products</span><br><span class="line"><span class="keyword">ON</span> vendors.vend_id <span class="operator">=</span> products.vend_id;</span><br></pre></td></tr></table></figure>

<p>此语句中的<code>SELECT</code>与前面的<code>SELECT</code>语句相同，但<code>FROM</code>子句不同。这里，两个表之间的关系是<code>FROM</code>子句的组成部分，以<code>INNER JOIN</code>指定。在使用这种语法时，联结条件用特定的<code>ON</code>子句而不是<code>WHERE</code>子句给出。传递给<code>ON</code>的实际条件与传递给<code>WHERE</code>的相同。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># 首先列出所有表，然后定义表之间的关系</span><br><span class="line"><span class="keyword">SELECT</span> prod_name, vend_name, prod_price, quantity</span><br><span class="line"><span class="keyword">FROM</span> orderitems, products, vendors</span><br><span class="line"><span class="keyword">WHERE</span> products.vend_id <span class="operator">=</span> vendors.vend_id</span><br><span class="line">      <span class="keyword">AND</span> orderitems.prod_id <span class="operator">=</span> products.prod_id</span><br><span class="line">      <span class="keyword">AND</span> order_num <span class="operator">=</span> <span class="number">20005</span>;</span><br></pre></td></tr></table></figure>

<p>此例子显示编号为<code>20005</code>的订单中的物品。订单物品存储在<code>orderitems</code>表中。每个产品按其产品<code>ID</code>存储，它引用<code>products</code>表中的产品。这些产品通过供应商ID联结到<code>vendors</code>表中相应的供应商，供应商ID存储在每个产品的记录中。这里的<code>FROM</code>子句列出了3个表，而<code>WHERE</code>子句定义了这两个联结条件，而第三个联结条件用来过滤出订单<code>20005</code>中的物品。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> cust_name, cust_contact</span><br><span class="line"><span class="keyword">FROM</span> customer</span><br><span class="line"><span class="keyword">WHERE</span> cust_id <span class="keyword">IN</span> (<span class="keyword">SELECT</span> cust_id</span><br><span class="line">                  <span class="keyword">FROM</span> orders</span><br><span class="line">                  <span class="keyword">WHERE</span> order_num <span class="keyword">IN</span> (<span class="keyword">SELECT</span> order_num</span><br><span class="line">                                      <span class="keyword">FROM</span> orderitems</span><br><span class="line">                                      <span class="keyword">WHERE</span> prod_id <span class="operator">=</span> <span class="string">&#x27;TNT2&#x27;</span>);)</span><br></pre></td></tr></table></figure>

<p>子查询并不总是执行复杂<code>SELECT</code>操作的最有效的方法，下面是使用联结的相同查询：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> cust_name, cust_contact</span><br><span class="line"><span class="keyword">FROM</span> customers, orders, orderitems</span><br><span class="line"><span class="keyword">WHERE</span> customers.cust_id <span class="operator">=</span> orders.cust_id</span><br><span class="line">      <span class="keyword">AND</span> orderitems.order_num <span class="operator">=</span> order.order_num</span><br><span class="line">      <span class="keyword">AND</span> prod_id <span class="operator">=</span> <span class="string">&#x27;TNT2&#x27;</span>;</span><br></pre></td></tr></table></figure>

<h1 id="第16章-创建高级联结"><a href="#第16章-创建高级联结" class="headerlink" title="第16章 创建高级联结"></a>第16章 创建高级联结</h1><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> customers <span class="keyword">AS</span> c, orders <span class="keyword">AS</span> o, orderitems <span class="keyword">AS</span> oi</span><br><span class="line"><span class="keyword">WHERE</span> c.cust_id <span class="operator">=</span> o.cust_id</span><br><span class="line">      <span class="keyword">AND</span> oi.order_num <span class="operator">=</span> o.order_num</span><br><span class="line">      <span class="keyword">AND</span> prod_id <span class="operator">=</span> <span class="string">&#x27;TNT2&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p><code>FROM</code>子句中3个表全都具有别名。<code>customers AS c</code>建立<code>c</code>作为<code>customers</code>的别名，等等。这使得能使用省写的<code>c</code>而不是全名<code>customers</code>。在此例子中，表别名只用于<code>WHERE</code>子句。但是，表别名不仅能用于<code>WHERE</code>子句，它还可以用于<code>SELECT</code>的列表、<code>ORDER BY</code>子句以及语句的其他部分。</p>
<p>表别名只在查询执行中使用。与列别名不一样，表别名不返回到客户机。</p>
<p>下面首先找到生产<code>ID</code>为<code>DTNTR</code>的物品的供应商，然后找出这个供应商生产的其他物品。它使用了子查询，内部的<code>SELECT</code>语句做了一个简单的检索，返回生产<code>ID</code>为<code>DTNTR</code>的物品供应商的<code>vend_id</code>。该<code>ID</code>用于外部查询的<code>WHERE</code>子句中，以便检索出这个供应商生产的所有物品：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># 子查询</span><br><span class="line"><span class="keyword">SELECT</span> prod_id, prod_name</span><br><span class="line"><span class="keyword">FROM</span> products</span><br><span class="line"><span class="keyword">WHERE</span> vend_id <span class="operator">=</span> (<span class="keyword">SELECT</span> vend_id</span><br><span class="line">                 <span class="keyword">FROM</span> products</span><br><span class="line">                 <span class="keyword">WHERE</span> prod_id <span class="operator">=</span> <span class="string">&#x27;DTNTR&#x27;</span>)</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> p1.prod_id, p1.prod_name</span><br><span class="line"><span class="keyword">FROM</span> products <span class="keyword">AS</span> p1, products <span class="keyword">AS</span> p2</span><br><span class="line"><span class="keyword">WHERE</span> p1.vend_id <span class="operator">=</span> p2.vend_id</span><br><span class="line">      <span class="keyword">AND</span> p2.prod_id <span class="operator">=</span> <span class="string">&#x27;DTNTR&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p><code>WHERE</code>（通过匹配<code>p1</code>中的<code>vend_id</code>和<code>p2</code>中的<code>vend_id</code>）首先联结两个表，然后按第二个表中的<code>prod_id</code>过滤数据，返回所需的数据。</p>
<p>自联结通常作为外部语句用来替代从相同表中检索数据时使用的子查询语句。虽然最终的结果是相同的，但有时候处理联结远比处理子查询快得多。</p>
<p>无论何时对表进行联结，应该至少有一个列出现在不止一个表中（被联结的列）。<br>标准的联结（前一章中介绍的内部联结）返回所有数据，甚至相同的列多次出现。自然联结排除多次出现，使每个列只返回一次。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> c.<span class="operator">*</span>, o.order_num, o.order_date, oi.prod_id, oi.quantity, oi.item_price</span><br><span class="line"><span class="keyword">FROM</span> customers <span class="keyword">AS</span> c, orders <span class="keyword">AS</span> o, oderitems <span class="keyword">AS</span> oi</span><br><span class="line"><span class="keyword">WHERE</span> c.cust_id <span class="operator">=</span> o.cust_id</span><br><span class="line">      <span class="keyword">AND</span> oi.order_num <span class="operator">=</span> o.order_num</span><br><span class="line">      <span class="keyword">AND</span> prod_id <span class="operator">=</span> <span class="string">&#x27;FB&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>许多联结将一个表中的行与另一个表中的行相关联。但有时候会需要包含没有关联行的那些行。使用外部联结。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> customers.cust_id, orders.order_num</span><br><span class="line"><span class="keyword">FROM</span> customers <span class="keyword">LEFT</span> <span class="keyword">OUTER</span> <span class="keyword">JOIN</span> orders</span><br><span class="line"><span class="keyword">ON</span> customers.cust_id <span class="operator">=</span> orders.cust_id;</span><br></pre></td></tr></table></figure>

<p>与内部联结关联两个表中的行不同的是，外部联结还包括没有关联行的行。在使用<code>OUTER JOIN</code>语法时，必须使用<code>RIGHT</code>或<code>LEFT</code>关键字指定包括其所有行的表（<code>RIGHT</code>指出的是<code>OUTER JOIN</code>右边的表，而<code>LEFT</code>指出的是<code>OUTER JOIN</code>左边的表）。上面的例子使用<code>LEFT OUTER JOIN</code>从<code>FROM</code>子句的左边表（<code>customers</code>表）中选择所有行。为了从右边的表中选择所有行，应该使用<code>RIGHT OUTER JOIN</code>，如下例所示：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> customer.cust_id, orders.order_num</span><br><span class="line"><span class="keyword">FROM</span> customers <span class="keyword">RIGHT</span> <span class="keyword">OUTER</span> <span class="keyword">JOIN</span> orders</span><br><span class="line"><span class="keyword">ON</span> orders.cust_id <span class="operator">=</span> customers.cust_id;</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> customers.cust_name,</span><br><span class="line">       customers.cust_id,</span><br><span class="line">       <span class="built_in">COUNT</span>(orders.order_num) <span class="keyword">AS</span> num_ord</span><br><span class="line"><span class="keyword">FROM</span> customers <span class="keyword">INNER</span> <span class="keyword">JOIN</span> orders</span><br><span class="line"><span class="keyword">ON</span> customers.cust_id <span class="operator">=</span> orders.cust_id</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> customers.cust_id;</span><br></pre></td></tr></table></figure>

<p>此<code>SELECT</code>语句使用<code>INNER JOIN</code>将<code>customers</code>和<code>orders</code>表互相关联。<code>GROUP BY</code>子句按客户分组数据，因此，函数调用<code>COUNT(orders.order_num)</code>对每个客户的订单计数，将它作为<code>num_ord</code>返回。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> customer.cust_name,</span><br><span class="line">       customers.cust_id,</span><br><span class="line">       <span class="built_in">COUNT</span>(orders.order_num) <span class="keyword">AS</span> num_ord</span><br><span class="line"><span class="keyword">FROM</span> customers <span class="keyword">LEFT</span> <span class="keyword">OUTER</span> <span class="keyword">JOIN</span> orders</span><br><span class="line"><span class="keyword">ON</span> customers.cust_id <span class="operator">=</span> orders.cust_id</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> customers.cust_id</span><br></pre></td></tr></table></figure>

<p>这个例子使用左外部联结来包含所有客户，甚至包含那些没有任何下订单的客户。结果显示也包含了客户Mouse House，它有0个订单。</p>
<h1 id="第17章-组合查询"><a href="#第17章-组合查询" class="headerlink" title="第17章 组合查询"></a>第17章 组合查询</h1><p><code>MySQL</code>也允许执行多个查询（多条<code>SELECT</code>语句），并将结果作为单个查询结果集返回。这些组合查询通常称为并（union）或复合查询（compound query）。<br>有两种基本情况，其中需要使用组合查询：</p>
<ul>
<li>在单个查询中从不同的表返回类似结构的数据；</li>
<li>对单个表执行多个查询，按单个查询返回数据。</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> vend_id, prod_id, prod_price</span><br><span class="line"><span class="keyword">FROM</span> products</span><br><span class="line"><span class="keyword">WHERE</span> prod_price <span class="operator">&lt;=</span> <span class="number">5</span></span><br><span class="line"><span class="keyword">UNION</span></span><br><span class="line"><span class="keyword">SELECT</span> vend_id, prod_id, prod_price</span><br><span class="line"><span class="keyword">FROM</span> products</span><br><span class="line"><span class="keyword">WHERE</span> vend_id <span class="keyword">IN</span> (<span class="number">1001</span>,<span class="number">1002</span>);</span><br></pre></td></tr></table></figure>

<p>第一条SELECT检索价格不高于5的所有物品。第二条SELECT使用IN找出供应商1001和1002生产的所有物品，组合了一下。与下面的查询等价。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> vend_id, prod_id, prod_price</span><br><span class="line"><span class="keyword">FROM</span> products</span><br><span class="line"><span class="keyword">WHERE</span> prod_price <span class="operator">&lt;=</span> <span class="number">5</span></span><br><span class="line"><span class="keyword">OR</span> vend_id <span class="keyword">IN</span> (<span class="number">1001</span>,<span class="number">1002</span>)</span><br></pre></td></tr></table></figure>

<p><code>UNION</code>规则</p>
<ul>
<li><code>UNION</code>必须由两条或两条以上的<code>SELECT</code>语句组成，语句之间用关键字<code>UNION</code>分隔（因此，如果组合4条<code>SELECT</code>语句，将要使用3个<code>UNION</code>关键字）。</li>
<li><code>UNION</code>中的每个查询必须包含相同的列、表达式或聚集函数（不过各个列不需要以相同的次序列出）。</li>
<li>列数据类型必须兼容：类型不必完全相同，但必须是<code>DBMS</code>可以隐含地转换的类型（例如，不同的数值类型或不同的日期类型）。</li>
</ul>
<p>在使用UNION时，重复的行被自动取消。如果想返回所有匹配行，可使用<code>UNION ALL</code>而不是<code>UNION</code>。</p>
<p>在用<code>UNION</code>组合查询时，只能使用一条<code>ORDER BY</code>子句，它必须出现在最后一条<code>SELECT</code>语句之后。将用它来排序所有<code>SELECT</code>语句返回的所有结果，只能有一种排序方式。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> vend_id, prod_id, prod_price</span><br><span class="line"><span class="keyword">FROM</span> products</span><br><span class="line"><span class="keyword">WHERE</span> prod_price <span class="operator">&lt;=</span> <span class="number">5</span></span><br><span class="line"><span class="keyword">UNION</span></span><br><span class="line"><span class="keyword">SELECT</span> vend_id, prod_id, prod_price</span><br><span class="line"><span class="keyword">FROM</span> products</span><br><span class="line"><span class="keyword">WHERE</span> vend_id <span class="keyword">IN</span> (<span class="number">1001</span>,<span class="number">1002</span>)</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> vend_id, prod_id;</span><br></pre></td></tr></table></figure>

<h1 id="第18章-全文本搜索"><a href="#第18章-全文本搜索" class="headerlink" title="第18章 全文本搜索"></a>第18章 全文本搜索</h1><p>两个最常使用的引擎为MyISAM和InnoDB，前者支持全文本搜索，而后者不支持。</p>
<p>一般在创建表时启用全文本搜索。<code>CREATE TABLE</code>语句（第21章中介绍）接受<code>FULLTEXT</code>子句，它给出被索引列的一个逗号分隔的列表。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> productnotes</span><br><span class="line">(</span><br><span class="line">        note_id    <span class="type">int</span>    <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">        prod_id    <span class="type">char</span>(<span class="number">10</span>)    <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">        note_date    datetime    <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">        note_text    text    <span class="keyword">NULL</span>,</span><br><span class="line">        <span class="keyword">PRIMARY</span> KEY(note_id),</span><br><span class="line">        FULLTEXT(note_text)</span><br><span class="line">)ENGINE<span class="operator">=</span>MyISAM;</span><br></pre></td></tr></table></figure>

<p>这里的<code>FULLTEXT</code>索引单个列，如果需要也可以指定多个列。<br>在定义之后，<code>MySQL</code>自动维护该索引。在增加、更新或删除行时，索引随之自动更新</p>
<p><code>Match()</code>指定被搜索的列，<code>Against()</code>指定要使用的搜索表达式。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> note_text</span><br><span class="line"><span class="keyword">FROM</span> productnotes</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">Match</span>(note_text) Against(<span class="string">&#x27;rabit&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p><code>Match(note_text)</code>指示<code>MySQL</code>针对指定的列进行搜索，<code>Against(&#39;rabbit&#39;)</code>指定词<code>rabbit</code>作为搜索文本。由于有两行包含词<code>rabbit</code>，这两个行被返回。<br>除非使用<code>BINARY</code>方式（本章中没有介绍），否则全文本搜索不区分大小写。</p>
<p>全文本搜索的一个重要部分就是对结果排序。具有较高等级的行先返回（因为这些行很可能是你真正想要的行）。<br>如果指定多个搜索项，则包含多数匹配词的那些行将具有比包含较少词（或仅有一个匹配）的那些行高的等级值。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> note_text</span><br><span class="line"><span class="keyword">FROM</span> productnotes</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">Match</span>(note_text) Against(<span class="string">&#x27;anvils&#x27;</span> <span class="keyword">WITH</span> QUERY EXPANSION);</span><br></pre></td></tr></table></figure>

<p>查询扩展，可能与你的搜索有关的所有其他行，即使它们不包含词anvils。</p>
<p>布尔方式，可以提供关于如下内容的细节：</p>
<ul>
<li>要匹配的词；</li>
<li>要排斥的词（如果某行包含这个词，则不返回该行，即使它包含其他指定的词也是如此）；</li>
<li>排列提示（指定某些词比其他词更重要，更重要的词等级更高）;</li>
<li>表达式分组；</li>
<li>另外一些内容。</li>
</ul>
<p>为了匹配包含<code>heavy</code>但不包含任意以<code>rope</code>开始的词的行，可使用以下查询：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> note_text</span><br><span class="line"><span class="keyword">FROM</span> productnotes</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">Match</span>(note_text) Against(<span class="string">&#x27;heavy -rope*&#x27;</span> <span class="keyword">IN</span> <span class="type">BOOLEAN</span> MODE);</span><br></pre></td></tr></table></figure>

<p><code>-</code>排除一个词，而<code>*</code>是截断操作符（可想象为用于词尾的一个通配符）。</p>
<p>支持的所有布尔操作符如下：</p>
<table>
<thead>
<tr>
<th align="center">函数</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">+</td>
<td align="center">包含，词必须存在</td>
</tr>
<tr>
<td align="center">-</td>
<td align="center">排除，词必须不出现</td>
</tr>
<tr>
<td align="center">&gt;</td>
<td align="center">包含，而且增加等级</td>
</tr>
<tr>
<td align="center">()</td>
<td align="center">把词组成子表达式（允许这些子表达式作为一个组被包含、排除、排列等）</td>
</tr>
<tr>
<td align="center">~</td>
<td align="center">取消一个词的排序值</td>
</tr>
<tr>
<td align="center">*</td>
<td align="center">词尾的通配符</td>
</tr>
<tr>
<td align="center">“”</td>
<td align="center">定义一个短语（与单个词的列表不一样，它匹配整个短语以便包含或排除这个短语）</td>
</tr>
</tbody></table>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> note_text</span><br><span class="line"><span class="keyword">FROM</span> productnotes</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">Match</span>(note_text) Against(<span class="string">&#x27;+rabbit +bait&#x27;</span> <span class="keyword">IN</span> <span class="type">BOOLEAN</span> MODE);</span><br></pre></td></tr></table></figure>

<p>这个搜索匹配包含词<code>rabbit</code>和<code>bait</code>的行。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> note_text</span><br><span class="line"><span class="keyword">FROM</span> productnotes</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">Match</span>(note_text) Against(<span class="string">&#x27;rabbit bait&#x27;</span> <span class="keyword">IN</span> <span class="type">BOOLEAN</span> MODE);</span><br></pre></td></tr></table></figure>

<p>没有指定操作符，这个搜索匹配包含<code>rabbit</code>和<code>bait</code>中的至少一个词的行。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> note_text</span><br><span class="line"><span class="keyword">FROM</span> productnotes</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">Match</span>(note_text) Against(<span class="string">&#x27;&quot;rabbit bait&quot;&#x27;</span> <span class="keyword">IN</span> <span class="type">BOOLEAN</span> MODE);</span><br></pre></td></tr></table></figure>

<p>这个搜索匹配短语<code>rabbit bait</code>而不是匹配两个词<code>rabbit</code>和<code>bait</code>。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> note_text</span><br><span class="line"><span class="keyword">FROM</span> productnotes</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">Match</span>(note_text) Against(<span class="string">&#x27;&gt;rabbit &lt;carrot&#x27;</span> <span class="keyword">IN</span> <span class="type">BOOLEAN</span> MODE);</span><br></pre></td></tr></table></figure>

<p>匹配<code>rabbit</code>和<code>carrot</code>，增加前者的等级，降低后者的等级。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> note_text</span><br><span class="line"><span class="keyword">FROM</span> productnotes</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">Match</span>(note_text) Against(<span class="string">&#x27;+safe +(&lt;combination)&#x27;</span> <span class="keyword">IN</span> <span class="type">BOOLEAN</span> MODE);</span><br></pre></td></tr></table></figure>

<p>这个搜索匹配词<code>safe</code>和<code>combination</code>，降低后者的等级。</p>
<p>在布尔方式中，不按等级值降序排序返回的行。</p>
<p>全文本搜索的某些重要的说明:</p>
<ul>
<li>在索引全文本数据时，短词被忽略且从索引中排除。短词定义为那些具有3个或3个以下字符的词（如果需要，这个数目可以更改）。</li>
<li><code>MySQL</code>带有一个内建的非用词（<code>stopword</code>）列表，这些词在索引全文本数据时总是被忽略。如果需要，可以覆盖这个列表（请参阅<code>MySQL</code>文档以了解如何完成此工作）。</li>
<li>许多词出现的频率很高，搜索它们没有用处（返回太多的结果）。因此，<code>MySQL</code>规定了一条50%规则，如果一个词出现在50%以上的行中，则将它作为一个非用词忽略。50%规则不用于<code>IN BOOLEAN MODE</code>。</li>
<li>如果表中的行数少于3行，则全文本搜索不返回结果（因为每个词或者不出现，或者至少出现在50%的行中）。</li>
<li>忽略词中的单引号。例如，don’t索引为dont。</li>
<li>不具有词分隔符（包括日语和汉语）的语言不能恰当地返回全文本搜索结果。</li>
<li>如前所述，仅在<code>MyISAM</code>数据库引擎中支持全文本搜索。</li>
</ul>
<h1 id="第19章-插入数据"><a href="#第19章-插入数据" class="headerlink" title="第19章 插入数据"></a>第19章 插入数据</h1><p>插入可以用几种方式使用：</p>
<ul>
<li>插入完整的行；</li>
<li>插入行的一部分；</li>
<li>插入多行；</li>
<li>插入某些查询的结果。</li>
</ul>
<p>INSERT语句一般不会产生输出。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> customers(</span><br><span class="line">        cust_name,</span><br><span class="line">        cust_city,</span><br><span class="line">        cust_state,</span><br><span class="line">        cust_zip,</span><br><span class="line">        cust_country,</span><br><span class="line">        cust_contact,</span><br><span class="line">        cust_email)</span><br><span class="line"><span class="keyword">VALUES</span>(</span><br><span class="line">        <span class="string">&#x27;Pep E. LaPew&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;100 Main Street&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;Los Angeles&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;CA&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;90046&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;USA&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;NULL&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;NULL&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>如果表的定义允许，则可以在<code>INSERT</code>操作中省略某些列。省略的列必须满足以下某个条件:</p>
<ul>
<li>该列定义为允许<code>NULL</code>值（无值或空值）。</li>
<li>在表定义中给出默认值。这表示如果不给出值，将使用默认值。</li>
</ul>
<p>只要每条<code>INSERT</code>语句中的列名（和次序）相同，可以如下组合各语句:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> customers(</span><br><span class="line">        cust_name,</span><br><span class="line">        cust_address,</span><br><span class="line">        cust_city,</span><br><span class="line">        cust_state,</span><br><span class="line">        cust_zip,</span><br><span class="line">        cust_country)</span><br><span class="line"><span class="keyword">VALUES</span>(</span><br><span class="line">        <span class="string">&#x27;Pep E. LaPew&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;100 Main Street&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;Los Angeles&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;CA&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;90046&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;USA&#x27;</span></span><br><span class="line">      ),</span><br><span class="line">      (</span><br><span class="line">        <span class="string">&#x27;M. Martian&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;42 Galaxy Way&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;New York&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;NY&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;11213&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;USA&#x27;</span></span><br><span class="line">      );</span><br></pre></td></tr></table></figure>

<p>下面的例子使用<code>INSERT SELECT</code>从<code>custnew</code>中将所有数据导入<code>customers</code>，也可以省略<code>cust_id</code>，让MySQL生成新值:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> customers(</span><br><span class="line">        cust_id,</span><br><span class="line">        cust_email,</span><br><span class="line">        cust_name,</span><br><span class="line">        cust_address,</span><br><span class="line">        cust_city,</span><br><span class="line">        cust_state,</span><br><span class="line">        cust_zip,</span><br><span class="line">        cust_country)</span><br><span class="line"><span class="keyword">SELECT</span>  cust_id,</span><br><span class="line">        cust_email,</span><br><span class="line">        cust_name,</span><br><span class="line">        cust_address,</span><br><span class="line">        cust_city,</span><br><span class="line">        cust_state,</span><br><span class="line">        cust_zip,</span><br><span class="line">        cust_country</span><br><span class="line"><span class="keyword">FROM</span> custnew;</span><br></pre></td></tr></table></figure>

<h1 id="第20章-更新和删除数据"><a href="#第20章-更新和删除数据" class="headerlink" title="第20章 更新和删除数据"></a>第20章 更新和删除数据</h1><p>可采用两种方式使用<code>UPDATE</code>：</p>
<ul>
<li>更新表中特定行；</li>
<li>更新表中所有行。</li>
</ul>
<p>基本的<code>UPDATE</code>语句由3部分组成，分别是：</p>
<ul>
<li>要更新的表；</li>
<li>列名和它们的新值；</li>
<li>确定要更新行的过滤条件。</li>
</ul>
<p><code>WHERE</code>子句不要省略，否则会更新表中所有行。</p>
<p>客户10005现在有了电子邮件地址，因此他的记录需要更新：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">UPDATE customers</span><br><span class="line"><span class="keyword">SET</span> cust_email <span class="operator">=</span> <span class="string">&#x27;elmer@fudd.com&#x27;</span></span><br><span class="line"><span class="keyword">WHERE</span> cust_id <span class="operator">=</span> <span class="number">10005</span>;</span><br></pre></td></tr></table></figure>

<p><code>UPDATE</code>语句总是以要更新的表的名字开始。在此例子中，要更新的表的名字为<code>customers</code>。<code>SET</code>命令用来将新值赋给被更新的列。如这里所示，<code>SET</code>子句设置<code>cust_email</code>列为指定的值。<code>UPDATE</code>语句以<code>WHERE</code>子句结束，它告诉<code>MySQL</code>更新哪一行。没有<code>WHERE</code>子句，<code>MySQL</code>将会用这个电子邮件地址更新<code>customers</code>表中所有行，这不是我们所希望的。</p>
<p>更新客户10005的<code>cust_name</code>和<code>cust_email</code>列：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">UPDATE customers</span><br><span class="line"><span class="keyword">SET</span> cust_name <span class="operator">=</span> <span class="string">&#x27;The Fudds&#x27;</span>,</span><br><span class="line">    cust_email <span class="operator">=</span> <span class="string">&#x27;elmer@fudd.com&#x27;</span></span><br><span class="line"><span class="keyword">WHERE</span> cust_id <span class="operator">=</span> <span class="number">10005</span>;</span><br></pre></td></tr></table></figure>

<p><code>IGNORE</code>关键字：如果用<code>UPDATE</code>语句更新多行，并且在更新这些行中的一行或多行时出现一个错误，则整个<code>UPDATE</code>操作被取消（错误发生前更新的所有行被恢复到它们原来的值）。即使是发生错误，也继续进行更新，可使用<code>IGNORE</code>关键字，如下所示：<code>UPDATE IGNORE customers…</code></p>
<p>为了删除某个列的值，可设置它为<code>NULL</code>（假如表定义允许<code>NULL</code>值）。如下进行：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">UPDATE customers</span><br><span class="line"><span class="keyword">SET</span> cust_email <span class="operator">=</span> <span class="keyword">NULL</span></span><br><span class="line"><span class="keyword">WHERE</span> cust_id <span class="operator">=</span> <span class="number">1005</span>;</span><br></pre></td></tr></table></figure>

<p><code>DELETE</code>可以从表中删除数据，有两种方式使用：</p>
<ul>
<li>从表中删除特定的行；</li>
<li>从表中删除所有行。</li>
</ul>
<p>下面的语句从<code>customers</code>表中删除一行：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> customers</span><br><span class="line"><span class="keyword">WHERE</span> cust_id <span class="operator">=</span> <span class="number">10006</span></span><br></pre></td></tr></table></figure>

<p>在这个例子中，只删除客户10006。如果省略<code>WHERE</code>子句，它将删除表中每个客户。</p>
<p><code>DELETE</code>不需要列名或通配符。<code>DELETE</code>删除整行而不是删除列。为了删除指定的列，请使用<code>UPDATE</code>语句。</p>
<p>更快的删除 如果想从表中删除所有行，不要使用<code>DELETE</code>。可使用<code>TRUNCATE TABLE</code>语句，它完成相同的工作，但速度更快（<code>TRUNCATE</code>实际是删除原来的表并重新创建一个表，而不是逐行删除表中的数据）</p>
<p>使用<code>UPDATE</code>或<code>DELETE</code>时所遵循的习惯：</p>
<ul>
<li>除非确实打算更新和删除每一行，否则绝对不要使用不带<code>WHERE</code>子句的<code>UPDATE</code>或<code>DELETE</code>语句。</li>
<li>保证每个表都有主键（如果忘记这个内容，请参阅第15章），尽可能像<code>WHERE</code>子句那样使用它（可以指定各主键、多个值或值的范围）。</li>
<li>在对<code>UPDATE</code>或<code>DELETE</code>语句使用<code>WHERE</code>子句前，应该先用<code>SELECT</code>进行测试，保证它过滤的是正确的记录，以防编写的<code>WHERE</code>子句不正确。</li>
<li>使用强制实施引用完整性的数据库（关于这个内容，请参阅第15章），这样<code>MySQL</code>将不允许删除具有与其他表相关联的数据的行。</li>
</ul>
<h1 id="第21章-创建和操纵表"><a href="#第21章-创建和操纵表" class="headerlink" title="第21章 创建和操纵表"></a>第21章 创建和操纵表</h1><p><code>CREATE TABLE</code>创建表，必须给出下列信息：</p>
<ul>
<li>新表的名字，在关键字<code>CREATE TABLE</code>之后给出；</li>
<li>表列的名字和定义，用逗号分隔。</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> productnotes</span><br><span class="line">(</span><br><span class="line">        note_id    <span class="type">int</span>    <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">        prod_id    <span class="type">char</span>(<span class="number">10</span>)    <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">        note_date    datetime    <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">        note_text    text    <span class="keyword">NULL</span>,</span><br><span class="line">        <span class="keyword">PRIMARY</span> KEY(note_id),</span><br><span class="line">)ENGINE<span class="operator">=</span>InnoDB;</span><br></pre></td></tr></table></figure>

<p>如果你仅想在一个表不存在时创建它，应该在表名后给出<code>IF NOT EXISTS</code>。</p>
<p>为创建由多个列组成的主键，应该以逗号分隔的列表给出各列名：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> orderitems</span><br><span class="line">(</span><br><span class="line">        order_num    <span class="type">int</span>    <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">        order_item    <span class="type">int</span>    <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">        prod_id    <span class="type">char</span>(<span class="number">10</span>)    <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">        quantity    <span class="type">int</span>    <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">        item_price    <span class="type">decimal</span>(<span class="number">8</span>,<span class="number">2</span>)    <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">        <span class="keyword">PRIMARY</span> KEY (order_num, order_item)</span><br><span class="line">)ENGINE<span class="operator">=</span>InnoDB;</span><br></pre></td></tr></table></figure>

<p>如果主键使用单个列，则它的值必须唯一。如果使用多个列，则这些列的组合值必须唯一，主键中只能使用不允许<code>NULL</code>值的列。</p>
<p>每个表只允许一个<code>AUTO_INCREMENT</code>列，而且它必须被索引（如，通过使它成为主键）。<br><code>SELECT_last_insert_id()</code>此语句返回最后一个<code>AUTO_INCREMENT</code>值，然后可以将它用于后续的MySQL语句。</p>
<p>默认值用<code>CREATE TABLE</code>语句的列定义中的<code>DEFAULT</code>关键字指定，下面给该列的描述添加文本<code>DEFAULT 1</code>指示<code>MySQL</code>，在未给出数量的情况下使用数量1：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> orderitems</span><br><span class="line">(</span><br><span class="line">        order_num    <span class="type">int</span>    <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">        order_item    <span class="type">int</span>    <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">        prod_id    <span class="type">char</span>(<span class="number">10</span>)    <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">        quantity    <span class="type">int</span>    <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="number">1</span>,</span><br><span class="line">        item_price    <span class="type">decimal</span>(<span class="number">8</span>,<span class="number">2</span>)    <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">        <span class="keyword">PRIMARY</span> KEY (order_num, order_item)</span><br><span class="line">)ENGINE<span class="operator">=</span>InnoDB;</span><br></pre></td></tr></table></figure>

<p>引擎：</p>
<ul>
<li><code>InnoDB</code>是一个可靠的事务处理引擎（参见第26章），它不支持全文本搜索；</li>
<li><code>MEMORY</code>在功能等同于<code>MyISAM</code>，但由于数据存储在内存（不是磁盘）中，速度很快（特别适合于临时表）；</li>
<li><code>MyISAM</code>是一个性能极高的引擎，它支持全文本搜索（参见第18章），但不支持事务处理。</li>
</ul>
<p>外键（用于强制实施引用完整性，如第1章所述）不能跨引擎，即使用一个引擎的表不能引用具有使用不同引擎的表的外键。</p>
<p>当表中存储数据以后，该表就不应该再被更新。<br>为了使用<code>ALTER TABLE</code>更改表结构，必须给出下面的信息：</p>
<ul>
<li>在<code>ALTER TABLE</code>之后给出要更改的表名（该表必须存在，否则将出错）；</li>
<li>所做更改的列表。</li>
</ul>
<p>下面的例子给表添加一个列：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> vendors</span><br><span class="line"><span class="keyword">ADD</span> vend_phone <span class="type">CHAR</span>(<span class="number">20</span>);</span><br></pre></td></tr></table></figure>

<p>这条语句给<code>vendors</code>表增加一个名为<code>vend_phone</code>的列，必须明确其数据类型。<br>删除刚刚添加的列，可以这样做：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> vendors</span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">COLUMN</span> vend_phone</span><br></pre></td></tr></table></figure>

<p><code>ALTER TABLE</code>的一种常见用途是定义外键。</p>
<p>复杂的表结构更改一般需要手动删除过程，它涉及以下步骤：</p>
<ol>
<li>用新的列布局创建一个新表；</li>
<li>使用INSERT SELECT语句（关于这条语句的详细介绍，请参阅第19章）从旧表复制数据到新表。如果有必要，可使用转换函数和计算字段；</li>
<li>检验包含所需数据的新表；</li>
<li>重命名旧表（如果确定，可以删除它）；</li>
<li>用旧表原来的名字重命名新表；</li>
<li>根据需要，重新创建触发器、存储过程、索引和外键。</li>
</ol>
<p>删除表（删除整个表而不是其内容）非常简单，使用<code>DROP TABLE</code>语句即可：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> customers2;</span><br></pre></td></tr></table></figure>

<p>使用<code>RENAME TABLE</code>语句可以重命名一个表：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">RENAME <span class="keyword">TABLE</span> customers2 <span class="keyword">TO</span> customers;</span><br></pre></td></tr></table></figure>

<p>可以使用下面的语句对多个表重命名：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">RENAME <span class="keyword">TABLE</span> backup_customers <span class="keyword">TO</span> customers,</span><br><span class="line">             backup_vendors <span class="keyword">TO</span> vendors,</span><br><span class="line">             backup_products <span class="keyword">TO</span> products;</span><br></pre></td></tr></table></figure>

<h1 id="第22章-使用视图"><a href="#第22章-使用视图" class="headerlink" title="第22章 使用视图"></a>第22章 使用视图</h1><p>视图是虚拟的表。与包含数据的表不一样，视图只包含使用时动态检索数据的查询。</p>
<p>视图的一些常见应用:</p>
<ul>
<li>重用SQL语句。</li>
<li>简化复杂的SQL操作。在编写查询后，可以方便地重用它而不必知道它的基本查询细节。</li>
<li>使用表的组成部分而不是整个表。</li>
<li>保护数据。可以给用户授予表的特定部分的访问权限而不是整个表的访问权限。</li>
<li>更改数据格式和表示。视图可返回与底层表的表示和格式不同的数据。</li>
</ul>
<p>因为视图不包含数据，所以每次使用视图时，都必须处理查询执行时所需的任一个检索。如果你用多个联结和过滤创建了复杂的视图或者嵌套了视图，可能会发现性能下降得很厉害。</p>
<p>视图创建和使用的一些最常见的规则和限制:</p>
<ul>
<li>与表一样，视图必须唯一命名（不能给视图取与别的视图或表相同的名字）。</li>
<li>对于可以创建的视图数目没有限制。</li>
<li>为了创建视图，必须具有足够的访问权限。这些限制通常由数据库管理人员授予。</li>
<li>视图可以嵌套，即可以利用从其他视图中检索数据的查询来构造一个视图。</li>
<li><code>ORDER BY</code>可以用在视图中，但如果从该视图检索数据的<code>SELECT</code>语句中也含有<code>ORDER BY</code>，那么该视图中的<code>ORDER BY</code>将被覆盖。</li>
<li>视图不能索引，也不能有关联的触发器或默认值。</li>
<li>视图可以和表一起使用。例如，编写一条联结表和视图的<code>SELECT</code>语句</li>
</ul>
<p>视图的创建:</p>
<ul>
<li>视图用<code>CREATE VIEW</code>语句来创建。</li>
<li>使用<code>SHOW CREATE VIEW viewname;</code>来查看创建视图的语句。</li>
<li>用DROP删除视图，其语法为<code>DROP VIEW viewname;</code>。</li>
<li>更新视图时，可以先用<code>DROP</code>再用<code>CREATE</code>，也可以直接用<code>CREATE OR REPLACE VIEW</code>。如果要更新的视图不存在，则第2条更新语句会创建一个视图；如果要更新的视图存在，则第2条更新语句会替换原有视图。</li>
</ul>
<p>视图的最常见的应用之一是隐藏复杂的SQL，这通常都会涉及联结。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> productcustomers <span class="keyword">AS</span></span><br><span class="line"><span class="keyword">SELECT</span> cust_name, cust_contact, prod_id</span><br><span class="line"><span class="keyword">FROM</span> customers, orders, orderitems</span><br><span class="line"><span class="keyword">WHERE</span> customers.cust_id <span class="operator">=</span> orders.cust_id</span><br><span class="line"><span class="keyword">AND</span> orderitems.order_num <span class="operator">=</span> orders.order_num;</span><br></pre></td></tr></table></figure>

<p>这条语句创建一个名为<code>productcustomers</code>的视图，它联结三个表，以返回已订购了任意产品的所有客户的列表。如果执行<code>SELECT * FROM productcustomers</code>，将列出订购了任意产品的客户。</p>
<p>为检索订购了产品TNT2的客户，可如下进行：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> cust_name, cust_contact</span><br><span class="line"><span class="keyword">FROM</span> productcustomers</span><br><span class="line"><span class="keyword">WHERE</span> prod_id <span class="operator">=</span> <span class="string">&#x27;TNT2&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>这条语句通过<code>WHERE</code>子句从视图中检索特定数据。在<code>MySQL</code>处理此查询时，它将指定的<code>WHERE</code>子句添加到视图查询中的已有<code>WHERE</code>子句中，以便正确过滤数据。</p>
<p>假如经常需要下面这个格式的结果。不必在每次需要时执行联结，创建一个视图，每次需要时使用它即可。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> vendorlocations <span class="keyword">AS</span></span><br><span class="line"><span class="keyword">SELECT</span> Concat(RTrim(vend_name),<span class="string">&#x27;(&#x27;</span>,RTrim(vend_country),<span class="string">&#x27;)&#x27;</span>) <span class="keyword">AS</span> vend_title</span><br><span class="line"><span class="keyword">FROM</span> vendors</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> vend_name;</span><br></pre></td></tr></table></figure>

<p>这条语句使用与以前的<code>SELECT</code>语句相同的查询创建视图</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> vendorlocatinos</span><br></pre></td></tr></table></figure>

<p>视图对于应用普通的<code>WHERE</code>子句也很有用。例如，可以定义<code>customeremaillist</code>视图，它过滤没有电子邮件地址的客户。为此目的，可使用下面的语句：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> customeremaillist <span class="keyword">AS</span></span><br><span class="line"><span class="keyword">SELECT</span> cust_id, cust_name, cust_email</span><br><span class="line"><span class="keyword">FROM</span> customers</span><br><span class="line"><span class="keyword">WHERE</span> cust_email <span class="keyword">IS</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span></span><br></pre></td></tr></table></figure>

<p>可以像使用其他表一样使用视图<code>customeremaillist</code>：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> customeremaillist;</span><br></pre></td></tr></table></figure>

<p>如果从视图检索数据时使用了一条<code>WHERE</code>子句，则两组子句（一组在视图中，另一组是传递给视图的）将自动组合。</p>
<p>视图对于简化计算字段的使用特别有用。下面是第10章中介绍的一条<code>SELECT</code>语句。它检索某个特定订单中的物品，计算每种物品的总价格：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> prod_id,</span><br><span class="line">       quantity,</span><br><span class="line">       item_price,</span><br><span class="line">       quantity<span class="operator">*</span>item_price <span class="keyword">AS</span> expanded_price</span><br><span class="line"><span class="keyword">FROM</span> orderitems</span><br><span class="line"><span class="keyword">WHERE</span> oreder_num <span class="operator">=</span> <span class="number">20005</span>;</span><br></pre></td></tr></table></figure>

<p>可转换为一个视图：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> orderitemsexpanded <span class="keyword">AS</span></span><br><span class="line"><span class="keyword">SELECT</span> prod_id,</span><br><span class="line">       quantity,</span><br><span class="line">       item_price,</span><br><span class="line">       quantity<span class="operator">*</span>item_price <span class="keyword">AS</span> expanded_price</span><br><span class="line"><span class="keyword">FROM</span> orderitems</span><br></pre></td></tr></table></figure>

<p>为检索订单20005的详细内容（上面的输出），如下进行：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> orderitemsexpanded</span><br><span class="line"><span class="keyword">WHERE</span> order_num <span class="operator">=</span> <span class="number">20005</span>;</span><br></pre></td></tr></table></figure>

<p>一般，应该将视图用于检索（<code>SELECT</code>语句）而不用于更新（<code>INSERT</code>、<code>UPDATE</code>和<code>DELETE</code>)。</p>
<p>视图提供了一种<code>MySQL</code>的<code>SELECT</code>语句层次的封装，可用来简化数据处理以及重新格式化基础数据或保护基础数据。</p>
<h1 id="第23章-使用存储过程"><a href="#第23章-使用存储过程" class="headerlink" title="第23章 使用存储过程"></a>第23章 使用存储过程</h1><p>存储过程简单来说，就是为以后的使用而保存的一条或多条<code>MySQL</code>语句的集合。可将其视为批文件，虽然它们的作用不仅限于批处理。</p>
<p>存储过程优点：</p>
<ul>
<li>通过把处理封装在容易使用的单元中，简化复杂的操作（正如前面例子所述）。</li>
<li>由于不要求反复建立一系列处理步骤，这保证了数据的完整性。如果所有开发人员和应用程序都使用同一（试验和测试）存储过程，则所使用的代码都是相同的。这一点的延伸就是防止错误。需要执行的步骤越多，出错的可能性就越大。防止错误保证了数据的一致性。</li>
<li>简化对变动的管理。如果表名、列名或业务逻辑（或别的内容）有变化，只需要更改存储过程的代码。使用它的人员甚至不需要知道这些变化。这一点的延伸就是安全性。通过存储过程限制对基础数据的访问减少了数据讹误（无意识的或别的原因所导致的数据讹误）的机会。</li>
<li>提高性能。因为使用存储过程比使用单独的SQL语句要快。</li>
<li>存在一些只能用在单个请求中的<code>MySQL</code>元素和特性，存储过程可以使用它们来编写功能更强更灵活的代码（在下一章的例子中可以看到。）换句话说，使用存储过程有3个主要的好处，即简单、安全、高性能。显然，它们都很重要。</li>
</ul>
<p>不过，在将<code>SQL</code>代码转换为存储过程前，也必须知道它的一些缺陷：</p>
<ul>
<li>一般来说，存储过程的编写比基本SQL语句复杂，编写存储过程需要更高的技能，更丰富的经验。</li>
<li>你可能没有创建存储过程的安全访问权限。许多数据库管理员限制存储过程的创建权限，允许用户使用存储过程，但不允许他们创建存储过程。</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CALL</span> productpricing(</span><br><span class="line">        <span class="variable">@pricelow</span>,</span><br><span class="line">        <span class="variable">@pricehigh</span>,</span><br><span class="line">        <span class="variable">@priceaverage</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>上面执行名为<code>productpricing</code>的存储过程，它计算并返回产品的最低、最高和平均价格。</p>
<p>一个返回产品平均价格的存储过程。以下是其代码：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> productpricing()</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    <span class="keyword">SELECT</span> <span class="built_in">Avg</span>(pro_price) <span class="keyword">AS</span> priceaverage</span><br><span class="line">    <span class="keyword">FROM</span> products;</span><br><span class="line"><span class="keyword">END</span>;</span><br></pre></td></tr></table></figure>

<p>此存储过程名为<code>productpricing</code>，用<code>CREATE PROCEDURE productpricing()</code>语句定义。如果存储过程接受参数，它们将在<code>()</code>中列举出来。此存储过程没有参数，但后跟的<code>()</code>仍然需要。<code>BEGIN</code>和<code>END</code>语句用来限定存储过程体，过程体本身仅是一个简单的<code>SELECT</code>语句（使用第12章介绍的<code>Avg()</code>函数）。</p>
<p>如果用的是命令行，需要改分隔符。我感觉不可能在命令行里写这个。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CALL</span> productpricing();</span><br></pre></td></tr></table></figure>

<p><code>CALL productpricing();</code>执行刚创建的存储过程并显示返回的结果。</p>
<p>存储过程在创建之后，被保存在服务器上以供使用，直至被删除。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DROP</span> PROCEDUREC productpricing;</span><br></pre></td></tr></table></figure>

<p>这条语句删除刚创建的存储过程。当过程存在想删除它时（如果过程不存在也不产生错误）可使用<code>DROP PROCEDURE IF EXISTS</code>。</p>
<p><code>productpricing</code>只是一个简单的存储过程，它简单地显示<code>SELECT</code>语句的结果。一般，存储过程并不显示结果，而是把结果返回给你指定的变量。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> productpricing(</span><br><span class="line">    <span class="keyword">OUT</span> pl <span class="type">DECIMAL</span>(<span class="number">8</span>,<span class="number">2</span>),</span><br><span class="line">    <span class="keyword">OUT</span> ph <span class="type">DECIMAL</span>(<span class="number">8</span>,<span class="number">2</span>),</span><br><span class="line">    <span class="keyword">OUT</span> pa <span class="type">DECIMAL</span>(<span class="number">8</span>,<span class="number">2</span>)</span><br><span class="line">)</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    <span class="keyword">SELECT</span> <span class="built_in">Min</span>(prod_price)</span><br><span class="line">    <span class="keyword">INTO</span> pl</span><br><span class="line">    <span class="keyword">FROM</span> products;</span><br><span class="line">    <span class="keyword">SELECT</span> <span class="built_in">Max</span>(prod_price)</span><br><span class="line">    <span class="keyword">INTO</span> ph</span><br><span class="line">    <span class="keyword">FROM</span> products;</span><br><span class="line">    <span class="keyword">SELECT</span> <span class="built_in">Avg</span>(prod_price)</span><br><span class="line">    <span class="keyword">INTO</span> pa</span><br><span class="line">    <span class="keyword">FROM</span> products;</span><br><span class="line"><span class="keyword">END</span>;</span><br></pre></td></tr></table></figure>

<p>此存储过程接受3个参数：<code>pl</code>存储产品最低价格，<code>ph</code>存储产品最高价格，<code>pa</code>存储产品平均价格。每个参数必须具有指定的类型，这里使用十进制值。关键字<code>OUT</code>指出相应的参数用来从存储过程传出一个值（返回给调用者）。<br><code>MySQL</code>支持<code>IN</code>（传递给存储过程）、<code>OUT</code>（从存储过程传出，如这里所用）和<code>INOUT</code>（对存储过程传入和传出）类型的参数。存储过程的代码位于<code>BEGIN</code>和<code>END</code>语句内，如前所见，它们是一系列<code>SELECT</code>语句，用来检索值，然后保存到相应的变量（通过指定<code>INTO</code>关键字）。</p>
<p>存储过程的参数允许的数据类型与表中使用的数据类型相同。</p>
<p>为调用此修改过的存储过程，必须指定3个变量名，如下所示：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CALL</span> productpricing(</span><br><span class="line">    <span class="variable">@pricelow</span>,</span><br><span class="line">    <span class="variable">@pricehigh</span>,</span><br><span class="line">    <span class="variable">@priceaverage</span>,</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>所有<code>MySQL</code>变量都必须以<code>@</code>开始</p>
<p>在调用时，这条语句并不显示任何数据，为了显示检索出的产品平均价格，可如下进行：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="variable">@priceaverage</span></span><br></pre></td></tr></table></figure>

<p>为了获得3个值，可使用以下语句：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="variable">@pricehigh</span>, <span class="variable">@pricelow</span>, <span class="variable">@priceaverage</span>;</span><br></pre></td></tr></table></figure>

<p><code>ordertotal</code>接受订单号并返回该订单的合计：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> ordertotal(</span><br><span class="line">    <span class="keyword">IN</span> onumber <span class="type">INT</span>,</span><br><span class="line">    <span class="keyword">OUT</span> ototal <span class="type">DECIMAL</span>(<span class="number">8</span>,<span class="number">2</span>)</span><br><span class="line">)</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    <span class="keyword">SELECT</span> <span class="built_in">Sum</span>(item_price<span class="operator">*</span>quantity)</span><br><span class="line">    <span class="keyword">FROM</span> orderitems</span><br><span class="line">    <span class="keyword">WHERE</span> order_num <span class="operator">=</span> onumber</span><br><span class="line">    <span class="keyword">INTO</span> ototal;</span><br><span class="line"><span class="keyword">END</span>;</span><br></pre></td></tr></table></figure>

<p><code>onumber</code>定义为<code>IN</code>，因为订单号被传入存储过程。<code>ototal</code>定义为<code>OUT</code>，因为要从存储过程返回合计。<br><code>SELECT</code>语句使用这两个参数，<code>WHERE</code>子句使用<code>onumber</code>选择正确的行，<code>INTO</code>使用<code>ototal</code>存储计算出来的合计。为调用这个新存储过程，可使用以下语句：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CALL</span> ordertotal(<span class="number">20005</span>, <span class="variable">@total</span>);</span><br></pre></td></tr></table></figure>

<p>必须给<code>ordertotal</code>传递两个参数；第一个参数为订单号，第二个参数为包含计算出来的合计的变量名。</p>
<p>为了显示此合计，可如下进行：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="variable">@total</span></span><br></pre></td></tr></table></figure>

<p>为了得到另一个订单的合计显示，需要再次调用存储过程，然后重新显示变量：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CALL</span> ordertotal(<span class="number">20009</span>, <span class="variable">@total</span>)</span><br></pre></td></tr></table></figure>

<p>有如下需求：</p>
<ul>
<li>获得合计（与以前一样）；</li>
<li>把营业税有条件地添加到合计；</li>
<li>返回合计（带或不带税）。</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- Name: ordertotal</span></span><br><span class="line"><span class="comment">-- Parameters: onumber = order number</span></span><br><span class="line"><span class="comment">--             taxable = 0 if not taxable, 1 if taxable</span></span><br><span class="line"><span class="comment">--             ototal  = order total variable</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> ordertotal(</span><br><span class="line">    <span class="keyword">IN</span> onumber <span class="type">INT</span>,</span><br><span class="line">    <span class="keyword">IN</span> taxable <span class="type">BOOLEAN</span>,</span><br><span class="line">    <span class="keyword">OUT</span> ototal <span class="type">DECIMAL</span>(<span class="number">8</span>,<span class="number">2</span>)</span><br><span class="line">)COMMENT <span class="string">&#x27;Obtain order total, optionally adding tax&#x27;</span></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">--Declare variable for total</span></span><br><span class="line">    <span class="keyword">DECLARE</span> total <span class="type">DECIMAL</span>(<span class="number">8</span>,<span class="number">2</span>)</span><br><span class="line">    <span class="comment">--DECLARE taxrate INT DEFAULT 6;</span></span><br><span class="line">    <span class="keyword">DECLARE</span> taxrate <span class="type">INT</span> <span class="keyword">DEFAULT</span> <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">--Get the order total</span></span><br><span class="line">    <span class="keyword">SELECT</span> <span class="built_in">Sum</span>(item_price<span class="operator">*</span>quantity)</span><br><span class="line">    <span class="keyword">FROM</span> orderitems</span><br><span class="line">    <span class="keyword">WHERE</span> order_num <span class="operator">=</span> onumber</span><br><span class="line">    <span class="keyword">INTO</span> total;</span><br><span class="line"></span><br><span class="line">    <span class="comment">--Is this taxable?</span></span><br><span class="line">    IF taxable <span class="keyword">THEN</span></span><br><span class="line">        <span class="comment">-- Yes, so add taxrate to the total</span></span><br><span class="line">        <span class="keyword">SELECT</span> total<span class="operator">+</span>(total<span class="operator">/</span><span class="number">100</span><span class="operator">*</span>taxrate) <span class="keyword">INTO</span> total;</span><br><span class="line">    <span class="keyword">END</span> IF;</span><br><span class="line">    <span class="comment">-- And finally, save to out variable</span></span><br><span class="line">    <span class="keyword">SELECT</span> total <span class="keyword">INTO</span> ototal;</span><br><span class="line"></span><br><span class="line"><span class="keyword">END</span>;</span><br></pre></td></tr></table></figure>

<p>上面增加了注释（前面放置<code>--</code>）。在存储过程复杂性增加时，这样做特别重要。添加了另外一个参数<code>taxable</code>，它是一个布尔值（如果要增加税则为真，否则为假）。在存储过程体中，用<code>DECLARE</code>语句定义了两个局部变量。<code>DECLARE</code>要求指定变量名和数据类型，它也支持可选的默认值（这个例子中的<code>taxrate</code>的默认被设置为<code>6%</code>）。<code>SELECT</code>语句已经改变，因此其结果存储到<code>total</code>（局部变量）而不是<code>ototal</code>。<code>IF</code>语句检查<code>taxable</code>是否为真，如果为真，则用另一<code>SELECT</code>语句增加营业税到局部变量<code>total</code>。最后，用另一<code>SELECT</code>语句将<code>total</code>（它增加或许不增加营业税）保存到<code>ototal</code>。</p>
<p>本例子中的存储过程在<code>CREATE PROCEDURE</code>语句中包含了一个<code>COMMENT</code>值。它不是必需的，但如果给出，将在<code>SHOW PROCEDURE STATUS</code>的结果中显示。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CALL</span> ordertotal(<span class="number">20005</span>, <span class="number">0</span>, <span class="variable">@total</span>);</span><br><span class="line"><span class="keyword">SELECT</span> <span class="variable">@total</span></span><br></pre></td></tr></table></figure>

<p><code>BOOLEAN</code>值指定为<code>1</code>表示真，指定为<code>0</code>表示假（实际上，非零值都考虑为真，只有<code>0</code>被视为假）。通过给中间的参数指定0或1，可以有条件地将营业税加到订单合计上。</p>
<p>为显示用来创建一个存储过程的<code>CREATE</code>语句，使用<code>SHOW CREATE PROCEDURE</code>语句：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> <span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> ordertotal;</span><br></pre></td></tr></table></figure>

<p>为了获得包括何时、由谁创建等详细信息的存储过程列表，使用<code>SHOW PROCEDURE STATUS</code>。</p>
<p><code>SHOW PROCEDURE STATUS</code>列出所有存储过程。为限制其输出，可使用<code>LIKE</code>指定一个过滤模式，例如：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> <span class="keyword">PROCEDURE</span> STATUS <span class="keyword">LIKE</span> <span class="string">&#x27;ordertotal&#x27;</span>;</span><br></pre></td></tr></table></figure>

<h1 id="第24章-使用游标"><a href="#第24章-使用游标" class="headerlink" title="第24章 使用游标"></a>第24章 使用游标</h1><p>游标（cursor）是一个存储在MySQL服务器上的数据库查询，它不是一条SELECT语句，而是被该语句检索出来的结果集<br>只能用于存储过程，不像多数DBMS, MySQL游标只能用于存储过程（和函数）。</p>
<p>使用游标涉及几个明确的步骤：</p>
<ul>
<li>在能够使用游标前，必须声明（定义）它。这个过程实际上没有检索数据，它只是定义要使用的SELECT语句。</li>
<li>一旦声明后，必须打开游标以供使用。这个过程用前面定义的SELECT语句把数据实际检索出来。</li>
<li>对于填有数据的游标，根据需要取出（检索）各行。</li>
<li>在结束游标使用时，必须关闭游标。<br>在声明游标后，可根据需要频繁地打开和关闭游标。在游标打开后，可根据需要频繁地执行取操作。</li>
</ul>
<p><code>DECLARE</code>命名游标，并定义相应的<code>SELECT</code>语句，根据需要带<code>WHERE</code>和其他子句</p>
<p>下面的语句定义了名为<code>ordernumbers</code>的游标，使用了可以检索所有订单的<code>SELECT</code>语句</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> processorders()</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    <span class="keyword">DECLARE</span> ordernumbers <span class="keyword">CURSOR</span></span><br><span class="line">    <span class="keyword">FOR</span></span><br><span class="line">    <span class="keyword">SELECT</span> order_num <span class="keyword">FROM</span> orders;</span><br><span class="line"><span class="keyword">END</span></span><br></pre></td></tr></table></figure>

<p>这个存储过程并没有做很多事情，<code>DECLARE</code>语句用来定义和命名游标，这里为<code>ordernumbers</code>。 存储过程处理完成后，游标就消失（因为它局限于存储过程）。</p>
<p>游标用<code>OPEN CURSOR</code>语句来打开：<code>OPEN ordernumbers</code><br>在处理<code>OPEN</code>语句时执行查询，存储检索出的数据以供浏览和滚动。<br>游标处理完成后，应当使用如下语句关闭游标：<code>CLOSE ordernumbers</code></p>
<p>CLOSE释放游标使用的所有内部内存和资源，因此在每个游标不再需要时都应该关闭。在一个游标关闭后，如果没有重新打开，则不能使用它<br>隐含关闭 如果你不明确关闭游标，MySQL将会在到达<code>END</code>语句时自动关闭它。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> processorders()</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    <span class="comment">-- Declare the cursor</span></span><br><span class="line">    <span class="keyword">DECLARE</span> ordernumbers <span class="keyword">CURSOR</span></span><br><span class="line">    <span class="keyword">FOR</span></span><br><span class="line">    <span class="keyword">SELECT</span> order_num <span class="keyword">FROM</span> orders;</span><br><span class="line"></span><br><span class="line">    <span class="comment">-- OPEN the cursor</span></span><br><span class="line">    <span class="keyword">OPEN</span> ordernumbers;</span><br><span class="line"></span><br><span class="line">    <span class="comment">-- Close the cursor</span></span><br><span class="line">    <span class="keyword">CLOSE</span> ordernumbers;</span><br><span class="line"><span class="keyword">END</span>;</span><br></pre></td></tr></table></figure>

<p>这个存储过程声明、打开和关闭一个游标。但对检索出的数据什么也没做。</p>
<p>在一个游标被打开后，可以使用<code>FETCH</code>语句分别访问它的每一行。<code>FETCH</code>指定检索什么数据（所需的列），检索出来的数据存储在什么地方。它还向前移动游标中的内部行指针，使下一条<code>FETCH</code>语句检索下一行（不重复读取同一行）。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> processorders()</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    <span class="comment">-- Declare local variables</span></span><br><span class="line">    <span class="keyword">DECLARE</span> o <span class="type">INT</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">-- Declare the cursor</span></span><br><span class="line">    <span class="keyword">DECLARE</span> ordernumbers <span class="keyword">CURSOR</span></span><br><span class="line">    <span class="keyword">FOR</span></span><br><span class="line">    <span class="keyword">SELECT</span> order_num <span class="keyword">FROM</span> orders;</span><br><span class="line"></span><br><span class="line">    <span class="comment">-- OPEN the cursor</span></span><br><span class="line">    <span class="keyword">OPEN</span> ordernumbers;</span><br><span class="line"></span><br><span class="line">    <span class="comment">-- Get order number</span></span><br><span class="line">    <span class="keyword">FETCH</span> ordernumbers <span class="keyword">INTO</span> o;</span><br><span class="line"></span><br><span class="line">    <span class="comment">-- Close the cursor</span></span><br><span class="line">    <span class="keyword">CLOSE</span> ordernumbers;</span><br><span class="line"><span class="keyword">END</span>;</span><br></pre></td></tr></table></figure>

<p>其中 FETCH 用来检索当前行的 order_num 列（将自动从第一行开始）到一个名为<code>o</code>的局部声明的变量中。对检索出的数据不做任何处理。<br>在下一个例子中，循环检索数据，从第一行到最后一行。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> processorders()</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    <span class="comment">-- Declare local variables</span></span><br><span class="line">    <span class="keyword">Declare</span> done <span class="type">BOOLEAN</span> <span class="keyword">DEFAULT</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">DECLARE</span> o <span class="type">INT</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">-- Declare the cursor</span></span><br><span class="line">    <span class="keyword">DECLARE</span> ordernumbers <span class="keyword">CURSOR</span></span><br><span class="line">    <span class="keyword">FOR</span></span><br><span class="line">    <span class="keyword">SELECT</span> order_num <span class="keyword">FROM</span> orders;</span><br><span class="line"></span><br><span class="line">    <span class="comment">-- Declare continue handler</span></span><br><span class="line">    <span class="keyword">DECLARE</span> CONTINUE HANDLER <span class="keyword">FOR</span> <span class="keyword">SQLSTATE</span> <span class="string">&#x27;02000&#x27;</span> <span class="keyword">SET</span> done<span class="operator">=</span><span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">-- OPEN the cursor</span></span><br><span class="line">    <span class="keyword">OPEN</span> ordernumbers;</span><br><span class="line"></span><br><span class="line">    <span class="comment">-- Loop through all rows</span></span><br><span class="line">    REPEAT</span><br><span class="line">        <span class="comment">-- Get order number</span></span><br><span class="line">        <span class="keyword">FETCH</span> ordernumbers <span class="keyword">INTO</span> o;</span><br><span class="line">    <span class="comment">-- End of loop</span></span><br><span class="line">    UNTIL done <span class="keyword">END</span> REPEAT</span><br><span class="line"></span><br><span class="line">    <span class="comment">-- Close the cursor</span></span><br><span class="line">    <span class="keyword">CLOSE</span> ordernumbers;</span><br><span class="line"><span class="keyword">END</span>;</span><br></pre></td></tr></table></figure>

<p>这个例子使用<code>FETCH</code>检索当前<code>order_num</code>到声明的名为<code>o</code>的变量中。但与前一个例子不一样的是，这个例子中的<code>FETCH</code>是在<code>REPEAT</code>内，因此它反复执行直到<code>done</code>为真（由<code>UNTIL done END REPEAT</code>；规定）。<br>为使它起作用，用一个<code>DEFAULT 0</code>（假，不结束）定义变量<code>done</code>。那么，<code>done</code>怎样才能在结束时被设置为真呢？答案是用以下语句：<br><code>DECLARE CONTINUE HANDLER FOR SQLSTATE &#39;02000&#39; SET done=1;</code><br>这条语句定义了一个<code>CONTINUE HANDLER</code>，它是在条件出现时被执行的代码。这里，它指出当<code>SQLSTATE &#39;02000’</code>出现时，<code>SET done=1</code>。<code>SQLSTATE &#39;02000’</code>是一个未找到条件，当<code>REPEAT</code>由于没有更多的行供循环而不能继续时，出现这个条件。</p>
<p><code>DECLARE</code>语句的次序：<br><code>DECLARE</code>语句的发布存在特定的次序。用<code>DECLARE</code>语句定义的局部变量必须在定义任意游标或句柄之前定义，而句柄必须在游标之后定义。不遵守此顺序将产生错误消息。</p>
<p>如果一切正常，你可以在循环内放入任意需要的处理（在<code>FETCH</code>语句之后，循环结束之前）。<br>重复或循环？ 除这里使用的<code>REPEAT</code>语句外，<code>MySQL</code>还支持循环语句，它可用来重复执行代码，直到使用<code>LEAVE</code>语句手动退出为止。通常<code>REPEAT</code>语句的语法使它更适合于对游标进行循环。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> processorders()</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    <span class="comment">-- Declare local variables</span></span><br><span class="line">    <span class="keyword">DECLARE</span> done <span class="type">BOOLEAN</span> <span class="keyword">DEFAULT</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">DECLARE</span> o <span class="type">INT</span>;</span><br><span class="line">    <span class="keyword">DECLARE</span> t <span class="type">DECIMAL</span>(<span class="number">8</span>,<span class="number">2</span>);</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="comment">-- Declare the cursor</span></span><br><span class="line">    <span class="keyword">DECLARE</span> ordernumbers <span class="keyword">CURSOR</span></span><br><span class="line">    <span class="keyword">FOR</span></span><br><span class="line">    <span class="keyword">SELECT</span> order_num <span class="keyword">FROM</span> orders;</span><br><span class="line"></span><br><span class="line">    <span class="comment">-- Declare continue handler</span></span><br><span class="line">    <span class="keyword">DECLARE</span> CONTINUE HANDLER <span class="keyword">FOR</span> <span class="keyword">SQLSTATE</span> <span class="string">&#x27;02000&#x27;</span> <span class="keyword">SET</span> done<span class="operator">=</span><span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">-- Create a table to store the results</span></span><br><span class="line">    <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> ordertotals</span><br><span class="line">    (order_num <span class="type">INT</span>, total <span class="type">DECIMAL</span>(<span class="number">8</span>,<span class="number">2</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">-- OPEN the cursor</span></span><br><span class="line">    <span class="keyword">OPEN</span> ordernumbers;</span><br><span class="line"></span><br><span class="line">    <span class="comment">-- Loop through all rows</span></span><br><span class="line">    REPEAT</span><br><span class="line">        <span class="comment">-- Get order number</span></span><br><span class="line">        <span class="keyword">FETCH</span> ordernumbers <span class="keyword">INTO</span> o;</span><br><span class="line"></span><br><span class="line">        <span class="comment">-- Get the total for this order</span></span><br><span class="line">        <span class="keyword">CALL</span> ordertotal(o, <span class="number">1</span>, t);</span><br><span class="line"></span><br><span class="line">        <span class="comment">-- Insert order and total into ordertotals</span></span><br><span class="line">        <span class="keyword">INSERT</span> <span class="keyword">INTO</span> ordertotals(order_num, total)</span><br><span class="line">        <span class="keyword">VALUES</span>(o,t)</span><br><span class="line">    <span class="comment">-- End of loop</span></span><br><span class="line">    UNTIL done <span class="keyword">END</span> REPEAT</span><br><span class="line"></span><br><span class="line">    <span class="comment">-- Close the cursor</span></span><br><span class="line">    <span class="keyword">CLOSE</span> ordernumbers;</span><br><span class="line"><span class="keyword">END</span>;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，我们增加了另一个名为<code>t</code>的变量（存储每个订单的合计）。此存储过程还在运行中创建了一个新表（如果它不存在的话），名为<code>ordertotals</code>。这个表将保存存储过程生成的结果。<code>FETCH</code>像以前一样取每个<code>order_num</code>，然后用<code>CALL</code>执行另一个存储过程（我们在前一章中创建）来计算每个订单的带税的合计（结果存储到<code>t</code>）。最后，用<code>INSERT</code>保存每个订单的订单号和合计。此存储过程不返回数据，但它能够创建和填充另一个表，可以用一条简单的<code>SELECT</code>语句查看该表：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> ordertotals;</span><br></pre></td></tr></table></figure>

<h1 id="第25章-使用触发器"><a href="#第25章-使用触发器" class="headerlink" title="第25章 使用触发器"></a>第25章 使用触发器</h1><p>触发器是MySQL响应以下任意语句而自动执行的一条MySQL语句（或位于<code>BEGIN</code>和<code>END</code>语句之间的一组语句）：</p>
<ul>
<li>DELETE</li>
<li>INSERT</li>
<li>UPDATE</li>
</ul>
<p>其他MySQL语句不支持触发器。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> newproduct AFTER <span class="keyword">INSERT</span> <span class="keyword">ON</span> products</span><br><span class="line"><span class="keyword">FOR</span> <span class="keyword">EACH</span> <span class="type">ROW</span> <span class="keyword">SELECT</span> <span class="string">&#x27;Product added&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p><code>CREATE TRIGGER</code>用来创建名为<code>newproduct</code>的新触发器。触发器可在一个操作发生之前或之后执行，这里给出了<code>AFTER INSERT</code>，所以此触发器将在<code>INSERT</code>语句成功执行后执行。这个触发器还指定 <code>FOR EACH ROW</code> ，因此代码对每个插入行执行。在这个例子中，文本<code>Product added</code>将对每个插入的行显示一次。</p>
<p>仅支持表 只有表才支持触发器，视图不支持（临时表也不支持）。</p>
<p>触发器按每个表每个事件每次地定义，每个表每个事件每次只允许一个触发器。因此，每个表最多支持6个触发器（每条<code>INSERT</code>、<code>UPDATE</code>和<code>DELETE</code>的之前和之后）。单一触发器不能与多个事件或多个表关联，所以，如果你需要一个对<code>INSERT</code>和<code>UPDATE</code>操作执行的触发器，则应该定义两个触发器。</p>
<p>触发器失败：如果<code>BEFORE</code>触发器失败，则<code>MySQL</code>将不执行请求的操作。此外，如果<code>BEFORE</code>触发器或语句本身失败，<code>MySQL</code>将不执行<code>AFTER</code>触发器（如果有的话）。</p>
<p>为了删除一个触发器，可使用DROP TRIGGER语句，如下所示：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TRIGGER</span> newproduct;</span><br></pre></td></tr></table></figure>

<p>触发器不能更新或覆盖。为了修改一个触发器，必须先删除它，然后再重新创建。</p>
<h2 id="INSERT触发器"><a href="#INSERT触发器" class="headerlink" title="INSERT触发器"></a>INSERT触发器</h2><p><code>INSERT</code>触发器在<code>INSERT</code>语句执行之前或之后执行。需要知道以下几点：</p>
<ul>
<li>在<code>INSERT</code>触发器代码内，可引用一个名为NEW的虚拟表，访问被插入的行；</li>
<li>在<code>BEFORE INSERT</code>触发器中，<code>NEW</code>中的值也可以被更新（允许更改被插入的值）；</li>
<li>对于<code>AUTO_INCREMENT</code>列，<code>NEW</code>在<code>INSERT</code>执行之前包含<code>0</code>，在<code>INSERT</code>执行之后包含新的自动生成值。</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> neworder AFTER <span class="keyword">INSERT</span> <span class="keyword">ON</span> orders</span><br><span class="line"><span class="keyword">FOR</span> <span class="keyword">EACH</span> <span class="type">ROW</span> <span class="keyword">SELECT</span> NEW.order_num</span><br></pre></td></tr></table></figure>

<p>此代码创建一个名为<code>neworder</code>的触发器，它按照<code>AFTER INSERT ON orders</code>执行。在插入一个新订单到<code>orders</code>表时，<code>MySQL</code>生成一个新订单号并保存到<code>order_num</code>中。触发器从<code>NEW. order_num</code>取得这个值并返回它。此触发器必须按照<code>AFTER INSERT</code>执行，因为在<code>BEFORE INSERT</code>语句执行之前，新<code>order_num</code>还没有生成。对于<code>orders</code>的每次插入使用这个触发器将总是返回新的订单号。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> orders(order_date, cust_id)</span><br><span class="line"><span class="keyword">VALUES</span>(Now(),<span class="number">10001</span>);</span><br></pre></td></tr></table></figure>

<p><code>orders</code>包含3个列。<code>order_date</code>和<code>cust_id</code>必须给出，<code>order_num</code>由<code>MySQL</code>自动生成，而现在<code>order_num</code>还自动被返回。</p>
<p><code>BEFORE</code>或<code>AFTER</code>？ 通常，将<code>BEFORE</code>用于数据验证和净化（目的是保证插入表中的数据确实是需要的数据）。本提示也适用于<code>UPDATE</code>触发器。</p>
<h2 id="DELETE触发器"><a href="#DELETE触发器" class="headerlink" title="DELETE触发器"></a>DELETE触发器</h2><p><code>DELETE</code>触发器在<code>DELETE</code>语句执行之前或之后执行。需要知道以下两点：<br>❑ 在<code>DELETE</code>触发器代码内，你可以引用一个名为<code>OLD</code>的虚拟表，访问被删除的行；<br>❑ <code>OLD</code>中的值全都是只读的，不能更新。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> deleteorder BEFORE <span class="keyword">DELETE</span> <span class="keyword">ON</span> orders</span><br><span class="line"><span class="keyword">FOR</span> <span class="keyword">EACH</span> <span class="type">ROW</span></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    <span class="keyword">INSERT</span> <span class="keyword">INTO</span> archive_orders(order_num, order_date, cust_id)</span><br><span class="line">    <span class="keyword">VALUES</span>(OLD.order_num, OLD.order_date, OLD.cust_id)</span><br><span class="line"><span class="keyword">END</span>;</span><br></pre></td></tr></table></figure>

<p>在任意订单被删除前将执行此触发器。它使用一条<code>INSERT</code>语句将<code>OLD</code>中的值（要被删除的订单）保存到一个名为<code>archive_orders</code>的存档表中（为实际使用这个例子，你需要用与<code>orders</code>相同的列创建一个名为<code>archive_orders</code>的表）。<br>使用<code>BEFORE DELETE</code>触发器的优点（相对于<code>AFTER DELETE</code>触发器来说）为，如果由于某种原因，订单不能存档，<code>DELETE</code>本身将被放弃。</p>
<p>多语句触发器：正如所见，触发器<code>deleteorder</code>使用<code>BEGIN</code>和<code>END</code>语句标记触发器体。这在此例子中并不是必需的，不过也没有害处。使用<code>BEGIN END</code>块的好处是触发器能容纳多条<code>SQL</code>语句（在<code>BEGIN END</code>块中一条挨着一条）。</p>
<h2 id="UPDATE触发器"><a href="#UPDATE触发器" class="headerlink" title="UPDATE触发器"></a>UPDATE触发器</h2><p><code>UPDATE</code>触发器在<code>UPDATE</code>语句执行之前或之后执行。需要知道以下几点：</p>
<ul>
<li>在<code>UPDATE</code>触发器代码中，你可以引用一个名为<code>OLD</code>的虚拟表访问以前（<code>UPDATE</code>语句前）的值，引用一个名为<code>NEW</code>的虚拟表访问新更新的值；</li>
<li>在<code>BEFORE UPDATE</code>触发器中，<code>NEW</code>中的值可能也被更新（允许更改将要用于<code>UPDATE</code>语句中的值）；</li>
<li><code>OLD</code>中的值全都是只读的，不能更新。</li>
</ul>
<p>下面的例子保证州名缩写总是大写（不管<code>UPDATE</code>语句中给出的是大写还是小写）。<br>显然，任何数据净化都需要在<code>UPDATE</code>语句之前进行，就像这个例子中一样。每次更新一个行时，<code>NEW.vend_state</code>中的值（将用来更新表行的值）都用<code>Upper(NEW.vend_state)</code>替换。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> updatevendor BEFORE UPDATE <span class="keyword">ON</span> vendors</span><br><span class="line"><span class="keyword">FOR</span> <span class="keyword">EACH</span> <span class="type">ROW</span> <span class="keyword">SET</span> NEW.vend_state <span class="operator">=</span> <span class="built_in">Upper</span>(NEW.vend_state);</span><br></pre></td></tr></table></figure>

<ul>
<li>与其他DBMS相比，MySQL 5中支持的触发器相当初级。未来的MySQL版本中有一些改进和增强触发器支持的计划。</li>
<li>创建触发器可能需要特殊的安全访问权限，但是，触发器的执行是自动的。如果<code>INSERT</code>、<code>UPDATE</code>或<code>DELETE</code>语句能够执行，则相关的触发器也能执行。</li>
<li>应该用触发器来保证数据的一致性（大小写、格式等）。在触发器中执行这种类型的处理的优点是它总是进行这种处理，而且是透明地进行，与客户机应用无关。</li>
<li>触发器的一种非常有意义的使用是创建审计跟踪。使用触发器，把更改（如果需要，甚至还有之前和之后的状态）记录到另一个表非常容易。</li>
<li>遗憾的是，MySQL触发器中不支持<code>CALL</code>语句。这表示不能从触发器内调用存储过程。所需的存储过程代码需要复制到触发器内。</li>
</ul>
<h1 id="第26章-管理事务处理"><a href="#第26章-管理事务处理" class="headerlink" title="第26章 管理事务处理"></a>第26章 管理事务处理</h1><p>事务处理（transaction processing）可以用来维护数据库的完整性，它保证成批的MySQL操作要么完全执行，要么完全不执行。</p>
<ul>
<li>事务（transaction）指一组SQL语句；</li>
<li>回退（rollback）指撤销指定SQL语句的过程；</li>
<li>提交（commit）指将未存储的SQL语句结果写入数据库表；</li>
<li>保留点（savepoint）指事务处理中设置的临时占位符（place-holder），你可以对它发布回退（与回退整个事务处理不同）。</li>
</ul>
<p>管理事务处理的关键在于将SQL语句组分解为逻辑块，并明确规定数据何时应该回退，何时不应该回退。<br>MySQL使用下面的语句来标识事务的开始：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">START</span> TRANSACTION</span><br></pre></td></tr></table></figure>

<h2 id="使用ROLLBACK"><a href="#使用ROLLBACK" class="headerlink" title="使用ROLLBACK"></a>使用ROLLBACK</h2><p>MySQL的<code>ROLLBACK</code>命令用来回退（撤销）MySQL语句，请看下面的语句：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> ordertotals;</span><br><span class="line"><span class="keyword">START</span> TRANSACTION;</span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> ordertotals;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> ordertotals;</span><br><span class="line"><span class="keyword">ROLLBACK</span>;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> ordertotals;</span><br></pre></td></tr></table></figure>

<p>这个例子从显示<code>ordertotals</code>表（此表在第24章中填充）的内容开始。首先执行一条<code>SELECT</code>以显示该表不为空。然后开始一个事务处理，用一条<code>DELETE</code>语句删除<code>ordertotals</code>中的所有行。另一条<code>SELECT</code>语句验证<code>ordertotals</code>确实为空。这时用一条<code>ROLLBACK</code>语句回退<code>START TRANSACTION</code>之后的所有语句，最后一条<code>SELECT</code>语句显示该表不为空。<br>显然，<code>ROLLBACK</code>只能在一个事务处理内使用（在执行一条<code>STARTTRANSACTION</code>命令之后）。</p>
<p>事务处理用来管理<code>INSERT</code>、<code>UPDATE</code>和<code>DELETE</code>语句。你不能回退<code>SELECT</code>语句。（这样做也没有什么意义。）你不能回退<code>CREATE</code>或<code>DROP</code>操作。事务处理块中可以使用这两条语句，但如果你执行回退，它们不会被撤销。</p>
<h2 id="使用COMMIT"><a href="#使用COMMIT" class="headerlink" title="使用COMMIT"></a>使用COMMIT</h2><p>一般的MySQL语句都是直接针对数据库表执行和编写的。这就是所谓的隐含提交（implicit commit），即提交（写或保存）操作是自动进行的。但是，在事务处理块中，提交不会隐含地进行。为进行明确的提交，使用<code>COMMIT</code>语句，如下所示：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">START</span> TRANSACTION;</span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> orderitems <span class="keyword">WHERE</span> order_num <span class="operator">=</span> <span class="number">20010</span>;</span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> orders <span class="keyword">WHERE</span> order_num <span class="operator">=</span> <span class="number">20010</span>;</span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，从系统中完全删除订单<code>20010</code>。因为涉及更新两个数据库表<code>orders</code>和<code>orderItems</code>，所以使用事务处理块来保证订单不被部分删除。最后的<code>COMMIT</code>语句仅在不出错时写出更改。如果第一条<code>DELETE</code>起作用，但第二条失败，则<code>DELETE</code>不会提交（实际上，它是被自动撤销的）。<br><strong>隐含事务关闭</strong>：当<code>COMMIT</code>或<code>ROLLBACK</code>语句执行后，事务会自动关闭（将来的更改会隐含提交）。</p>
<h2 id="使用保留点"><a href="#使用保留点" class="headerlink" title="使用保留点"></a>使用保留点</h2><p>简单的<code>ROLLBACK</code>和<code>COMMIT</code>语句就可以写入或撤销整个事务处理。但是，只是对简单的事务处理才能这样做，更复杂的事务处理可能需要部分提交或回退。<br>例如，前面描述的添加订单的过程为一个事务处理。如果发生错误，只需要返回到添加<code>orders</code>行之前即可，不需要回退到<code>customers</code>表（如果存在的话）。<br>为了支持回退部分事务处理，必须能在事务处理块中合适的位置放置占位符。这样，如果需要回退，可以回退到某个占位符。<br>这些占位符称为保留点。为了创建占位符，可如下使用<code>SAVEPOINT</code>语句：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SAVEPOINT</span> deletel;</span><br></pre></td></tr></table></figure>

<p>每个保留点都取标识它的唯一名字，以便在回退时，<code>MySQL</code>知道要回退到何处。为了回退到本例给出的保留点，可如下进行：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ROLLBACK</span> <span class="keyword">TO</span> deletel;</span><br></pre></td></tr></table></figure>

<p>可以在MySQL代码中设置任意多的保留点，越多越好。为什么呢？因为保留点越多，你就越能按自己的意愿灵活地进行回退。</p>
<p>保留点在事务处理完成（执行一条<code>ROLLBACK</code>或<code>COMMIT</code>）后自动释放。自MySQL 5以来，也可以用<code>RELEASE SAVEPOINT</code>明确地释放保留点。</p>
<h2 id="更改默认的提交行为"><a href="#更改默认的提交行为" class="headerlink" title="更改默认的提交行为"></a>更改默认的提交行为</h2><p>正如所述，默认的MySQL行为是自动提交所有更改。换句话说，任何时候你执行一条MySQL语句，该语句实际上都是针对表执行的，而且所做的更改立即生效。为指示MySQL不自动提交更改，需要使用以下语句：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SET</span> autocommit<span class="operator">=</span><span class="number">0</span></span><br></pre></td></tr></table></figure>

<p><code>autocommit</code>标志决定是否自动提交更改，不管有没有<code>COMMIT</code>语句。设置<code>autocommit</code>为0（假）指示MySQL不自动提交更改（直到<code>autocommit</code>被设置为真为止）。</p>
<p>标志为连接专用：<code>autocommit</code>标志是针对每个连接而不是服务器的。</p>
<h1 id="第27章-全球化和本地化"><a href="#第27章-全球化和本地化" class="headerlink" title="第27章 全球化和本地化"></a>第27章 全球化和本地化</h1><p>数据库表被用来存储和检索数据。不同的语言和字符集需要以不同的方式存储和检索。因此，MySQL需要适应不同的字符集（不同的字母和字符），适应不同的排序和检索数据的方法。</p>
<ul>
<li>字符集为字母和符号的集合；</li>
<li>编码为某个字符集成员的内部表示；</li>
<li>校对为规定字符如何比较的指令。</li>
</ul>
<p>在MySQL的正常数据库活动（<code>SELECT</code>、<code>INSERT</code>等）中，不需要操心太多的东西。使用何种字符集和校对的决定在服务器、数据库和表级进行。</p>
<p>MySQL支持众多的字符集。为查看所支持的字符集完整列表，使用以下语句：<br>这条语句显示所有可用的字符集以及每个字符集的描述和默认校对</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> <span class="type">CHARACTER</span> <span class="keyword">SET</span>;</span><br></pre></td></tr></table></figure>

<p>为了查看所支持校对的完整列表，使用以下语句：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> <span class="keyword">COLLATION</span>;</span><br></pre></td></tr></table></figure>

<p>此语句显示所有可用的校对，以及它们适用的字符集。可以看到有的字符集具有不止一种校对。例如，<code>latin1</code>对不同的欧洲语言有几种校对，而且许多校对出现两次，一次区分大小写（由<code>_cs</code>表示），一次不区分大小写（由<code>_ci</code>表示）。</p>
<p>通常系统管理在安装时定义一个默认的字符集和校对。此外，也可以在创建数据库时，指定默认的字符集和校对。为了确定所用的字符集和校对，可以使用以下语句：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> VARIABLES <span class="keyword">LIKE</span> <span class="string">&#x27;character%&#x27;</span>;</span><br><span class="line"><span class="keyword">SHOW</span> VARIABLES <span class="keyword">LIKE</span> <span class="string">&#x27;collation%&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>实际上，字符集很少是服务器范围（甚至数据库范围）的设置。不同的表，甚至不同的列都可能需要不同的字符集，而且两者都可以在创建表时指定。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> mytable</span><br><span class="line">(</span><br><span class="line">    columnn1    <span class="type">INT</span>,</span><br><span class="line">    columnn2    <span class="type">VARCHAR</span>(<span class="number">10</span>)</span><br><span class="line">)<span class="keyword">DEFAULT</span> <span class="type">CHARACTER</span> <span class="keyword">SET</span> hebrew</span><br><span class="line"><span class="keyword">COLLATE</span> hebrew_general_ci;</span><br></pre></td></tr></table></figure>

<p>此语句创建一个包含两列的表，并且指定一个字符集和一个校对顺序。<br>这个例子中指定了 CHARACTER SET 和 COLLATE 两者。一般，MySQL如下确定使用什么样的字符集和校对。</p>
<ul>
<li>如果指定<code>CHARACTER SET</code>和<code>COLLATE</code>两者，则使用这些值。</li>
<li>如果只指定<code>CHARACTER SET</code>，则使用此字符集及其默认的校对（如<code>SHOW CHARACTER SET</code>的结果中所示）。</li>
<li>如果既不指定<code>CHARACTER SET</code>，也不指定<code>COLLATE</code>，则使用数据库默认。</li>
</ul>
<p>除了能指定字符集和校对的表范围外，MySQL还允许对每个列设置它们，如下所示：<br>这里对整个表以及一个特定的列指定了<code>CHARACTER SET</code>和<code>COLLATE</code>。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> mytable</span><br><span class="line">(</span><br><span class="line">    columnn1    <span class="type">INT</span>,</span><br><span class="line">    columnn2    <span class="type">VARCHAR</span>(<span class="number">10</span>)</span><br><span class="line">    columnn2    <span class="type">VARCHAR</span>(<span class="number">10</span>) <span class="type">CHARACTER</span> <span class="keyword">SET</span> latin1 <span class="keyword">COLLATE</span> latin1_general_ci</span><br><span class="line">)<span class="keyword">DEFAULT</span> <span class="type">CHARACTER</span> <span class="keyword">SET</span> hebrew</span><br><span class="line"><span class="keyword">COLLATE</span> hebrew_general_ci;</span><br></pre></td></tr></table></figure>

<p>如前所述，校对在对用<code>ORDER BY</code>子句检索出来的数据排序时起重要的作用。如果你需要用与创建表时不同的校对顺序排序特定的<code>SELECT</code>语句，可以在<code>SELECT</code>语句自身中进行：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> customers</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> lastname, firstname <span class="keyword">COLLATE</span> latin1_general_cs;</span><br></pre></td></tr></table></figure>

<p>此<code>SELECT</code>使用<code>COLLATE</code>指定一个备用的校对顺序（在这个例子中，为区分大小写的校对）。这显然将会影响到结果排序的次序。<br>上面的 SELECT 语句演示了在通常不区分大小写的表上进行区分大小写搜索的一种技术。当然，反过来也是可以的。<br>除了这里看到的在<code>ORDER BY</code>子句 中使用以外，<code>COLLATE</code>还可以用于<code>GROUP BY</code>、<code>HAVING</code>、聚集函数、别名等。</p>
<h1 id="第28章-安全管理"><a href="#第28章-安全管理" class="headerlink" title="第28章 安全管理"></a>第28章 安全管理</h1><p><code>MySQL</code>用户账号和信息存储在名为<code>mysql</code>的<code>MySQL</code>数据库中。一般不需要直接访问<code>mysql</code>数据库和表（你稍后会明白这一点），但有时需要直接访问。需要直接访问它的时机之一是在需要获得所有用户账号列表时。为此，可使用以下代码：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">USE mysql</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">user</span> <span class="keyword">FROM</span> <span class="keyword">user</span>;</span><br></pre></td></tr></table></figure>

<p>为了创建一个新用户账号，使用<code>CREATE USER</code>语句，如下所示：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">USER</span> ben IDENTIFIED <span class="keyword">BY</span> <span class="string">&#x27;p@$$w0rd&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>为重新命名一个用户账号，使用<code>RENAME USER</code>语句，如下所示：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">RENAME <span class="keyword">USER</span> ben <span class="keyword">TO</span> bforta;</span><br></pre></td></tr></table></figure>

<p>为了删除一个用户账号（以及相关的权限），使用<code>DROP USER</code>语句，如下所示：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">USER</span> bforta;</span><br></pre></td></tr></table></figure>

<p>在创建用户账号后，必须接着分配访问权限。新创建的用户账号没有访问权限。它们能登录<code>MySQL</code>，但不能看到数据，不能执行任何数据库操作。为看到赋予用户账号的权限，使用<code>SHOW GRANTS FOR</code>，如下所示</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> GRANTS <span class="keyword">FOR</span> bforta</span><br></pre></td></tr></table></figure>

<p>输出结果显示用户<code>bforta</code>有一个权限<code>USAGE ON *.*</code>。<code>USAGE</code>表示根本没有权限（我知道，这不很直观），所以，此结果表示在任意数据库和任意表上对任何东西没有权限。</p>
<p>为设置权限，使用<code>GRANT</code>语句。<code>GRANT</code>要求你至少给出以下信息：</p>
<ul>
<li>要被授予的权限</li>
<li>要被授予访问权限的数据库或表</li>
<li>用户名</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">GRANT</span> <span class="keyword">SELECT</span> <span class="keyword">ON</span> crashcourse.<span class="operator">*</span> <span class="keyword">TO</span> bforta;</span><br></pre></td></tr></table></figure>

<p>此<code>GRANT</code>允许用户在<code>crashcourse.*</code>（<code>crashcourse</code>数据库的所有表）上使用<code>SELECT</code>。通过只授予<code>SELECT</code>访问权限，用户<code>bforta</code>对<code>crashcourse</code>数据库中的所有数据具有只读访问权限。<br>每个<code>GRANT</code>添加（或更新）用户的一个权限。<code>MySQL</code>读取所有授权，并根据它们确定权限。</p>
<p><code>GRANT</code>的反操作为<code>REVOKE</code>，用它来撤销特定的权限。下面举一个例子：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">REVOKE</span> <span class="keyword">SELECT</span> <span class="keyword">ON</span> crashcourse.<span class="operator">*</span> <span class="keyword">FROM</span> bforta</span><br></pre></td></tr></table></figure>

<p>这条<code>REVOKE</code>语句取消刚赋予用户<code>bforta</code>的<code>SELECT</code>访问权限。被撤销的访问权限必须存在，否则会出错。</p>
<p><code>GRANT</code>和<code>REVOKE</code>可在几个层次上控制访问权限：</p>
<ul>
<li>整个服务器，使用<code>GRANT ALL</code>和<code>REVOKE ALL</code>；</li>
<li>整个数据库，使用<code>ON database.*</code>；</li>
<li>特定的表，使用<code>ON database.table</code>；</li>
<li>特定的列；</li>
<li>特定的存储过程。</li>
</ul>
<table>
<thead>
<tr>
<th>权限</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>ALL</td>
<td>除GRANT OPTION外的所有权限</td>
</tr>
<tr>
<td>ALTER</td>
<td>使用ALTER TABLE</td>
</tr>
<tr>
<td>ALTER ROUTINE</td>
<td>使用ALTER PROCEDURE和DROP ROCEDURE</td>
</tr>
<tr>
<td>CREATE</td>
<td>使用CREATE TABLE</td>
</tr>
<tr>
<td>CREATE ROUTINE</td>
<td>使用CREATE PROCEDURE</td>
</tr>
<tr>
<td>CREATE TEMPORARY TABLES</td>
<td>使用CREATE TEMPORARY TABLE</td>
</tr>
<tr>
<td>CREATE USER</td>
<td>使用CREATE USER、DROP USER、RENAME USER和REVOKE ALL PRIVILEGES</td>
</tr>
<tr>
<td>CREATE VIEW</td>
<td>使用CREATE VIEW</td>
</tr>
<tr>
<td>DELETE</td>
<td>使用DELETE</td>
</tr>
<tr>
<td>DROP</td>
<td>使用DROP TABLE</td>
</tr>
<tr>
<td>EXECUTE</td>
<td>使用CALL和存储过程</td>
</tr>
<tr>
<td>FILE</td>
<td>使用SELECT INTO OUTFILE和LOAD DATA INFILE</td>
</tr>
<tr>
<td>GRANT OPTION</td>
<td>使用GRANT和REVOKE</td>
</tr>
<tr>
<td>INDEX</td>
<td>使用CREATE INDEX和DROP INDEX</td>
</tr>
<tr>
<td>INSERT</td>
<td>使用INSERT</td>
</tr>
<tr>
<td>LOCK TABLES</td>
<td>使用LOCK TABLES</td>
</tr>
<tr>
<td>PROCESS</td>
<td>使用SHOW FULL PROCESSLIST</td>
</tr>
<tr>
<td>RELOAD</td>
<td>使用FLUSH</td>
</tr>
<tr>
<td>REPLICATION CLIENT</td>
<td>服务器位置的访问</td>
</tr>
<tr>
<td>REPLICATION SLAVE</td>
<td>由复制从属使用</td>
</tr>
<tr>
<td>SELECT</td>
<td>使用SELECT</td>
</tr>
<tr>
<td>SHOW DATABASES</td>
<td>使用SHOW DATABASES</td>
</tr>
<tr>
<td>SHOW VIEW</td>
<td>使用SHOW CREATE VIEW</td>
</tr>
<tr>
<td>SHUTDOWN</td>
<td>使用mysqladmin shutdown（用来关闭MySQL）</td>
</tr>
<tr>
<td>SUPER</td>
<td>使用CHANGE MASTER、KILL、LOGS、PURGE、MASTER和SET GLOBAL。还允许mysqladmin调试登录</td>
</tr>
<tr>
<td>UPDATE</td>
<td>使用UPDATE</td>
</tr>
<tr>
<td>USAGE</td>
<td>无访问权限</td>
</tr>
</tbody></table>
<p>为了更改用户口令，可使用<code>SET PASSWORD</code>语句。新口令必须如下加密：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SET</span> PASSWORD <span class="keyword">FOR</span> bforta <span class="operator">=</span> Password(<span class="string">&#x27;n3w p@$$w0rd&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p><code>SET PASSWORD</code>还可以用来设置你自己的口令：<br>在不指定用户名时，<code>SET PASSWORD</code>更新当前登录用户的口令。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SET</span> PASSWORD <span class="operator">=</span> Password(<span class="string">&#x27;n3w p@$$w0rd&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h1 id="第29章-数据库维护"><a href="#第29章-数据库维护" class="headerlink" title="第29章 数据库维护"></a>第29章 数据库维护</h1><p>为了保证所有数据被写到磁盘（包括索引数据），可能需要在进行备份前使用<code>FLUSH TABLES</code>语句。</p>
<p><code>ANALYZE TABLE</code>，用来检查表键是否正确。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">ANALYZE <span class="keyword">TABLE</span> orders;</span><br></pre></td></tr></table></figure>

<p><code>CHECK TABLE</code>用来针对许多问题对表进行检查。在<code>MyISAM</code>表上还对索引进行检查。<code>CHECK TABLE</code>支持一系列的用于<code>MyISAM</code>表的方式。<code>CHANGED</code>检查自最后一次检查以来改动过的表。<code>EXTENDED</code>执行最彻底的检查， <code>FAST</code>只检查未正常关闭的表， <code>MEDIUM</code>检查所有被删除的链接并进行键检验，<code>QUICK</code>只进行快速扫描。如下所示，<code>CHECKTABLE</code>发现和修复问题：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CHECK</span> <span class="keyword">TABLE</span> orders, orderitems;</span><br></pre></td></tr></table></figure>

<p>如果<code>MyISAM</code>表访问产生不正确和不一致的结果，可能需要用<code>REPAIR TABLE</code>来修复相应的表。这条语句不应该经常使用，如果需要经常使用，可能会有更大的问题要解决。</p>
<p>如果从一个表中删除大量数据，应该使用<code>OPTIMIZE TABLE</code>来收回所用的空间，从而优化表的性能。</p>
<p>在排除系统启动问题时，首先应该尽量用手动启动服务器。MySQL服务器自身通过在命令行上执行mysqld启动。下面是几个重要的mysqld命令行选项：</p>
<ul>
<li>–help 显示帮助——一个选项列表；</li>
<li>–safe-mode 装载减去某些最佳配置的服务器；</li>
<li>–verbose 显示全文本消息（为获得更详细的帮助消息与 –help联合使用）；</li>
<li>–version 显示版本信息然后退出</li>
</ul>
<p>MySQL维护管理员依赖的一系列日志文件。主要的日志文件有以下几种。</p>
<ul>
<li>错误日志。它包含启动和关闭问题以及任意关键错误的细节。此日志通常名为<code>hostname.err</code>，位于<code>data</code>目录中。此日志名可用<code>--log-error</code>命令行选项更改。</li>
<li>查询日志。它记录所有MySQL活动，在诊断问题时非常有用。此日志文件可能会很快地变得非常大，因此不应该长期使用它。此日志通常名为<code>hostname.log</code>，位于<code>data</code>目录中。此名字可以用<code>--log</code>命令行选项更改。</li>
<li>二进制日志。它记录更新过数据（或者可能更新过数据）的所有语句。此日志通常名为<code>hostname-bin</code>，位于<code>data</code>目录内。此名字可以用<code>--log-bin</code>命令行选项更改。注意，这个日志文件是MySQL5中添加的，以前的MySQL版本中使用的是更新日志。</li>
<li>缓慢查询日志。顾名思义，此日志记录执行缓慢的任何查询。这个日志在确定数据库何处需要优化很有用。此日志通常名为hostname-slow.log ，位于data目录中。此名字可以用<code>--log-slow-queries</code>命令行选项更改。</li>
</ul>
<p>在使用日志时，可用<code>FLUSH LOGS</code>语句来刷新和重新开始所有日志文件。</p>
<h1 id="第30章-改善性能"><a href="#第30章-改善性能" class="headerlink" title="第30章 改善性能"></a>第30章 改善性能</h1><p>数据库管理员把他们生命中的相当一部分时间花在了调整、试验以改善DBMS性能之上。在诊断应用的滞缓现象和性能问题时，性能不良的数据库（以及数据库查询）通常是最常见的祸因。<br>可以看出，下面的内容并不能完全决定MySQL的性能。我们只是想回顾一下前面各章的重点，提供进行性能优化探讨和分析的一个出发点。</p>
<ul>
<li>首先，MySQL（与所有DBMS一样）具有特定的硬件建议。在学习和研究MySQL时，使用任何旧的计算机作为服务器都可以。但对用于生产的服务器来说，应该坚持遵循这些硬件建议。</li>
<li>一般来说，关键的生产DBMS应该运行在自己的专用服务器上。</li>
<li>MySQL是用一系列的默认设置预先配置的，这些设置开始通常是很好的。但过一段时间后你可能需要调整内存分配、缓冲区大小等。（为查看当前设置，可使用SHOW VARIABLES；和SHOW STATUS;。）</li>
<li>MySQL是一个多用户多线程的DBMS，换言之，它经常同时执行多个任务。如果这些任务中的某一个执行缓慢，则所有请求都会执行缓慢。如果你遇到显著的性能不良，可使用SHOW PROCESSLIST显示所有活动进程（以及它们的线程ID和执行时间）。你还可以用KILL命令终结某个特定的进程（使用这个命令需要作为管理员登录）。</li>
<li>总是有不止一种方法编写同一条SELECT语句。应该试验联结、并、子查询等，找出最佳的方法。</li>
<li>使用EXPLAIN语句让MySQL解释它将如何执行一条SELECT语句。</li>
<li>一般来说，存储过程执行得比一条一条地执行其中的各条MySQL语句快。</li>
<li>应该总是使用正确的数据类型。</li>
<li>决不要检索比需求还要多的数据。换言之，不要用SELECT *（除非你真正需要每个列）。</li>
<li>有的操作（包括INSERT）支持一个可选的DELAYED关键字，如果使用它，将把控制立即返回给调用程序，并且一旦有可能就实际执行该操作。</li>
<li>在导入数据时，应该关闭自动提交。你可能还想删除索引（包括FULLTEXT索引），然后在导入完成后再重建它们。</li>
<li>必须索引数据库表以改善数据检索的性能。确定索引什么不是一件微不足道的任务，需要分析使用的SELECT语句以找出重复的WHERE和ORDER BY子句。如果一个简单的WHERE子句返回结果所花的时间太长，则可以断定其中使用的列（或几个列）就是需要索引的对象。</li>
<li>你的SELECT语句中有一系列复杂的OR条件吗？通过使用多条SELECT语句和连接它们的UNION语句，你能看到极大的性能改进。</li>
<li>索引改善数据检索的性能，但损害数据插入、删除和更新的性能。如果你有一些表，它们收集数据且不经常被搜索，则在有必要之前不要索引它们。（索引可根据需要添加和删除。）</li>
<li>LIKE很慢。一般来说，最好是使用FULLTEXT而不是LIKE。</li>
<li>数据库是不断变化的实体。一组优化良好的表一会儿后可能就面目全非了。由于表的使用和内容的更改，理想的优化和配置也会改变。</li>
<li>最重要的规则就是，每条规则在某些条件下都会被打破。</li>
</ul>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>我依然爱你，我只是不喜欢你了</title>
    <url>/2021/07/24/%E6%88%91%E4%BE%9D%E7%84%B6%E7%88%B1%E4%BD%A0%EF%BC%8C%E6%88%91%E5%8F%AA%E6%98%AF%E4%B8%8D%E5%96%9C%E6%AC%A2%E4%BD%A0%E4%BA%86/</url>
    <content><![CDATA[<ol>
<li>时光酿成的佳缘，虽百转千回，终成美眷</li>
</ol>
<span id="more"></span>

<ol start="2">
<li><p>我人生中最幸运的两件事：一件是时间终于将我对你的爱消耗殆尽，另一件是很久以前我遇到你</p>
</li>
<li><p>我不认为一辈子只爱一个人是件可惜的事，也不认为一辈子爱过很多人就是一件不道德的事</p>
</li>
<li><p>日本禅师铃木大拙的《禅者的初心》有一段话：“因为迷失了自己，烦恼对你来说就会成为真正的烦恼。当你没有迷失自己，哪怕你碰到麻烦，都不会觉得它们是什么烦恼。”</p>
</li>
<li><p>在没有见到巨龙之前，每个勇士都会认为自己会是那个屠龙的英雄</p>
</li>
<li><p>爱情这东西，时间很关键。认识得太早或太晚，都不行</p>
</li>
<li><p>依然祝你，平安幸福</p>
</li>
<li><p>一个人若要完全理解另一个人，大概必须有过类似的处境，受过类似的痛苦，或者有过类似的觉醒体验，而这却是非常罕见的</p>
</li>
<li><p>只要我知道你在，一切就都很好</p>
</li>
<li><p>叔本华的哲学理论看不进去，但他的随笔还是很精彩的，写了那么多，无非强调一点——所谓人生，不过是摇摆于痛苦与无聊之间的一座钟摆，或者因欲望不能满足而痛苦，或者因满足后的空虚而无聊。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>懂事之前，情动以后</title>
    <url>/2021/07/25/%E6%87%82%E4%BA%8B%E4%B9%8B%E5%89%8D%EF%BC%8C%E6%83%85%E5%8A%A8%E4%BB%A5%E5%90%8E/</url>
    <content><![CDATA[<ul>
<li><p>组成我们生命的，从来不是枯燥的永恒，而是那些怦然心动的细节</p>
</li>
<li><p>诸行无常，缘起缘灭，极乐终有尽时</p>
</li>
<li><p>妖本薄情</p>
</li>
</ul>
<span id="more"></span>

<ul>
<li><p>正是我们花在他身上的时间使他变得重要</p>
</li>
<li><p>姑娘，如果你想要一个暖男，就请你拥有配得上这份温暖的温柔</p>
</li>
<li><p>愿赌服输，这真是爱情里最高尚的品德</p>
</li>
<li><p>只是自此以后，悠悠岁月，好像了无牵挂，滚滚红尘，不过一堆白骨</p>
</li>
<li><p>痛苦是人生的本质，痛苦的来源并不是一切苦痛，而是你对人生本质的看不透</p>
</li>
<li><p>祝你最终找到一个既能陪你吃泡面，又能伴你吃烛光晚餐的姑娘</p>
</li>
<li><p>失去喜欢的人，就是恋爱这门课最高昂的学费</p>
</li>
<li><p>很多故事是假的，但道理是真的</p>
</li>
<li><p>讲故事的人假正经，听故事的人最无情</p>
</li>
<li><p>初见心动，再见依然</p>
</li>
</ul>
]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>三月下起了大雨</title>
    <url>/2021/07/27/%E4%B8%89%E6%9C%88%E4%B8%8B%E8%B5%B7%E4%BA%86%E5%A4%A7%E9%9B%A8/</url>
    <content><![CDATA[<ol>
<li><p>三月下起了大雨，四月里遍地蔷薇，五月我们面对坐着，犹如在梦中，就这样六月到了</p>
</li>
<li><p>归根到底是我错把你对我的好当做只给我一人的温柔，你负了我，你永远记得</p>
</li>
<li><p>爱的反面不是恨，而是冷漠。从来哭着闹着要走的人，都不是真正会离开的人。真正想要离开的那个人，挑一个风和日丽的下午，穿上一件大衣出门，消失在秋日的阳光里，再也没有回来</p>
</li>
</ol>
<span id="more"></span>

<ol start="4">
<li><p>当你遇上一个特别的人，却清醒明白永远不可能在一起，或迟或早，你不得不放弃。有些爱只能止于唇齿，掩于岁月</p>
</li>
<li><p>每一次去爱的时候，都请记得，你在第一次爱时拥有过的，像新生婴儿面对世界一样的好奇和感动；也请记得，你曾经如那蹒跚学步小孩一样的，对摔倒和受伤的不屑一顾</p>
</li>
<li><p>某天，你无端端想起一个人，她曾让你对明天有所期许，但她却完完全全没有出现在你的明天里。而青春的残酷就在于，我们拥有最好的爱，也遇见了最好的人，但是这些感情通常都没有任何结果，当它陨落消散的时候，甚至我们都来不及问一句为什么</p>
</li>
<li><p>想和你吃饭的人，酸甜苦辣都爱吃；想送你回家的人，东南西北都顺路</p>
</li>
</ol>
]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>偷影子的人</title>
    <url>/2021/07/27/%E5%81%B7%E5%BD%B1%E5%AD%90%E7%9A%84%E4%BA%BA/</url>
    <content><![CDATA[<ol>
<li><p>一段美丽的邂逅，有时是时间的问题，两个人得在对的时间遇到对方</p>
</li>
<li><p>一部分的自我遗落在离开的人身上，就像爱情的忧愁，这是友谊的愁绪</p>
</li>
<li><p>这整整两个月，我们称为“夏天”，而这也是四季中最美的季节</p>
</li>
</ol>
<span id="more"></span>

<ol start="4">
<li><p>你偷走了我的影子，不论你在哪里，我都会一直想着你</p>
</li>
<li><p>年轻人，规则，是用来让你们学会经验而不至于误杀死太多病人，而经验值则是让你们拿来打破规则的</p>
</li>
<li><p>我只是你生活里的一个影子，你却在我的生命里占有重要地位。如果我只是个单纯的过客，为何要让我闯入你的生活？我千百次想过要离开你，但仅凭一己之力我做不到</p>
</li>
<li><p>一个会用风筝向你写出“我想你”的女孩啊，真让人永远都忘不了她</p>
</li>
</ol>
]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>爱情来的太迟</title>
    <url>/2021/07/27/%E7%88%B1%E6%83%85%E6%9D%A5%E7%9A%84%E5%A4%AA%E8%BF%9F/</url>
    <content><![CDATA[<ol>
<li><p>爱情来的太迟，再来的人已经看不见我当初的美好和倔强，分享不了我年轻的愿望。<br>如果再迟些，也将错过我的青春和柔情，触碰不到我年轻的神态以及柔软的微笑，感受不到我如今炙热、生动并且强烈的情感</p>
</li>
<li><p>千里迢迢背井离乡，下了火车正是傍晚，万家灯火，没有一盏是为我点亮</p>
</li>
<li><p>我希望你别难过太久，希望你以后也能吃很多饭，希望你不要回头看我，希望你那晴天很多，希望你每天都能睡得熟，希望我们即使偶尔想念彼此也不要再问候，希望你走得越远就有更好的风景。希望，一别两宽，各生欢喜</p>
</li>
</ol>
<span id="more"></span>

<ol start="4">
<li><p>哪里会有人喜欢孤独，不过是不喜欢失望罢了     ——《挪威的森林》</p>
</li>
<li><p>后来我终于知道，它并不是我的花，我只是恰好途经了它的盛放</p>
</li>
<li><p>最甜的蜜糖，可以使味觉麻木。不太热烈的爱情才能维持久远       ——莎士比亚</p>
</li>
<li><p>爱情就像瓶子里的酒，倒一次少一点，直至倒完，却不会再生</p>
</li>
<li><p>我愿此生心里都有阳光。如果有多余的，再分给别人一点</p>
</li>
<li><p>为天地立心，为生民立命，为往圣继绝学，为万世开太平</p>
</li>
<li><p>某天，你无端端想起一个人，她曾让你对明天有所期许，但她却完完全全没有出现在你的明天里</p>
</li>
<li><p>我无法控制自己对你的难以忘怀，可是我关于你的一切已经再没有了期待</p>
</li>
<li><p>与恶龙缠斗过久，自身亦成恶龙；凝视深渊过久，深渊将回以凝视      ——尼采</p>
</li>
<li><p>上帝没有那么好心，不可能送给你一个你完全喜欢的人。合适的人不是靠遇见的，是上帝给足够成熟，愿意付出和相互改变的两个人的真贵的礼物。像榫和卯，没天生的，都是雕刻和彼此痛苦的改变之后的一种契合</p>
</li>
<li><p>其实，一段刻骨铭心的爱情有两个步骤。一是遇见，二是相处。遇见需要缘分，相处需要智慧</p>
</li>
<li><p>人事在世如身处荆棘之中，心不动，人不妄动，不动则不伤；如心动则人妄动，伤其身痛其骨，于是体会到世间诸般痛苦</p>
</li>
<li><p>对一个你明知道他喜欢你，而你又不喜欢他的人，请记得至少做到，不要在寂寞的时候找他。这是对感情的尊重，也是对别人的放过</p>
</li>
</ol>
]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>天下有大勇者</title>
    <url>/2021/07/28/%E5%A4%A9%E4%B8%8B%E6%9C%89%E5%A4%A7%E5%8B%87%E8%80%85/</url>
    <content><![CDATA[<ol>
<li><p>天下有大勇者，猝然临之而不惊，无故加之而不怒。此其所挟持者甚大，而其志甚远也</p>
</li>
<li><p>如果你想要你从未拥有过的东西，那么你必须去做你从来未做过的事</p>
</li>
<li><p>感情问题不是理科题，有标准答案，每两个人的结合都可能是一种独特的化学反应，难以片面分析</p>
</li>
</ol>
<span id="more"></span>

<ol start="4">
<li><p>感动不是爱情，爱情根本不需要这么累，你追我跑，那是狩猎，我又不是猎物</p>
</li>
<li><p>一生匆匆，不能因为任何外因而放弃追随自己的心</p>
</li>
<li><p>《圣经·传道书》第三章说：世间万物皆有定时，生有时，死有时，悲恸有时，跳舞有时，花开有时，凋零有时。第一次看，颇有宿命论的感觉，但现在思量，这章无非是想告诉世人，人间万物瞬息万变，悲喜无常，却也总有那最合适的因缘和时机，花开也自有凋零时，花开须折直须折，莫待无花空折枝啊！生命中那些最美好的东西，都是转瞬即逝，春之落樱，夏之花火，秋之红枫，冬之飞雪，错过了那个时刻，就永远不是那个味道</p>
</li>
<li><p>如果你希望一个人爱你，最好的心理准备就是不要让自己变成非爱他（她）不可，你要坚强独立，自求多福，让自己成为自己生活的重心，有寄托，有目标，有光辉，有前途……总之，让自己有足够多可以使自己快乐的源泉，然后再准备接受或不接受对方的爱       ——《罗兰小语》</p>
</li>
<li><p>喜欢一个人本是一件多么美好的事，它应该带来温暖与治愈，宁静与安心</p>
</li>
<li><p>希望每一个在爱中的人都能够尽可能做到：不欺人，不自欺，也不被人欺</p>
</li>
<li><p>朝闻道，夕死可矣</p>
</li>
<li><p>我行过许多地方的桥，看过许多次数的云，喝过许多种类的酒，却只爱过一个正当最好年龄的人</p>
</li>
<li><p>因为有了和你在一起的故事，它就是对于你来说，最好的，唯一的，不可取代的</p>
</li>
</ol>
]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>有一个可以想念的人</title>
    <url>/2021/07/28/%E6%9C%89%E4%B8%80%E4%B8%AA%E5%8F%AF%E4%BB%A5%E6%83%B3%E5%BF%B5%E7%9A%84%E4%BA%BA/</url>
    <content><![CDATA[<ol>
<li><p>什么事都以功利的眼光去衡量，人生未免太无趣了</p>
</li>
<li><p>有一个可以想念的人，就是幸福</p>
</li>
<li><p>你从身边走过，却改变了我的季节</p>
</li>
</ol>
<span id="more"></span>

<ol start="4">
<li><p>所有你乐于挥霍的时间都不能算作浪费</p>
</li>
<li><p>没有了安全感，爱情便什么都不是</p>
</li>
<li><p>人生的很多甚至大部分痛苦来自于对于自我的错误认识</p>
</li>
<li><p>我对你好，但也请你，对我好一点</p>
</li>
<li><p>你希望这个世界如何并不重要，重要的是你认清这个世界事实上是怎么样的，并在接受这样的事实前提下努力去做一点事情</p>
</li>
<li><p>在你没有变成你想成为的人的时候，你所遇到的永远不是对的人</p>
</li>
<li><p>草在结他的籽，树在摇他的叶，我们站着，不说话，就十分美好</p>
</li>
<li><p>你是什么样的人，你就拥有什么样的世界</p>
</li>
</ol>
]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>有的人吧</title>
    <url>/2021/07/29/%E6%9C%89%E7%9A%84%E4%BA%BA%E5%90%A7/</url>
    <content><![CDATA[<ol>
<li><p>有的人吧，他可以选锦衣玉食，也可以选粗茶淡饭，可以选咖啡红酒，也可以选白开水。这样的人，他说喜欢喝白开水，那就是真的喜欢喝白开水。有的人，买不起锦衣玉食，选不了咖啡红酒，他说喜欢喝白开水，但是哪天你哪怕在他面前放一杯可乐，他都会扔掉那杯白开水</p>
</li>
<li><p>所谓恋爱啊，只要参加了就是有意义的，即使是没有结局。当你喜欢上一个人的那一霎，是永远都不会消失的。这都将会变成你活下去的勇气，而且会变成你在黑暗中的一线曙光。我一直相信，你一定会喜欢上我的</p>
</li>
<li><p>不是常常有机会遇到可以爱他一生的人的，不过喜欢上的话就是另外一回事了，所以…所以我很珍惜爱过你的一切回忆，我真的这么想哦！爱过你的回忆，被你爱过的回忆，一直都好好地在这儿（心口）。不是能想着明天爱情会变得怎么样而谈着恋爱的，就是有那时候的我，才有现在的自己。我真的能够对自己这么说：你做得真好。不管在做什么，我就是我自己</p>
</li>
</ol>
<span id="more"></span>

<ol start="4">
<li><p>在这个城市里，我坚持的相信一定会有那么一个人，想着同样的事情，怀着相似的频率，在某站寂寞的出口，安排好了与我相遇</p>
</li>
<li><p>是的，所有关注这个话题，所有点赞所有评论的人，无论说了什么，心里都是舍不得放不下【真心】的人。我们男人同女人一样，渴望真心，渴望挚爱，渴望付出。我们没有看破红尘，没有绝望，我们一直在希望，在等待，等待这漫长漫长的黑夜终有光亮的一天</p>
</li>
<li><p>我们都想，得一人心足矣</p>
</li>
<li><p>不可胜在己，可胜在敌。胜不可为</p>
</li>
<li><p>紧张一个人，一件事，就是因为你在乎。有多在乎，就有多紧张</p>
</li>
<li><p>做事靠谱是一个毕业生最可贵的素质，没有之一</p>
</li>
<li><p>就像童话中两个贪心的人挖地下的财宝，结果挖出一个人的骸骨，虽然迅速埋上了，甚至在上面种了树，栽了花，但都清楚地知道底下埋的是什么。看见树，看见花，想的却是地下的那具骸骨</p>
</li>
<li><p>曾经亲手盖过一栋漂亮的房子，突然有一天莫名其妙的崩塌，露出了地基下的森森白骨，我又亲手清理了破碎的砖瓦，却不敢再盖房子，只能种上鲜花。每年花开的时候，我都会来这里，别人都以为我在看花，其实我看到的只有白骨</p>
</li>
<li><p>只是缘分尽了而已，缘起自有缘灭，和万物的最终结局一样</p>
</li>
<li><p>想象有两个世界，一个世界有你，一个世界没有你，两者之间的不同就是你生命的意义</p>
</li>
<li><p>死亡是无法战胜的东西，而生前的陪伴，可以让死亡变得不那么可怕</p>
</li>
<li><p>为了一个不知能否实现的愿望，人有时会豁出一辈子的。笑其愚蠢的人，毕竟只是人生中的过客而已</p>
</li>
<li><p>不要那么孤独，请相信，这个世界上真的有人在过着你想要的生活</p>
</li>
<li><p>爱是两情相悦，你情我愿，又不是在自由市场挑西红柿，非要找性能价格比最合理的</p>
</li>
<li><p>她想要的，不过是一个能在寒夜里带给她温暖和希望，拉着她的手带着她穿山越岭，让她无惧荒郊黑夜的男人</p>
</li>
<li><p>如果我不曾见过太阳，我本可以忍受黑暗</p>
</li>
<li><p>喜欢你甚于昨日，略匮明朝</p>
</li>
<li><p>你不能在拥有爱情时惧怕失去爱情，更不能像我一样，在失去爱情以后憎恨爱情</p>
</li>
<li><p>我对世界骄傲，但不介意对你温柔，而你的快乐，就是我们的快乐</p>
</li>
<li><p>你这种年轻人我见的多啦，懂一点武功就以为可以横行天下，其实走江湖是一件很痛苦的事。会武功，有很多东西不能做。你不想耕田吧？又不耻去打劫，更不想抛头露面在街头卖艺，你怎么生活？</p>
</li>
<li><p>和一个自己爱的人去争什么输赢，吵赢了有怎样，低头认输又怎样</p>
</li>
<li><p>让我有最原始的生理冲动接近她，又有最高级的心理状态想去保护她</p>
</li>
<li><p>最恐怖的不是鬼神，而是人心</p>
</li>
<li><p>庭有枇杷树，吾妻死之年所手植也，今已亭亭如盖矣</p>
</li>
<li><p>婚姻不是为了获取，而是为了更好的付出</p>
</li>
<li><p>遇见，就不要错过。珍惜且珍惜</p>
</li>
<li><p>毕竟既然生命中有过一个女孩如此对你，你这辈子就不可以堕落。你得告诉所有人，她当年爱过的人，值得她爱</p>
</li>
<li><p>其实我想说的是，这世界上没有任何人值得你为了不回短信而苦恼的（除非你担心她出了什么意外），所有人或早或晚都会离你而去，或者你离他们而去，人生就是一部不知什么时候会被砍掉的美剧</p>
</li>
<li><p>如果你喜欢一个事，又有这样的才干，那就把整个人都投入进去，就要像一把刀扎下去直到刀柄一样，不要问为什么，也不要管会碰到什么</p>
</li>
<li><p>女孩子青春何其宝贵，那些时光交付给你，除了寄望于与你长相厮守外，只为最好的年华和一个值得的人一起走过，换取在一起的快乐回忆，留待日后珍藏；只要一起快乐过，那些青春便不算浪掷</p>
</li>
<li><p>如果真的有个曾经喜欢你，却最后没能在一起的姑娘让你心存歉意，至少为了她，也请你努力一点；因为你能为了她做最好的事，就是让自己配得上她的青春，让她想起你会觉得骄傲，而不是年轻时的一场荒唐。到最后，感情分崩离析，唯有旧时光不可辜负。我们都希望自己爱过的是个美好的人，哪怕是在我们看不见的地方</p>
</li>
<li><p>许多东西记下来，就是在心里生根。日后触景生情，总会懂的</p>
</li>
<li><p>你走，我不送你。你来，无论多大风多大雨，我要去接你。你要走便走，我不会留</p>
</li>
<li><p>人生而趋利避害，所谓人的感情，也不过是遵从这个趋利避害的基础上，更加显得有人情味一点罢了</p>
</li>
<li><p>在这个时间被微博微信碎片化的时代，还是有一些事值得我们单线程地事前花心思计划，事中用心执行，事后细细回味的。因为这些事情能给我们带来无法言说并且不能复制的美妙体验</p>
</li>
</ol>
]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>2021-08</title>
    <url>/2021/08/02/2021-08/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码看着不太对, 请再试试." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">
  <script id="hbeData" type="hbeData" data-hmacdigest="db568fc20baf7540e83ed73d4e8cba448b154f2375846ff4e75a392a6e95929e">21b5bcc0e4657ce349e1a94ae87ceae177e19bfdd8f117aa27ee9fb5fc3b17b35f5f40d8365cb771cfeb0fede49c3bc588f44bee9f68840bb37842909f10230c3811640631425f340116d708482039fb9ad411c92d61983cc993c37d6745d1c18ef784a5dff3c9a6f5003787e7afd3fc1470189ed1d0e98c434ab1c4012921d42289ee0e6140a7dadf1a2c0a074b5ab4e5eb64be1dd65a6b8e40438066cb5a877d4a30e6a1f27e77e53d3b5c234aa12b2282890ef45b3cb5147f3c2a30932929f445fc08bee2a818740004c7db36a80ff52456129acc8472eeaf8cfc1bdfefa76e9b76035226fe005f773dedd8173a629baf0acf14848997c91dfa3879f058f8dc304947a75038b3c753b60c3ef238fafe94aa12e15d7223ec4ea940b3bc84f879c44c1c94c6d498259fe8daab89ab501ae50922d2f4dbe09074a7812b7de9bb321b72e06d69a1e5d7a0d652c100b50f389a2fb181290ab5afa576d1ba1c2e95d93dca5b97d224671ccb92166b1f71f4d3453d03b0d757305e2ebda2724706dc89e78321fbe3a6ed2056c1a5c23c9cb9491ce36a613f6ed1b87fb0416ad5dd7dfff09e600fe200925316d027207a8c1f7bf4a272b19479fdc412029d733376ad9f2f41288c481cb4e57cc38a883920f3d59b1b1240c34485efd772afc2bf1a69053dc645ed8a02e7cc5320f8d63307f13e61f82ebf6ce654509e3ac7a2f150df53ee831602af79bb8f7985f87c6c5b0843ea5947efcce3121ef634f81aae3cdb56470b882f96edb1b04bd363f56048a91f502f543902df0d7ef21154ba7443fe8b7a5adeca3babcf8aec4266932a75076e2b463c62406ff628d8c8e8cc506a2609e4dea3282443550f8ae7dfeb642a483a7b5d8557e83739b5456d502141e61a5f1b66232142f5b0df0c099605ad1bac969ce6852a4ed1bbf1598daafb4785b16b583753b2823d27732f9b226891f5d0e322ca02ce48236c2367d55bfdfaf8eeb0f4a009fb894e7196c8439b101f0efb171e17fa1c1b92c4575cc1af5323e587ccea52cd80a148464c55a904cc60d5ea011f08e140d4874a52b259bba9ba6d66372c45aa34fe287b6c2703e6acadad8dfcf2b1c77b7379a851ea5f51f9c320ef58e7e470c77a659ebc9cff9db94c18f4054ca576418788cb537ca53b095ba37c4cd83aefcce66ed56d08be125625b5acdca5c3c28282da41a387db0f49c9e34148bcbae207b7e8f0413f6ad72f1b0632028bc0d35d2b7b58350162d8a08cb76252e68f88ac3a15fb81d2ec213a44d025d84d7737c9324cebbe108f0ec06f5627ec73512201ef5cc519e048f8eeb3942c26fb5e28284490d762d11713ad7aec7f3785cb1085ac14111613aadab5102938</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-shrink">
      <input class="hbe hbe-input-field hbe-input-field-shrink" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-shrink" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-shrink">您好, 这里需要密码.</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>月度总结</category>
      </categories>
      <tags>
        <tag>月度总结</tag>
      </tags>
  </entry>
  <entry>
    <title>告白与告别</title>
    <url>/2021/08/02/%E5%91%8A%E7%99%BD%E4%B8%8E%E5%91%8A%E5%88%AB/</url>
    <content><![CDATA[<ol>
<li><p>因为你没有证明自己的胆量，你就不要去怪别人异样的眼光</p>
</li>
<li><p>人可以不上学，但一定要学习</p>
</li>
<li><p>反正常常是这样，你其实已经在第一把触摸到几乎最好的东西了，但因为它来的太早，所以你还在不断找寻，总觉得自己不应该这么轻易得到</p>
</li>
</ol>
<span id="more"></span>

<ol start="4">
<li><p>很多人都是在自认为骑着驴找马的过程中把自己胯下那匹真正的好马放走了。对于那些骑马找马的人，只能说，珍惜“裆”下</p>
</li>
<li><p>从小到大的很多经历告诉我，这个世界上，除了自己，除了至亲，没有人在乎你的痛苦。你能让大家高兴就行了，或者无感地存在也是个好方式。但你如果太在意自己的痛苦，或者太想让他人在意你的痛苦，真会让自己陷入被忽略的痛苦，甚至是表演痛苦的痛苦</p>
</li>
<li><p>这个世界上永远没有百分之一百准备好的事情，最充分的准备往往意味着你错过了一切</p>
</li>
<li><p>与其让别人来做砸了，不如自己来，好歹砸也是砸在自己手里</p>
</li>
<li><p>人生特别有限，老在回头看自己做过的东西，我会觉得无意义，虚度光阴</p>
</li>
<li><p>到后来我就不想在继续下去了，我往往在做事情的时候兴高采烈，但在这个过程中热情也就随之过去了，对我来讲已经完成了</p>
</li>
<li><p>像这样的处理方式，很容易跟别人产生创作分歧，跟别人阐述自己想法的时间，不如自己写</p>
</li>
<li><p>我总希望，作为朋友，当我找你的时候，大家都能够因此而得到快乐，以及好处吧</p>
</li>
<li><p>我觉得真正的地位是无须靠你站的位置来获得的，而你越在乎这些，也就说明你还没在那个地位上</p>
</li>
<li><p>创作就是要在绝对谦逊地学习聆听磨炼之后实施绝对的独裁</p>
</li>
<li><p>人都有不痛快的时候，但绝对不能放在表面上，因为这绝对不是你真性情的表现，而是一种不负责任的表现</p>
</li>
<li><p>适当的妥协不是委屈自己或者所谓怂，而是使事情更容易接近你的目标</p>
</li>
<li><p>人要通过很多努力，让自己更加厉害，比起那些用大嗓门企图压制世界的人，让全世界都安静下来听你小声说话的人更可畏</p>
</li>
<li><p>我在赛车之前，遇到的是不理解和嘲笑，现在我是七届总冠军。但我在游泳之前，我遇到的是支持和吹捧，但我依然游不好。别人的眼光不重要，你把事情做成什么样子才重要</p>
</li>
<li><p>所以，作品好，这些都是特点；作品不好，这些都是缺点，反正就是这么现实</p>
</li>
<li><p>不会有人喜欢倾听你的痛苦，说给朋友，朋友不好受；说给敌人，敌人更开心</p>
</li>
<li><p>人的一生会看到许多风景，如果你被困在一个风景里，就看很难看到下一个风景</p>
</li>
<li><p>有多少人听过很多道理，却依然过不好这一生</p>
</li>
<li><p>这是他希望成为，却又永远无法成为的人</p>
</li>
<li><p>相逢有时，后会无期</p>
</li>
<li><p>洞穴人始终被束缚住手脚，终日只能观看眼前人造的稀薄虚假影像度日，他们安分守己，以为这就是世界。而终于有一个年轻人决定挣脱枷锁，出去走一走，看见了真实世界，他欢呼着把这个信息带给伙伴们，而洞穴人们以为他是疯子，把他杀了</p>
</li>
<li><p>生命就是用来燃烧的</p>
</li>
<li><p>而在我眼里，韩寒骨子里始终是那个上海亭林镇东村村头热爱摩托喜欢追风每天都要洗头的不羁少年。在界定少年的标准里，最重要的一条就是义气</p>
</li>
<li><p>世界所有光芒都是一场远行，它们从太阳出发，只是为了去未知的地球看一眼</p>
</li>
<li><p>不需要大门向我们打开，因为我们自己就是钥匙</p>
</li>
<li><p>音乐不应该只是简单地用音色旋律来渲染电影，我想音乐是组成电影的各个元素中所需要的之一</p>
</li>
<li><p>也许因为原野太辽阔了，草原狼找到自己的同类并不是件容易的事。所以当风带来一缕熟悉的味道时，它们总会兴奋地仰首远眺，互相发出善意的嚎叫。然后，没有任何中间过程，它们就能建立起深刻的信任，它们一起在草原与河流之间合作狩猎，一起奔跑在无尽的阳光里，然后在下一个雨季来临前分道扬镳。这样的事情，很美好</p>
</li>
</ol>
]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>1988：我想和这个世界谈谈</title>
    <url>/2021/08/05/1988%EF%BC%9A%E6%88%91%E6%83%B3%E5%92%8C%E8%BF%99%E4%B8%AA%E4%B8%96%E7%95%8C%E8%B0%88%E8%B0%88/</url>
    <content><![CDATA[<ol>
<li><p>以此书纪念我每一个倒在路上的朋友，更以此书献给你，我生命里的女孩们，无论你解不解我的风情，无论我解不解你的衣扣，在此刻，我是如此地想念你，不带们</p>
</li>
<li><p>数火车是多么消磨时间的方式，唯一的缺点就是没有办法验算</p>
</li>
<li><p>无论是多么面目狰狞的人们，除了他们指着鼻子骂我以外，我其实始终都能记得他们不经意间的叹息，我不认为那是人类在压迫下容易满足的贱，而是不经意间流露出来本是同类的交流。但当我想去挖掘的时候，大地马上就把井盖给盖住了，说，朋友，你想都不要想</p>
</li>
</ol>
<span id="more"></span>

<ol start="4">
<li><p>我要从这里出发，沿着318号国道，开到那里的尽头。不要以为这只是一场肤浅的自驾游，不要以为我是无根的漂泊，我的根深深地扎在这片土地上，我一度以为自己是种子，被这季风吹来吹去，但是我终于意识到，我不是种子，我就是连着根的植物，至于我是一棵什么样的植物，我看不到我自己，那得问其他的植物，至于我为什么一直在换地方，因为我以为我扎在泥土里，但其实我扎在了流沙中。<br>这么多年来，一直是我脚下的流沙裹着我四处漂泊，它也不淹没我，它只是时不时提醒我，你没有别的选择，否则你就被风吹走了。我就这么浑浑噩噩地度过了我所有热血的岁月，被裹到东，被裹到西，连我曾经所鄙视的种子都不如。</p>
</li>
<li><p>我说，我的资讯有点爆炸，你让我记了四个人名</p>
</li>
<li><p>我发现我生命里所崇拜的都是那些热血的人们，虽然我不是一个冷血的人，但我的血液是温的，我总是喜欢看见那些热血的人们，我希望我成为他们中的一个。我总是发现，当我在发呆的时候，他们已经在思考了，当我在思考的时候，他们已经行动了，当我行动的时候，他们已经翘了，然后我又不敢行动了。翘了的他们就成为我生命里至高的仰望。我天生佩服他们，希望他们身上的血能够温热我的身体</p>
</li>
<li><p>你懂得越多，你就越像这个世界的孤儿</p>
</li>
<li><p>我愿意伸手，但我不愿意插手</p>
</li>
<li><p>因为我坚信，世界就像一堵墙，我们就像一只猫，我必须要在这个墙上留下我的抓痕，在此之前，我才不会把爪子对向自己</p>
</li>
<li><p>这就是日复一日机械的工作带给人们的恶果。它让人无一例外地忘记自己最初的理想</p>
</li>
<li><p>我就如同一只幼犬，面对着一块比自己还要大的骨头，不知道从何下口</p>
</li>
<li><p>我说，我坚信邪恶不能压倒正义。<br>他抿了一小口，说，嗯，但是他们可以定义正义和邪恶</p>
</li>
<li><p>但这对婊子和戏子都不公平，我们的一生很难对婊子动情，很难对戏子动心，纵然我对婊子动情，婊子也很少赠我真情，纵然我对戏子动心，戏子也未必还我真心</p>
</li>
<li><p>见你是比天大的事情。我想，天大地大，莫过于此</p>
</li>
<li><p>我就像这个世界，这个世界是不会变的，来适应这个世界吧</p>
</li>
<li><p>但我至少等待过，我知道你从不会来，但我从不怀疑你彼时的真心，就如同我的每一个谎言都是真心的</p>
</li>
<li><p>我拍了拍衣服，想那又如何，反正我也是被他们笼罩着的人，他们先行，我替他们收拾着因为跑太快从口袋里跌落的扑克牌，我始终跑在他们划破的气流里，不过我也不曾觉得风阻会减小一些，只是他们替我撞过了每一堵我可能要撞的高墙，摔落了每一道我可能要落进的沟壑，然后告诉我，这条路没有错，继续前行吧，但是你已经用掉了一次帮助的机会，再见了朋友。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>我喜欢你</title>
    <url>/2021/08/04/%E6%88%91%E5%96%9C%E6%AC%A2%E4%BD%A0/</url>
    <content><![CDATA[<ol>
<li><p>阳光从叶子的怀抱里穿梭，影子斑驳，岁月晶莹</p>
</li>
<li><p>我喜欢你，你喜欢我吗？</p>
</li>
<li><p>女生说，你要帮我。<br>男生说，好。<br>女生说，不要骗我。<br>男生说，好。</p>
</li>
</ol>
<span id="more"></span>

<ol start="4">
<li><p>你为谁冲锋陷阵，谁为你捡拾骸骨</p>
</li>
<li><p>真正的爱无需表白，所有成功的表白不过是双方早已写好剧本的一场戏而已</p>
</li>
<li><p>我爱你，若你不爱我，那么去你（哔）的</p>
</li>
<li><p>大丈夫行事，论是非，不论利害；论顺逆，不论成败；论万世，不论一生     ——黄宗羲</p>
</li>
<li><p>每个女孩都是我们人生的烛火，照亮了我们每段时期疯狂追求爱情的动人姿态，帮助我们这些男孩，一步一步，成为像样的男子汉。我们所要做的，就是再多喜欢那女孩一点。再多一点，再多一点一点。只要够喜欢，就没有办不到的等待。</p>
</li>
<li><p>等待，要有一个最简单的理由，就够了</p>
</li>
<li><p>逃避，就一直是输家。唯有面对，才熟要赢的第一步</p>
</li>
<li><p>当世界年纪还小的时候，洋葱、萝卜和西红柿，不相信世界上有南瓜这种东西。它们认为那是一种空想。南瓜不说话，默默地成长着</p>
</li>
<li><p>你怎么就不明白呢？这个世界是不会为你而改变的。我和这个世界一样，是不会为你而改变的      ——《牯岭街少年杀人事件》</p>
</li>
<li><p>《牯岭街少年杀人事件》有这么一句台词，我和这个世界一样，这个世界是不会改变的。我不这么认为。我会变，这个世界也会变。有可能有个人因为读了某篇文章，受到某个人观点的影响，就真的改变了世界</p>
</li>
<li><p>我们现在所经历的迷茫和窘境，其实就归咎于过去不愿面对的改变或多年来不曾根治的恶习，如果因为做一件事而无法坚持，那么到了20多岁需要对外界承担一份责任时，就欠自己一个交代</p>
</li>
<li><p>别给自己找太多放弃的理由，因为比你好的人还在坚持。而这个世界上所有的坚持，都是因为热爱</p>
</li>
<li><p>祝我们再遇见，都能比现在过得更好</p>
</li>
<li><p>以后还有很漫长很漫长的路途，都要一个人走完。都要靠自己，凭借自己的能力去完成，而不是依靠谁      ——《千与千寻》</p>
</li>
<li><p>我只是想告诉你，如果你一无所长，脑子里什么东西都没有，你以后还会碰到无数个许言言，但是你一个都抓不住</p>
</li>
<li><p>世界上有那么多人，这么对我的，偏偏不是许言言。她像一把刀子，我用她来搅动我的心。虽然痛但是却乐此不疲</p>
</li>
<li><p>一个人在没有成为最好的自己之前，也不配拥有最好的对方</p>
</li>
<li><p>而那一条没有风，没有人的街，就像我们如今的内心。它曾经人来人往过，热闹过，可是每当夜晚来临，它却只是一个人卧在黑暗里，静静地想，什么时候，只要有一盏路灯亮，一盏就好了</p>
</li>
<li><p>总有一天，会有一个人，看你写过的所有状态，读完写的所有微博，看你从小到大的所有照片，甚至去别的地方寻找关于你的信息，甚至听你听的歌，走你走过的地方，看你喜欢看的书，品尝你总是大呼好吃的东西……只是想弥补上，你的青春——他迟到的时光</p>
</li>
<li><p>七岁那年，我抓住一只蝉，以为抓住了整个夏天。十七岁的那年，我吻过他的脸，就以为能和她永远</p>
</li>
<li><p>每当我找不到存在的意义，每当我迷失在黑夜里，夜空中最亮的星，请照亮我前行</p>
</li>
<li><p>真爱的第一个征兆，在男孩身上是胆怯，在女孩身上是大胆</p>
</li>
<li><p>坐在前桌的某某，你是我十七岁时爱上的女孩，如今，各自安好，我不打扰，致我那美好的高三岁月</p>
</li>
<li><p>我们都生活在阴沟里，但仍然有人仰望星空<br>We are all in the gutter, but some of us are looking at the star</p>
</li>
</ol>
]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>那时候爱上一个人</title>
    <url>/2021/08/14/%E9%82%A3%E6%97%B6%E5%80%99%E7%88%B1%E4%B8%8A%E4%B8%80%E4%B8%AA%E4%BA%BA/</url>
    <content><![CDATA[<ol>
<li><p>老了，就是对身边的事情逐渐习以为常       ——茨威格</p>
</li>
<li><p>那时候爱上一个人不是因为你有车有房，而是那天下午阳光很好，你穿了一件白衬衣</p>
</li>
<li><p>我是一个不愿意给别人添麻烦的人</p>
</li>
</ol>
<span id="more"></span>

<ol start="4">
<li><p>不管你对多少异性失望，你都没有理由对爱情失望。因为爱情本身就是希望，永远是生命的一种希望。爱情是你自己的品质，是你自己的心魄，是你自己的处境，与别人无关     ——史铁生</p>
</li>
<li><p>一个人的性格决定他的际遇。如果你喜欢保持你的性格，那么你就无权拒绝你的际遇       ——罗曼·罗兰</p>
</li>
<li><p>那一刻，我有些淡淡的心酸</p>
</li>
<li><p>世间最难得的事是，恰好在这个时间，你喜欢我，我也喜欢你</p>
</li>
<li><p>从来都是因为不爱，我们才敢肆无忌惮</p>
</li>
<li><p>爱情就是因为有人把你视若珍宝费劲心机才会这样动人</p>
</li>
<li><p>如果少年时代听得进过来人的建议，那少年便不为少年，世间也不再会有那么多重复的烦恼</p>
</li>
<li><p>你怕不怕，你一个转身，你最亲的人就跟你擦肩而过，再也不能见了呢？</p>
</li>
<li><p>我以为我的眼里会出现别人，但除了她再也没有别人了</p>
</li>
<li><p>在其位，谋其职</p>
</li>
<li><p>世界是道德的世界，人却非道德之人    ——尼采</p>
</li>
<li><p>我赢了全世界又如何？偏偏负了你</p>
</li>
<li><p>质量是设计制造出来的，不是检验出来的。如果能关注每一个细节，就可以实现零缺陷的目标</p>
</li>
<li><p>凡有的，还要加给他，叫他有余；没有的，连他所有的也要夺过来      ——《圣经·马太福音》</p>
</li>
<li><p>天之道，损有余而补不足；人之道则不然，损不足以奉有余        ——《道德经》</p>
</li>
<li><p>有些人注定是要一生孤独的</p>
</li>
<li><p>看尽世间悲凉，更感人生可贵</p>
</li>
<li><p>表虽已枯，其心不灭</p>
</li>
<li><p>为政以德，譬如北辰，居其所而众星共之    ——孔子</p>
</li>
<li><p>七月繁花夏中央，晴丝千尺挽韶光</p>
</li>
<li><p>看清这个世界，然后爱她      ——罗曼·罗兰</p>
</li>
<li><p>情之所钟，心之所梦</p>
</li>
<li><p>我不是归人，只是过客</p>
</li>
<li><p>当你们出门，到世界上去走走，不要忘了，手拉手紧挨在一起</p>
</li>
<li><p>陌路伊始，相爱无期</p>
</li>
<li><p>道路是曲折的，但前途是光明的</p>
</li>
<li><p>安好，勿念，各自精彩</p>
</li>
<li><p>The world is small and the city is big.People who lack for luck would not see one another again for the rest of life.<br>世界很小，城市很大，欠缺缘分的人也许终生也不会再见了。</p>
</li>
<li><p>这个世界很小，我们就这样遇见。这个世界很大，分开就很难再见</p>
</li>
</ol>
]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
      </tags>
  </entry>
</search>
